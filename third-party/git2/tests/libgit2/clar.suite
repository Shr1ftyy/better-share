extern void test_apply_both__generated_diff(void);
extern void test_apply_both__parsed_diff(void);
extern void test_apply_both__removes_file(void);
extern void test_apply_both__adds_file(void);
extern void test_apply_both__application_failure_leaves_index_unmodified(void);
extern void test_apply_both__index_must_match_workdir(void);
extern void test_apply_both__index_mode_must_match_workdir(void);
extern void test_apply_both__application_failure_leaves_workdir_unmodified(void);
extern void test_apply_both__keeps_nonconflicting_changes(void);
extern void test_apply_both__can_apply_nonconflicting_file_changes(void);
extern void test_apply_both__honors_crlf_attributes(void);
extern void test_apply_both__rename(void);
extern void test_apply_both__rename_and_modify(void);
extern void test_apply_both__rename_a_to_b_to_c(void);
extern void test_apply_both__rename_a_to_b_to_c_exact(void);
extern void test_apply_both__rename_circular(void);
extern void test_apply_both__rename_2_to_1(void);
extern void test_apply_both__rename_1_to_2(void);
extern void test_apply_both__two_deltas_one_file(void);
extern void test_apply_both__two_deltas_one_new_file(void);
extern void test_apply_both__rename_and_modify_deltas(void);
extern void test_apply_both__rename_delta_after_modify_delta(void);
extern void test_apply_both__cant_rename_after_modify_nonexistent_target_path(void);
extern void test_apply_both__cant_modify_source_path_after_rename(void);
extern void test_apply_both__readd_deleted_file(void);
extern void test_apply_both__cant_remove_file_twice(void);
extern void test_apply_both__cant_add_invalid_filename(void);
extern void test_apply_both__initialize(void);
extern void test_apply_both__cleanup(void);
extern void test_apply_callbacks__delta_aborts(void);
extern void test_apply_callbacks__delta_can_skip(void);
extern void test_apply_callbacks__hunk_can_skip(void);
extern void test_apply_callbacks__initialize(void);
extern void test_apply_callbacks__cleanup(void);
extern void test_apply_check__generate_diff(void);
extern void test_apply_check__parsed_diff(void);
extern void test_apply_check__binary(void);
extern void test_apply_check__does_not_apply(void);
extern void test_apply_check__initialize(void);
extern void test_apply_check__cleanup(void);
extern void test_apply_fromdiff__change_middle(void);
extern void test_apply_fromdiff__change_middle_nocontext(void);
extern void test_apply_fromdiff__change_firstline(void);
extern void test_apply_fromdiff__lastline(void);
extern void test_apply_fromdiff__change_middle_and_lastline_nocontext(void);
extern void test_apply_fromdiff__prepend(void);
extern void test_apply_fromdiff__prepend_nocontext(void);
extern void test_apply_fromdiff__prepend_and_change(void);
extern void test_apply_fromdiff__prepend_and_change_nocontext(void);
extern void test_apply_fromdiff__delete_and_change(void);
extern void test_apply_fromdiff__delete_and_change_nocontext(void);
extern void test_apply_fromdiff__delete_firstline(void);
extern void test_apply_fromdiff__append(void);
extern void test_apply_fromdiff__append_nocontext(void);
extern void test_apply_fromdiff__prepend_and_append(void);
extern void test_apply_fromdiff__to_empty_file(void);
extern void test_apply_fromdiff__from_empty_file(void);
extern void test_apply_fromdiff__add(void);
extern void test_apply_fromdiff__delete(void);
extern void test_apply_fromdiff__no_change(void);
extern void test_apply_fromdiff__binary_add(void);
extern void test_apply_fromdiff__binary_no_change(void);
extern void test_apply_fromdiff__binary_change_delta(void);
extern void test_apply_fromdiff__binary_change_literal(void);
extern void test_apply_fromdiff__binary_delete(void);
extern void test_apply_fromdiff__patching_correctly_truncates_source(void);
extern void test_apply_fromdiff__initialize(void);
extern void test_apply_fromdiff__cleanup(void);
extern void test_apply_fromfile__change_middle(void);
extern void test_apply_fromfile__change_middle_nocontext(void);
extern void test_apply_fromfile__change_firstline(void);
extern void test_apply_fromfile__lastline(void);
extern void test_apply_fromfile__change_middle_shrink(void);
extern void test_apply_fromfile__change_middle_shrink_nocontext(void);
extern void test_apply_fromfile__change_middle_grow(void);
extern void test_apply_fromfile__change_middle_grow_nocontext(void);
extern void test_apply_fromfile__prepend(void);
extern void test_apply_fromfile__prepend_nocontext(void);
extern void test_apply_fromfile__append(void);
extern void test_apply_fromfile__append_nocontext(void);
extern void test_apply_fromfile__prepend_and_append(void);
extern void test_apply_fromfile__to_empty_file(void);
extern void test_apply_fromfile__from_empty_file(void);
extern void test_apply_fromfile__add(void);
extern void test_apply_fromfile__delete(void);
extern void test_apply_fromfile__rename_exact(void);
extern void test_apply_fromfile__rename_similar(void);
extern void test_apply_fromfile__rename_similar_quotedname(void);
extern void test_apply_fromfile__modechange(void);
extern void test_apply_fromfile__modechange_with_modification(void);
extern void test_apply_fromfile__noisy(void);
extern void test_apply_fromfile__noisy_nocontext(void);
extern void test_apply_fromfile__fail_truncated_1(void);
extern void test_apply_fromfile__fail_truncated_2(void);
extern void test_apply_fromfile__fail_truncated_3(void);
extern void test_apply_fromfile__fail_corrupt_githeader(void);
extern void test_apply_fromfile__empty_context(void);
extern void test_apply_fromfile__append_no_nl(void);
extern void test_apply_fromfile__fail_missing_new_file(void);
extern void test_apply_fromfile__fail_missing_old_file(void);
extern void test_apply_fromfile__fail_no_changes(void);
extern void test_apply_fromfile__fail_missing_hunk_header(void);
extern void test_apply_fromfile__fail_not_a_patch(void);
extern void test_apply_fromfile__binary_add(void);
extern void test_apply_fromfile__binary_change_delta(void);
extern void test_apply_fromfile__binary_change_literal(void);
extern void test_apply_fromfile__binary_delete(void);
extern void test_apply_fromfile__binary_change_does_not_apply(void);
extern void test_apply_fromfile__binary_change_must_be_reversible(void);
extern void test_apply_fromfile__empty_file_not_allowed(void);
extern void test_apply_fromfile__initialize(void);
extern void test_apply_fromfile__cleanup(void);
extern void test_apply_index__generate_diff(void);
extern void test_apply_index__parsed_diff(void);
extern void test_apply_index__removes_file(void);
extern void test_apply_index__adds_file(void);
extern void test_apply_index__modified_workdir_with_unmodified_index_is_ok(void);
extern void test_apply_index__application_failure_leaves_index_unmodified(void);
extern void test_apply_index__keeps_nonconflicting_changes(void);
extern void test_apply_index__can_apply_nonconflicting_file_changes(void);
extern void test_apply_index__change_mode(void);
extern void test_apply_index__initialize(void);
extern void test_apply_index__cleanup(void);
extern void test_apply_partial__prepend_and_change_skip_addition(void);
extern void test_apply_partial__prepend_and_change_nocontext_skip_addition(void);
extern void test_apply_partial__prepend_and_change_nocontext_abort_addition(void);
extern void test_apply_partial__prepend_and_change_skip_change(void);
extern void test_apply_partial__prepend_and_change_nocontext_skip_change(void);
extern void test_apply_partial__prepend_and_change_nocontext_abort_change(void);
extern void test_apply_partial__delete_and_change_skip_deletion(void);
extern void test_apply_partial__delete_and_change_nocontext_skip_deletion(void);
extern void test_apply_partial__delete_and_change_nocontext_abort_deletion(void);
extern void test_apply_partial__delete_and_change_skip_change(void);
extern void test_apply_partial__delete_and_change_nocontext_skip_change(void);
extern void test_apply_partial__delete_and_change_nocontext_abort_change(void);
extern void test_apply_partial__initialize(void);
extern void test_apply_partial__cleanup(void);
extern void test_apply_tree__one(void);
extern void test_apply_tree__adds_file(void);
extern void test_apply_tree__initialize(void);
extern void test_apply_tree__cleanup(void);
extern void test_apply_workdir__generated_diff(void);
extern void test_apply_workdir__parsed_diff(void);
extern void test_apply_workdir__removes_file(void);
extern void test_apply_workdir__adds_file(void);
extern void test_apply_workdir__modified_index_with_unmodified_workdir_is_ok(void);
extern void test_apply_workdir__application_failure_leaves_workdir_unmodified(void);
extern void test_apply_workdir__keeps_nonconflicting_changes(void);
extern void test_apply_workdir__can_apply_nonconflicting_file_changes(void);
extern void test_apply_workdir__change_mode(void);
extern void test_apply_workdir__apply_many_changes_one(void);
extern void test_apply_workdir__apply_many_changes_two(void);
extern void test_apply_workdir__initialize(void);
extern void test_apply_workdir__cleanup(void);
extern void test_attr_file__simple_read(void);
extern void test_attr_file__match_variants(void);
extern void test_attr_file__assign_variants(void);
extern void test_attr_file__check_attr_examples(void);
extern void test_attr_file__whitespace(void);
extern void test_attr_flags__bare(void);
extern void test_attr_flags__index_vs_workdir(void);
extern void test_attr_flags__subdir(void);
extern void test_attr_flags__cleanup(void);
extern void test_attr_lookup__simple(void);
extern void test_attr_lookup__match_variants(void);
extern void test_attr_lookup__assign_variants(void);
extern void test_attr_lookup__check_attr_examples(void);
extern void test_attr_lookup__from_buffer(void);
extern void test_attr_macro__macros(void);
extern void test_attr_macro__bad_macros(void);
extern void test_attr_macro__macros_in_root_wd_apply(void);
extern void test_attr_macro__changing_macro_in_root_wd_updates_attributes(void);
extern void test_attr_macro__macros_in_subdir_do_not_apply(void);
extern void test_attr_macro__adding_macro_succeeds(void);
extern void test_attr_macro__adding_boolean_macros_succeeds(void);
extern void test_attr_macro__redefining_macro_succeeds(void);
extern void test_attr_macro__recursive_macro_resolves(void);
extern void test_attr_macro__cleanup(void);
extern void test_attr_repo__get_one(void);
extern void test_attr_repo__get_one_start_deep(void);
extern void test_attr_repo__get_many(void);
extern void test_attr_repo__get_many_in_place(void);
extern void test_attr_repo__foreach(void);
extern void test_attr_repo__manpage_example(void);
extern void test_attr_repo__staging_properly_normalizes_line_endings_according_to_gitattributes_directives(void);
extern void test_attr_repo__bare_repo_with_index(void);
extern void test_attr_repo__inmemory_repo_without_index(void);
extern void test_attr_repo__sysdir(void);
extern void test_attr_repo__sysdir_with_session(void);
extern void test_attr_repo__rewrite(void);
extern void test_attr_repo__rewrite_sysdir(void);
extern void test_attr_repo__unlink(void);
extern void test_attr_repo__initialize(void);
extern void test_attr_repo__cleanup(void);
extern void test_blame_buffer__4_edits(void);
extern void test_blame_buffer__two_added_lines_and_one_modified(void);
extern void test_blame_buffer__two_added_lines(void);
extern void test_blame_buffer__added_blocks(void);
extern void test_blame_buffer__overlapping_blocks(void);
extern void test_blame_buffer__2_add_splits_hunk(void);
extern void test_blame_buffer__index(void);
extern void test_blame_buffer__added_line(void);
extern void test_blame_buffer__added_lines(void);
extern void test_blame_buffer__deleted_line(void);
extern void test_blame_buffer__add_splits_hunk(void);
extern void test_blame_buffer__delete_crosses_hunk_boundary(void);
extern void test_blame_buffer__replace_line(void);
extern void test_blame_buffer__add_lines_at_end(void);
extern void test_blame_buffer__initialize(void);
extern void test_blame_buffer__cleanup(void);
extern void test_blame_getters__byindex(void);
extern void test_blame_getters__byline(void);
extern void test_blame_getters__initialize(void);
extern void test_blame_getters__cleanup(void);
extern void test_blame_harder__m(void);
extern void test_blame_harder__c(void);
extern void test_blame_harder__cc(void);
extern void test_blame_harder__ccc(void);
extern void test_blame_harder__initialize(void);
extern void test_blame_harder__cleanup(void);
extern void test_blame_simple__trivial_testrepo(void);
extern void test_blame_simple__trivial_blamerepo(void);
extern void test_blame_simple__trivial_libgit2(void);
extern void test_blame_simple__trivial_libgit2_under_cache_pressure(void);
extern void test_blame_simple__can_restrict_lines_min(void);
extern void test_blame_simple__can_ignore_whitespace_change(void);
extern void test_blame_simple__can_restrict_lines_max(void);
extern void test_blame_simple__can_restrict_lines_both(void);
extern void test_blame_simple__can_blame_huge_file(void);
extern void test_blame_simple__can_restrict_to_newish_commits(void);
extern void test_blame_simple__can_restrict_to_first_parent_commits(void);
extern void test_blame_simple__initialize(void);
extern void test_blame_simple__cleanup(void);
extern void test_checkout_binaryunicode__noautocrlf(void);
extern void test_checkout_binaryunicode__autocrlf(void);
extern void test_checkout_binaryunicode__initialize(void);
extern void test_checkout_binaryunicode__cleanup(void);
extern void test_checkout_conflict__ignored(void);
extern void test_checkout_conflict__ours(void);
extern void test_checkout_conflict__theirs(void);
extern void test_checkout_conflict__diff3(void);
extern void test_checkout_conflict__automerge(void);
extern void test_checkout_conflict__directory_file(void);
extern void test_checkout_conflict__directory_file_with_custom_labels(void);
extern void test_checkout_conflict__link_file(void);
extern void test_checkout_conflict__links(void);
extern void test_checkout_conflict__add_add(void);
extern void test_checkout_conflict__mode_change(void);
extern void test_checkout_conflict__renames(void);
extern void test_checkout_conflict__rename_keep_ours(void);
extern void test_checkout_conflict__name_mangled_file_exists_in_workdir(void);
extern void test_checkout_conflict__update_only(void);
extern void test_checkout_conflict__path_filters(void);
extern void test_checkout_conflict__report_progress(void);
extern void test_checkout_conflict__initialize(void);
extern void test_checkout_conflict__cleanup(void);
extern void test_checkout_crlf__matches_core_git(void);
extern void test_checkout_crlf__detect_crlf_autocrlf_false(void);
extern void test_checkout_crlf__autocrlf_false_index_size_is_unfiltered_size(void);
extern void test_checkout_crlf__detect_crlf_autocrlf_true(void);
extern void test_checkout_crlf__detect_crlf_autocrlf_true_utf8(void);
extern void test_checkout_crlf__autocrlf_true_index_size_is_filtered_size(void);
extern void test_checkout_crlf__with_ident(void);
extern void test_checkout_crlf__autocrlf_false_no_attrs(void);
extern void test_checkout_crlf__autocrlf_true_no_attrs(void);
extern void test_checkout_crlf__autocrlf_input_no_attrs(void);
extern void test_checkout_crlf__autocrlf_false_text_auto_attr(void);
extern void test_checkout_crlf__autocrlf_true_text_auto_attr(void);
extern void test_checkout_crlf__autocrlf_input_text_auto_attr(void);
extern void test_checkout_crlf__can_write_empty_file(void);
extern void test_checkout_crlf__initialize(void);
extern void test_checkout_crlf__cleanup(void);
extern void test_checkout_head__unborn_head_returns_GIT_EUNBORNBRANCH(void);
extern void test_checkout_head__with_index_only_tree(void);
extern void test_checkout_head__do_not_remove_untracked_file(void);
extern void test_checkout_head__do_not_remove_untracked_file_in_subdir(void);
extern void test_checkout_head__do_remove_untracked_paths(void);
extern void test_checkout_head__do_remove_tracked_subdir(void);
extern void test_checkout_head__typechange_workdir(void);
extern void test_checkout_head__typechange_index_and_workdir(void);
extern void test_checkout_head__workdir_filemode_is_simplified(void);
extern void test_checkout_head__obeys_filemode_true(void);
extern void test_checkout_head__obeys_filemode_false(void);
extern void test_checkout_head__initialize(void);
extern void test_checkout_head__cleanup(void);
extern void test_checkout_icase__refuses_to_overwrite_files_for_files(void);
extern void test_checkout_icase__overwrites_files_for_files_when_forced(void);
extern void test_checkout_icase__refuses_to_overwrite_links_for_files(void);
extern void test_checkout_icase__overwrites_links_for_files_when_forced(void);
extern void test_checkout_icase__overwrites_empty_folders_for_files(void);
extern void test_checkout_icase__refuses_to_overwrite_populated_folders_for_files(void);
extern void test_checkout_icase__overwrites_folders_for_files_when_forced(void);
extern void test_checkout_icase__refuses_to_overwrite_files_for_folders(void);
extern void test_checkout_icase__overwrites_files_for_folders_when_forced(void);
extern void test_checkout_icase__refuses_to_overwrite_links_for_folders(void);
extern void test_checkout_icase__overwrites_links_for_folders_when_forced(void);
extern void test_checkout_icase__ignores_unstaged_casechange(void);
extern void test_checkout_icase__conflicts_with_casechanged_subtrees(void);
extern void test_checkout_icase__initialize(void);
extern void test_checkout_icase__cleanup(void);
extern void test_checkout_index__cannot_checkout_a_bare_repository(void);
extern void test_checkout_index__can_create_missing_files(void);
extern void test_checkout_index__can_remove_untracked_files(void);
extern void test_checkout_index__can_disable_pathspec_match(void);
extern void test_checkout_index__honor_the_specified_pathspecs(void);
extern void test_checkout_index__honor_the_gitattributes_directives(void);
extern void test_checkout_index__honor_coreautocrlf_setting_set_to_true(void);
extern void test_checkout_index__honor_coresymlinks_default_true(void);
extern void test_checkout_index__honor_coresymlinks_default_false(void);
extern void test_checkout_index__coresymlinks_set_to_true_fails_when_unsupported(void);
extern void test_checkout_index__honor_coresymlinks_setting_set_to_true(void);
extern void test_checkout_index__honor_coresymlinks_setting_set_to_false(void);
extern void test_checkout_index__donot_overwrite_modified_file_by_default(void);
extern void test_checkout_index__can_overwrite_modified_file(void);
extern void test_checkout_index__options_disable_filters(void);
extern void test_checkout_index__options_dir_modes(void);
extern void test_checkout_index__options_override_file_modes(void);
extern void test_checkout_index__options_open_flags(void);
extern void test_checkout_index__can_notify_of_skipped_files(void);
extern void test_checkout_index__wont_notify_of_expected_line_ending_changes(void);
extern void test_checkout_index__calls_progress_callback(void);
extern void test_checkout_index__can_overcome_name_clashes(void);
extern void test_checkout_index__validates_struct_version(void);
extern void test_checkout_index__can_update_prefixed_files(void);
extern void test_checkout_index__can_checkout_a_newly_initialized_repository(void);
extern void test_checkout_index__issue_1397(void);
extern void test_checkout_index__target_directory(void);
extern void test_checkout_index__target_directory_from_bare(void);
extern void test_checkout_index__can_get_repo_from_index(void);
extern void test_checkout_index__writes_conflict_file(void);
extern void test_checkout_index__adding_conflict_removes_stage_0(void);
extern void test_checkout_index__conflicts_honor_coreautocrlf(void);
extern void test_checkout_index__initialize(void);
extern void test_checkout_index__cleanup(void);
extern void test_checkout_nasty__dotgit_tree(void);
extern void test_checkout_nasty__dotcapitalgit_tree(void);
extern void test_checkout_nasty__dot_tree(void);
extern void test_checkout_nasty__dot_dotgit_tree(void);
extern void test_checkout_nasty__dotdot_dotgit_tree(void);
extern void test_checkout_nasty__dotdot_tree(void);
extern void test_checkout_nasty__dotgit_path(void);
extern void test_checkout_nasty__dotcapitalgit_path(void);
extern void test_checkout_nasty__dot_dotgit_path(void);
extern void test_checkout_nasty__dot_dotcapitalgit_path(void);
extern void test_checkout_nasty__dotdot_dotgit_path(void);
extern void test_checkout_nasty__dotdot_dotcapitalgit_path(void);
extern void test_checkout_nasty__dot_path(void);
extern void test_checkout_nasty__dot_path_two(void);
extern void test_checkout_nasty__dotdot_path(void);
extern void test_checkout_nasty__dotgit_backslash_path(void);
extern void test_checkout_nasty__dotcapitalgit_backslash_path(void);
extern void test_checkout_nasty__dot_backslash_dotcapitalgit_path(void);
extern void test_checkout_nasty__dot_git_dot(void);
extern void test_checkout_nasty__git_tilde1(void);
extern void test_checkout_nasty__git_custom_shortname(void);
extern void test_checkout_nasty__only_looks_like_a_git_shortname(void);
extern void test_checkout_nasty__dot_git_colon(void);
extern void test_checkout_nasty__dot_git_colon_stuff(void);
extern void test_checkout_nasty__dotgit_alternate_data_stream(void);
extern void test_checkout_nasty__dot_git_hfs_ignorable(void);
extern void test_checkout_nasty__honors_core_protecthfs(void);
extern void test_checkout_nasty__honors_core_protectntfs(void);
extern void test_checkout_nasty__symlink1(void);
extern void test_checkout_nasty__symlink2(void);
extern void test_checkout_nasty__symlink3(void);
extern void test_checkout_nasty__gitmodules_symlink(void);
extern void test_checkout_nasty__initialize(void);
extern void test_checkout_nasty__cleanup(void);
extern void test_checkout_tree__cannot_checkout_a_non_treeish(void);
extern void test_checkout_tree__can_checkout_a_subdirectory_from_a_commit(void);
extern void test_checkout_tree__can_checkout_and_remove_directory(void);
extern void test_checkout_tree__can_checkout_a_subdirectory_from_a_subtree(void);
extern void test_checkout_tree__calls_progress_callback(void);
extern void test_checkout_tree__doesnt_write_unrequested_files_to_worktree(void);
extern void test_checkout_tree__can_switch_branches(void);
extern void test_checkout_tree__can_remove_untracked(void);
extern void test_checkout_tree__can_remove_ignored(void);
extern void test_checkout_tree__conflict_on_ignored_when_not_overwriting(void);
extern void test_checkout_tree__can_overwrite_ignored_by_default(void);
extern void test_checkout_tree__conflict_on_ignored_folder_when_not_overwriting(void);
extern void test_checkout_tree__can_overwrite_ignored_folder_by_default(void);
extern void test_checkout_tree__can_update_only(void);
extern void test_checkout_tree__can_checkout_with_pattern(void);
extern void test_checkout_tree__pathlist_checkout_ignores_non_matches(void);
extern void test_checkout_tree__can_disable_pattern_match(void);
extern void test_checkout_tree__checking_out_a_conflicting_type_change_returns_ECONFLICT(void);
extern void test_checkout_tree__checking_out_a_conflicting_type_change_returns_ECONFLICT_2(void);
extern void test_checkout_tree__checking_out_a_conflicting_content_change_returns_ECONFLICT(void);
extern void test_checkout_tree__donot_update_deleted_file_by_default(void);
extern void test_checkout_tree__can_cancel_checkout_from_notify(void);
extern void test_checkout_tree__can_checkout_with_last_workdir_item_missing(void);
extern void test_checkout_tree__issue_1397(void);
extern void test_checkout_tree__can_write_to_empty_dirs(void);
extern void test_checkout_tree__fails_when_dir_in_use(void);
extern void test_checkout_tree__can_continue_when_dir_in_use(void);
extern void test_checkout_tree__target_directory_from_bare(void);
extern void test_checkout_tree__extremely_long_file_name(void);
extern void test_checkout_tree__fails_when_conflicts_exist_in_index(void);
extern void test_checkout_tree__filemode_preserved_in_index(void);
extern void test_checkout_tree__filemode_preserved_in_workdir(void);
extern void test_checkout_tree__removes_conflicts(void);
extern void test_checkout_tree__removes_conflicts_only_by_pathscope(void);
extern void test_checkout_tree__case_changing_rename(void);
extern void test_checkout_tree__can_collect_perfdata(void);
extern void test_checkout_tree__caches_attributes_during_checkout(void);
extern void test_checkout_tree__can_not_update_index(void);
extern void test_checkout_tree__can_update_but_not_write_index(void);
extern void test_checkout_tree__safe_proceeds_if_no_index(void);
extern void test_checkout_tree__baseline_is_empty_when_no_index(void);
extern void test_checkout_tree__mode_change_is_force_updated(void);
extern void test_checkout_tree__nullopts(void);
extern void test_checkout_tree__retains_external_index_changes(void);
extern void test_checkout_tree__no_index_refresh(void);
extern void test_checkout_tree__dry_run(void);
extern void test_checkout_tree__initialize(void);
extern void test_checkout_tree__cleanup(void);
extern void test_checkout_typechange__checkout_typechanges_safe(void);
extern void test_checkout_typechange__checkout_with_conflicts(void);
extern void test_checkout_typechange__status_char(void);
extern void test_checkout_typechange__initialize(void);
extern void test_checkout_typechange__cleanup(void);
extern void test_cherrypick_bare__automerge(void);
extern void test_cherrypick_bare__conflicts(void);
extern void test_cherrypick_bare__orphan(void);
extern void test_cherrypick_bare__initialize(void);
extern void test_cherrypick_bare__cleanup(void);
extern void test_cherrypick_workdir__automerge(void);
extern void test_cherrypick_workdir__empty_result(void);
extern void test_cherrypick_workdir__conflicts(void);
extern void test_cherrypick_workdir__conflict_use_ours(void);
extern void test_cherrypick_workdir__rename(void);
extern void test_cherrypick_workdir__both_renamed(void);
extern void test_cherrypick_workdir__nonmerge_fails_mainline_specified(void);
extern void test_cherrypick_workdir__merge_fails_without_mainline_specified(void);
extern void test_cherrypick_workdir__merge_first_parent(void);
extern void test_cherrypick_workdir__merge_second_parent(void);
extern void test_cherrypick_workdir__initialize(void);
extern void test_cherrypick_workdir__cleanup(void);
extern void test_clone_empty__can_clone_an_empty_local_repo_barely(void);
extern void test_clone_empty__respects_initialbranch_config(void);
extern void test_clone_empty__can_clone_an_empty_local_repo(void);
extern void test_clone_empty__can_clone_an_empty_standard_repo(void);
extern void test_clone_empty__initialize(void);
extern void test_clone_empty__cleanup(void);
extern void test_clone_local__should_clone_local(void);
extern void test_clone_local__hardlinks(void);
extern void test_clone_local__standard_unc_paths_are_written_git_style(void);
extern void test_clone_local__git_style_unc_paths(void);
extern void test_clone_local__shallow_fails(void);
extern void test_clone_nonetwork__bad_urls(void);
extern void test_clone_nonetwork__do_not_clean_existing_directory(void);
extern void test_clone_nonetwork__local(void);
extern void test_clone_nonetwork__local_absolute_path(void);
extern void test_clone_nonetwork__local_bare(void);
extern void test_clone_nonetwork__fail_when_the_target_is_a_file(void);
extern void test_clone_nonetwork__fail_with_already_existing_but_non_empty_directory(void);
extern void test_clone_nonetwork__custom_origin_name(void);
extern void test_clone_nonetwork__defaults(void);
extern void test_clone_nonetwork__cope_with_already_existing_directory(void);
extern void test_clone_nonetwork__can_prevent_the_checkout_of_a_standard_repo(void);
extern void test_clone_nonetwork__can_checkout_given_branch(void);
extern void test_clone_nonetwork__can_cancel_clone_in_fetch(void);
extern void test_clone_nonetwork__can_cancel_clone_in_checkout(void);
extern void test_clone_nonetwork__can_detached_head(void);
extern void test_clone_nonetwork__clone_tag_to_tree(void);
extern void test_clone_nonetwork__clone_updates_reflog_properly(void);
extern void test_clone_nonetwork__clone_from_empty_sets_upstream(void);
extern void test_clone_nonetwork__initialize(void);
extern void test_clone_nonetwork__cleanup(void);
extern void test_clone_transport__custom_transport(void);
extern void test_commit_commit__create_unexisting_update_ref(void);
extern void test_commit_commit__create_initial_commit(void);
extern void test_commit_commit__create_initial_commit_parent_not_current(void);
extern void test_commit_commit__summary(void);
extern void test_commit_commit__body(void);
extern void test_commit_commit__initialize(void);
extern void test_commit_commit__cleanup(void);
extern void test_commit_create__from_stage_simple(void);
extern void test_commit_create__from_stage_nochanges(void);
extern void test_commit_create__from_stage_newrepo(void);
extern void test_commit_create__initialize(void);
extern void test_commit_create__cleanup(void);
extern void test_commit_parent__can_retrieve_nth_generation_parent(void);
extern void test_commit_parent__initialize(void);
extern void test_commit_parent__cleanup(void);
extern void test_commit_parse__header(void);
extern void test_commit_parse__signature(void);
extern void test_commit_parse__entire_commit(void);
extern void test_commit_parse__details0(void);
extern void test_commit_parse__leading_lf(void);
extern void test_commit_parse__only_lf(void);
extern void test_commit_parse__arbitrary_field(void);
extern void test_commit_parse__extract_signature(void);
extern void test_commit_parse__initialize(void);
extern void test_commit_parse__cleanup(void);
extern void test_commit_signature__leading_and_trailing_spaces_are_trimmed(void);
extern void test_commit_signature__leading_and_trailing_dots_are_supported(void);
extern void test_commit_signature__leading_and_trailing_crud_is_trimmed(void);
extern void test_commit_signature__timezone_does_not_read_oob(void);
extern void test_commit_signature__angle_brackets_in_names_are_not_supported(void);
extern void test_commit_signature__angle_brackets_in_email_are_not_supported(void);
extern void test_commit_signature__create_empties(void);
extern void test_commit_signature__create_one_char(void);
extern void test_commit_signature__create_two_char(void);
extern void test_commit_signature__create_zero_char(void);
extern void test_commit_signature__from_buf(void);
extern void test_commit_signature__from_buf_with_neg_zero_offset(void);
extern void test_commit_signature__pos_and_neg_zero_offsets_dont_match(void);
extern void test_commit_signature__from_env(void);
extern void test_commit_signature__initialize(void);
extern void test_commit_signature__cleanup(void);
extern void test_commit_write__from_memory(void);
extern void test_commit_write__into_buf(void);
extern void test_commit_write__root(void);
extern void test_commit_write__can_write_invalid_objects(void);
extern void test_commit_write__can_validate_objects(void);
extern void test_commit_write__attach_signature_checks_objects(void);
extern void test_commit_write__attach_singleline_signature(void);
extern void test_commit_write__attach_multiline_signature(void);
extern void test_commit_write__initialize(void);
extern void test_commit_write__cleanup(void);
extern void test_config_add__to_existing_section(void);
extern void test_config_add__to_new_section(void);
extern void test_config_add__initialize(void);
extern void test_config_add__cleanup(void);
extern void test_config_backend__checks_version(void);
extern void test_config_conditionals__gitdir(void);
extern void test_config_conditionals__gitdir_i(void);
extern void test_config_conditionals__invalid_conditional_fails(void);
extern void test_config_conditionals__onbranch(void);
extern void test_config_conditionals__empty(void);
extern void test_config_conditionals__initialize(void);
extern void test_config_conditionals__cleanup(void);
extern void test_config_configlevel__adding_the_same_level_twice_returns_EEXISTS(void);
extern void test_config_configlevel__can_replace_a_config_file_at_an_existing_level(void);
extern void test_config_configlevel__can_read_from_a_single_level_focused_file_after_parent_config_has_been_freed(void);
extern void test_config_configlevel__fetching_a_level_from_an_empty_compound_config_returns_ENOTFOUND(void);
extern void test_config_configlevel__can_fetch_highest_level(void);
extern void test_config_configlevel__can_override_local_with_worktree(void);
extern void test_config_find__one(void);
extern void test_config_global__open_global(void);
extern void test_config_global__open_symlinked_global(void);
extern void test_config_global__lock_missing_global_config(void);
extern void test_config_global__open_xdg(void);
extern void test_config_global__open_programdata(void);
extern void test_config_global__initialize(void);
extern void test_config_global__cleanup(void);
extern void test_config_include__relative(void);
extern void test_config_include__absolute(void);
extern void test_config_include__homedir(void);
extern void test_config_include__ordering(void);
extern void test_config_include__depth(void);
extern void test_config_include__empty_path_sanely_handled(void);
extern void test_config_include__missing(void);
extern void test_config_include__missing_homedir(void);
extern void test_config_include__depth2(void);
extern void test_config_include__removing_include_removes_values(void);
extern void test_config_include__rewriting_include_refreshes_values(void);
extern void test_config_include__rewriting_include_twice_refreshes_values(void);
extern void test_config_include__included_variables_cannot_be_deleted(void);
extern void test_config_include__included_variables_cannot_be_modified(void);
extern void test_config_include__variables_in_included_override_including(void);
extern void test_config_include__variables_in_including_override_included(void);
extern void test_config_include__initialize(void);
extern void test_config_include__cleanup(void);
extern void test_config_memory__write_operations_fail(void);
extern void test_config_memory__simple(void);
extern void test_config_memory__malformed_fails_to_open(void);
extern void test_config_memory__multiple_vars(void);
extern void test_config_memory__multiple_sections(void);
extern void test_config_memory__multivar_gets_correct_string(void);
extern void test_config_memory__foreach_sees_multivar(void);
extern void test_config_memory__values(void);
extern void test_config_memory__valid_values(void);
extern void test_config_memory__initialize(void);
extern void test_config_memory__cleanup(void);
extern void test_config_multivar__foreach(void);
extern void test_config_multivar__get(void);
extern void test_config_multivar__add(void);
extern void test_config_multivar__add_new(void);
extern void test_config_multivar__replace(void);
extern void test_config_multivar__replace_multiple(void);
extern void test_config_multivar__delete(void);
extern void test_config_multivar__delete_multiple(void);
extern void test_config_multivar__delete_notfound(void);
extern void test_config_multivar__rename_section(void);
extern void test_config_multivar__initialize(void);
extern void test_config_multivar__cleanup(void);
extern void test_config_new__write_new_config(void);
extern void test_config_read__simple_read(void);
extern void test_config_read__case_sensitive(void);
extern void test_config_read__multiline_value(void);
extern void test_config_read__multiline_value_and_eof(void);
extern void test_config_read__multiline_eof(void);
extern void test_config_read__subsection_header(void);
extern void test_config_read__lone_variable(void);
extern void test_config_read__number_suffixes(void);
extern void test_config_read__blank_lines(void);
extern void test_config_read__invalid_ext_headers(void);
extern void test_config_read__empty_files(void);
extern void test_config_read__symbol_headers(void);
extern void test_config_read__multiline_multiple_quoted_comment_chars(void);
extern void test_config_read__multiline_multiple_quoted_quote_at_beginning_of_line(void);
extern void test_config_read__header_in_last_line(void);
extern void test_config_read__prefixes(void);
extern void test_config_read__escaping_quotes(void);
extern void test_config_read__invalid_escape_sequence(void);
extern void test_config_read__foreach(void);
extern void test_config_read__iterator(void);
extern void test_config_read__foreach_match(void);
extern void test_config_read__iterator_invalid_glob(void);
extern void test_config_read__iterator_glob(void);
extern void test_config_read__whitespace_not_required_around_assignment(void);
extern void test_config_read__read_git_config_entry(void);
extern void test_config_read__local_config_overrides_global_config_overrides_system_config(void);
extern void test_config_read__fallback_from_local_to_global_and_from_global_to_system(void);
extern void test_config_read__parent_dir_is_file(void);
extern void test_config_read__simple_read_from_specific_level(void);
extern void test_config_read__can_load_and_parse_an_empty_config_file(void);
extern void test_config_read__corrupt_header(void);
extern void test_config_read__corrupt_header2(void);
extern void test_config_read__corrupt_header3(void);
extern void test_config_read__invalid_key_chars(void);
extern void test_config_read__lone_variable_with_trailing_whitespace(void);
extern void test_config_read__override_variable(void);
extern void test_config_read__path(void);
extern void test_config_read__crlf_style_line_endings(void);
extern void test_config_read__trailing_crlf(void);
extern void test_config_read__bom(void);
extern void test_config_read__arbitrary_whitespace_before_subsection(void);
extern void test_config_read__no_whitespace_after_subsection(void);
extern void test_config_read__invalid_space_section(void);
extern void test_config_read__invalid_quoted_first_section(void);
extern void test_config_read__invalid_unquoted_subsection(void);
extern void test_config_read__invalid_quoted_third_section(void);
extern void test_config_read__unreadable_file_ignored(void);
extern void test_config_read__single_line(void);
extern void test_config_read__nosection(void);
extern void test_config_read__get_mapped(void);
extern void test_config_read__cleanup(void);
extern void test_config_readonly__writing_to_readonly_fails(void);
extern void test_config_readonly__writing_to_cfg_with_rw_precedence_succeeds(void);
extern void test_config_readonly__writing_to_cfg_with_ro_precedence_succeeds(void);
extern void test_config_readonly__initialize(void);
extern void test_config_readonly__cleanup(void);
extern void test_config_rename__can_rename(void);
extern void test_config_rename__prevent_overwrite(void);
extern void test_config_rename__require_a_valid_new_name(void);
extern void test_config_rename__initialize(void);
extern void test_config_rename__cleanup(void);
extern void test_config_snapshot__create_snapshot(void);
extern void test_config_snapshot__multivar(void);
extern void test_config_snapshot__includes(void);
extern void test_config_snapshot__snapshot(void);
extern void test_config_snapshot__snapshot_from_in_memory(void);
extern void test_config_snapshot__cleanup(void);
extern void test_config_stress__dont_break_on_invalid_input(void);
extern void test_config_stress__comments(void);
extern void test_config_stress__escape_subsection_names(void);
extern void test_config_stress__trailing_backslash(void);
extern void test_config_stress__complex(void);
extern void test_config_stress__quick_write(void);
extern void test_config_stress__foreach_refreshes(void);
extern void test_config_stress__foreach_refreshes_snapshot(void);
extern void test_config_stress__huge_section_with_many_values(void);
extern void test_config_stress__initialize(void);
extern void test_config_stress__cleanup(void);
extern void test_config_validkeyname__accessing_requires_a_valid_name(void);
extern void test_config_validkeyname__initialize(void);
extern void test_config_validkeyname__cleanup(void);
extern void test_config_write__replace_value(void);
extern void test_config_write__delete_value(void);
extern void test_config_write__delete_value_at_specific_level(void);
extern void test_config_write__delete_value_with_duplicate_header(void);
extern void test_config_write__add_value_with_duplicate_header(void);
extern void test_config_write__overwrite_value_with_duplicate_header(void);
extern void test_config_write__overwrite_multivar_within_duplicate_header(void);
extern void test_config_write__write_subsection(void);
extern void test_config_write__delete_inexistent(void);
extern void test_config_write__value_containing_quotes(void);
extern void test_config_write__escape_value(void);
extern void test_config_write__add_value_at_specific_level(void);
extern void test_config_write__add_value_at_file_with_no_clrf_at_the_end(void);
extern void test_config_write__add_section_at_file_with_no_clrf_at_the_end(void);
extern void test_config_write__add_value_which_needs_quotes(void);
extern void test_config_write__can_set_a_value_to_NULL(void);
extern void test_config_write__can_set_an_empty_value(void);
extern void test_config_write__updating_a_locked_config_file_returns_ELOCKED(void);
extern void test_config_write__outside_change(void);
extern void test_config_write__preserves_whitespace_and_comments(void);
extern void test_config_write__preserves_entry_with_name_only(void);
extern void test_config_write__to_empty_file(void);
extern void test_config_write__to_file_with_only_comment(void);
extern void test_config_write__locking(void);
extern void test_config_write__abort_lock(void);
extern void test_config_write__repeated(void);
extern void test_config_write__preserve_case(void);
extern void test_config_write__write_config_file_with_multi_line_value(void);
extern void test_config_write__initialize(void);
extern void test_config_write__cleanup(void);
extern void test_core_buf__sanitize(void);
extern void test_core_buf__tostr(void);
extern void test_core_buf__fromstr(void);
extern void test_core_env__0(void);
extern void test_core_env__1(void);
extern void test_core_env__2(void);
extern void test_core_env__substitution(void);
extern void test_core_env__initialize(void);
extern void test_core_env__cleanup(void);
extern void test_core_features__0(void);
extern void test_core_hashsig__similarity_metric(void);
extern void test_core_hashsig__similarity_metric_whitespace(void);
extern void test_core_oid__streq_sha1(void);
extern void test_core_oid__streq_sha256(void);
extern void test_core_oid__strcmp_sha1(void);
extern void test_core_oid__strcmp_sha256(void);
extern void test_core_oid__ncmp_sha1(void);
extern void test_core_oid__ncmp_sha256(void);
extern void test_core_oid__is_hexstr(void);
extern void test_core_oid__fmt_substr_sha1(void);
extern void test_core_oid__type_lookup(void);
extern void test_core_oid__initialize(void);
extern void test_core_oidarray__add_and_remove_oid_from_shallowarray(void);
extern void test_core_oidmap__basic(void);
extern void test_core_oidmap__hash_collision(void);
extern void test_core_oidmap__get_succeeds_with_existing_keys(void);
extern void test_core_oidmap__get_fails_with_nonexisting_key(void);
extern void test_core_oidmap__setting_oid_persists(void);
extern void test_core_oidmap__setting_existing_key_updates(void);
extern void test_core_oidmap__initialize(void);
extern void test_core_oidmap__cleanup(void);
extern void test_core_opts__readwrite(void);
extern void test_core_opts__invalid_option(void);
extern void test_core_opts__extensions_query(void);
extern void test_core_opts__extensions_add(void);
extern void test_core_opts__extensions_remove(void);
extern void test_core_opts__extensions_uniq(void);
extern void test_core_opts__cleanup(void);
extern void test_core_pool__oid(void);
extern void test_core_structinit__compare(void);
extern void test_core_useragent__get_default(void);
extern void test_core_useragent__set(void);
extern void test_core_useragent__initialize(void);
extern void test_core_useragent__cleanup(void);
extern void test_date_date__overflow(void);
extern void test_date_date__invalid_date(void);
extern void test_date_date__offset(void);
extern void test_date_rfc2822__format_rfc2822_no_offset(void);
extern void test_date_rfc2822__format_rfc2822_positive_offset(void);
extern void test_date_rfc2822__format_rfc2822_negative_offset(void);
extern void test_delta_apply__read_at_off(void);
extern void test_delta_apply__read_after_limit(void);
extern void test_describe_describe__can_describe_against_a_bare_repo(void);
extern void test_describe_describe__describe_a_repo_with_no_refs(void);
extern void test_describe_t6120__default(void);
extern void test_describe_t6120__tags(void);
extern void test_describe_t6120__all(void);
extern void test_describe_t6120__longformat(void);
extern void test_describe_t6120__firstparent(void);
extern void test_describe_t6120__workdir(void);
extern void test_describe_t6120__pattern(void);
extern void test_describe_t6120__initialize(void);
extern void test_describe_t6120__cleanup(void);
extern void test_diff_binary__add_normal(void);
extern void test_diff_binary__add(void);
extern void test_diff_binary__modify_normal(void);
extern void test_diff_binary__modify(void);
extern void test_diff_binary__delete_normal(void);
extern void test_diff_binary__delete(void);
extern void test_diff_binary__delta(void);
extern void test_diff_binary__delta_append(void);
extern void test_diff_binary__empty_for_no_diff(void);
extern void test_diff_binary__index_to_workdir(void);
extern void test_diff_binary__print_patch_from_diff(void);
extern void test_diff_binary__blob_to_blob(void);
extern void test_diff_binary__initialize(void);
extern void test_diff_binary__cleanup(void);
extern void test_diff_blob__patch_with_freed_blobs(void);
extern void test_diff_blob__can_compare_text_blobs(void);
extern void test_diff_blob__can_compare_text_blobs_with_patch(void);
extern void test_diff_blob__can_compare_against_null_blobs(void);
extern void test_diff_blob__can_compare_against_null_blobs_with_patch(void);
extern void test_diff_blob__can_compare_identical_blobs(void);
extern void test_diff_blob__can_compare_identical_blobs_with_patch(void);
extern void test_diff_blob__can_compare_two_binary_blobs(void);
extern void test_diff_blob__can_compare_a_binary_blob_and_a_text_blob(void);
extern void test_diff_blob__comparing_two_text_blobs_honors_interhunkcontext(void);
extern void test_diff_blob__checks_options_version_too_low(void);
extern void test_diff_blob__checks_options_version_too_high(void);
extern void test_diff_blob__can_correctly_detect_a_binary_blob_as_binary(void);
extern void test_diff_blob__can_correctly_detect_binary_blob_data_as_binary(void);
extern void test_diff_blob__can_correctly_detect_a_textual_blob_as_non_binary(void);
extern void test_diff_blob__can_correctly_detect_textual_blob_data_as_non_binary(void);
extern void test_diff_blob__can_compare_blob_to_buffer(void);
extern void test_diff_blob__can_compare_blob_to_buffer_with_patch(void);
extern void test_diff_blob__binary_data_comparisons(void);
extern void test_diff_blob__using_path_and_attributes(void);
extern void test_diff_blob__can_compare_buffer_to_buffer(void);
extern void test_diff_blob__initialize(void);
extern void test_diff_blob__cleanup(void);
extern void test_diff_diffiter__create(void);
extern void test_diff_diffiter__iterate_files_1(void);
extern void test_diff_diffiter__iterate_files_2(void);
extern void test_diff_diffiter__iterate_files_and_hunks(void);
extern void test_diff_diffiter__max_size_threshold(void);
extern void test_diff_diffiter__iterate_all(void);
extern void test_diff_diffiter__iterate_randomly_while_saving_state(void);
extern void test_diff_diffiter__iterate_and_generate_patch_text(void);
extern void test_diff_diffiter__checks_options_version(void);
extern void test_diff_diffiter__initialize(void);
extern void test_diff_diffiter__cleanup(void);
extern void test_diff_drivers__patterns(void);
extern void test_diff_drivers__long_lines(void);
extern void test_diff_drivers__builtins(void);
extern void test_diff_drivers__invalid_pattern(void);
extern void test_diff_drivers__initialize(void);
extern void test_diff_drivers__cleanup(void);
extern void test_diff_externalmodifications__file_becomes_smaller(void);
extern void test_diff_externalmodifications__file_becomes_empty(void);
extern void test_diff_externalmodifications__file_deleted(void);
extern void test_diff_externalmodifications__empty_file_becomes_non_empty(void);
extern void test_diff_externalmodifications__initialize(void);
extern void test_diff_externalmodifications__cleanup(void);
extern void test_diff_format_email__simple(void);
extern void test_diff_format_email__with_message(void);
extern void test_diff_format_email__multiple(void);
extern void test_diff_format_email__exclude_marker(void);
extern void test_diff_format_email__invalid_no(void);
extern void test_diff_format_email__mode_change(void);
extern void test_diff_format_email__rename_add_remove(void);
extern void test_diff_format_email__multiline_summary(void);
extern void test_diff_format_email__binary(void);
extern void test_diff_format_email__initialize(void);
extern void test_diff_format_email__cleanup(void);
extern void test_diff_index__0(void);
extern void test_diff_index__1(void);
extern void test_diff_index__checks_options_version(void);
extern void test_diff_index__reports_conflicts(void);
extern void test_diff_index__reports_conflicts_when_reversed(void);
extern void test_diff_index__not_in_head_conflicted(void);
extern void test_diff_index__to_index(void);
extern void test_diff_index__initialize(void);
extern void test_diff_index__cleanup(void);
extern void test_diff_notify__notify_single_pathspec(void);
extern void test_diff_notify__notify_multiple_pathspec(void);
extern void test_diff_notify__notify_catchall_with_empty_pathspecs(void);
extern void test_diff_notify__notify_catchall(void);
extern void test_diff_notify__notify_cb_can_abort_diff(void);
extern void test_diff_notify__notify_cb_can_be_used_as_filtering_function(void);
extern void test_diff_notify__progress_cb_can_abort_diff(void);
extern void test_diff_notify__initialize(void);
extern void test_diff_notify__cleanup(void);
extern void test_diff_parse__nonpatches_fail_with_notfound(void);
extern void test_diff_parse__exact_rename(void);
extern void test_diff_parse__empty_file(void);
extern void test_diff_parse__no_extended_headers(void);
extern void test_diff_parse__add_delete_no_index(void);
extern void test_diff_parse__invalid_patches_fails(void);
extern void test_diff_parse__can_parse_generated_diff(void);
extern void test_diff_parse__get_patch_from_diff(void);
extern void test_diff_parse__eof_nl_missing(void);
extern void test_diff_parse__foreach_works_with_parsed_patch(void);
extern void test_diff_parse__parsing_minimal_patch_succeeds(void);
extern void test_diff_parse__patch_roundtrip_succeeds(void);
extern void test_diff_parse__issue4672(void);
extern void test_diff_parse__lineinfo(void);
extern void test_diff_parse__new_file_with_space(void);
extern void test_diff_parse__new_file_with_space_and_regenerate_patch(void);
extern void test_diff_parse__delete_file_with_space_and_regenerate_patch(void);
extern void test_diff_parse__crlf(void);
extern void test_diff_parse__cleanup(void);
extern void test_diff_patch__can_properly_display_the_removal_of_a_file(void);
extern void test_diff_patch__can_cancel_diff_print(void);
extern void test_diff_patch__to_string(void);
extern void test_diff_patch__config_options(void);
extern void test_diff_patch__hunks_have_correct_line_numbers(void);
extern void test_diff_patch__line_counts_with_eofnl(void);
extern void test_diff_patch__can_strip_bad_utf8(void);
extern void test_diff_patch__initialize(void);
extern void test_diff_patch__cleanup(void);
extern void test_diff_patchid__simple_commit(void);
extern void test_diff_patchid__deleted_file(void);
extern void test_diff_patchid__created_file(void);
extern void test_diff_patchid__binary_file(void);
extern void test_diff_patchid__renamed_file(void);
extern void test_diff_patchid__modechange(void);
extern void test_diff_patchid__shuffle_hunks(void);
extern void test_diff_patchid__filename_with_spaces(void);
extern void test_diff_patchid__multiple_hunks(void);
extern void test_diff_patchid__multiple_files(void);
extern void test_diff_patchid__same_diff_with_differing_whitespace_has_same_id(void);
extern void test_diff_pathspec__0(void);
extern void test_diff_pathspec__initialize(void);
extern void test_diff_pathspec__cleanup(void);
extern void test_diff_racediffiter__basic(void);
extern void test_diff_racediffiter__racy(void);
extern void test_diff_racediffiter__initialize(void);
extern void test_diff_racediffiter__cleanup(void);
extern void test_diff_rename__match_oid(void);
extern void test_diff_rename__checks_options_version(void);
extern void test_diff_rename__not_exact_match(void);
extern void test_diff_rename__test_small_files(void);
extern void test_diff_rename__working_directory_changes(void);
extern void test_diff_rename__patch(void);
extern void test_diff_rename__file_exchange(void);
extern void test_diff_rename__file_exchange_three(void);
extern void test_diff_rename__file_partial_exchange(void);
extern void test_diff_rename__rename_and_copy_from_same_source(void);
extern void test_diff_rename__from_deleted_to_split(void);
extern void test_diff_rename__rejected_match_can_match_others(void);
extern void test_diff_rename__rejected_match_can_match_others_two(void);
extern void test_diff_rename__rejected_match_can_match_others_three(void);
extern void test_diff_rename__can_rename_from_rewrite(void);
extern void test_diff_rename__case_changes_are_split(void);
extern void test_diff_rename__unmodified_can_be_renamed(void);
extern void test_diff_rename__rewrite_on_single_file(void);
extern void test_diff_rename__can_find_copy_to_split(void);
extern void test_diff_rename__can_delete_unmodified_deltas(void);
extern void test_diff_rename__can_delete_unmodified_deltas_including_submodule(void);
extern void test_diff_rename__matches_config_behavior(void);
extern void test_diff_rename__can_override_thresholds_when_obeying_config(void);
extern void test_diff_rename__by_config_doesnt_mess_with_whitespace_settings(void);
extern void test_diff_rename__empty_files_renamed(void);
extern void test_diff_rename__blank_files_renamed_when_ignoring_whitespace(void);
extern void test_diff_rename__blank_files_not_renamed_when_not_ignoring_whitespace(void);
extern void test_diff_rename__identical(void);
extern void test_diff_rename__rewrite_and_delete(void);
extern void test_diff_rename__delete_and_rename(void);
extern void test_diff_rename__break_rewrite(void);
extern void test_diff_rename__initialize(void);
extern void test_diff_rename__cleanup(void);
extern void test_diff_stats__stat(void);
extern void test_diff_stats__multiple_hunks(void);
extern void test_diff_stats__numstat(void);
extern void test_diff_stats__shortstat(void);
extern void test_diff_stats__shortstat_noinsertions(void);
extern void test_diff_stats__shortstat_nodeletions(void);
extern void test_diff_stats__rename(void);
extern void test_diff_stats__rename_nochanges(void);
extern void test_diff_stats__rename_and_modifiy(void);
extern void test_diff_stats__rename_in_subdirectory(void);
extern void test_diff_stats__rename_no_find(void);
extern void test_diff_stats__rename_nochanges_no_find(void);
extern void test_diff_stats__rename_and_modify_no_find(void);
extern void test_diff_stats__binary(void);
extern void test_diff_stats__binary_numstat(void);
extern void test_diff_stats__mode_change(void);
extern void test_diff_stats__new_file(void);
extern void test_diff_stats__initialize(void);
extern void test_diff_stats__cleanup(void);
extern void test_diff_submodules__unmodified_submodule(void);
extern void test_diff_submodules__dirty_submodule(void);
extern void test_diff_submodules__dirty_submodule_2(void);
extern void test_diff_submodules__submod2_index_to_wd(void);
extern void test_diff_submodules__submod2_head_to_index(void);
extern void test_diff_submodules__invalid_cache(void);
extern void test_diff_submodules__diff_ignore_options(void);
extern void test_diff_submodules__skips_empty_includes_used(void);
extern void test_diff_submodules__can_be_identified_by_trailing_slash_in_pathspec(void);
extern void test_diff_submodules__initialize(void);
extern void test_diff_submodules__cleanup(void);
extern void test_diff_tree__0(void);
extern void test_diff_tree__options(void);
extern void test_diff_tree__bare(void);
extern void test_diff_tree__merge(void);
extern void test_diff_tree__larger_hunks(void);
extern void test_diff_tree__checks_options_version(void);
extern void test_diff_tree__symlink_blob_mode_changed_to_regular_file(void);
extern void test_diff_tree__symlink_blob_mode_changed_to_regular_file_as_typechange(void);
extern void test_diff_tree__regular_blob_mode_changed_to_executable_file(void);
extern void test_diff_tree__issue_1397(void);
extern void test_diff_tree__diff_configs(void);
extern void test_diff_tree__diff_tree_with_empty_dir_entry_succeeds(void);
extern void test_diff_tree__initialize(void);
extern void test_diff_tree__cleanup(void);
extern void test_diff_userdiff__compile_userdiff_regexps(void);
extern void test_diff_userdiff__cleanup(void);
extern void test_diff_workdir__to_index(void);
extern void test_diff_workdir__to_index_with_conflicts(void);
extern void test_diff_workdir__to_index_with_assume_unchanged(void);
extern void test_diff_workdir__to_tree(void);
extern void test_diff_workdir__to_index_with_pathspec(void);
extern void test_diff_workdir__to_index_with_pathlist_disabling_fnmatch(void);
extern void test_diff_workdir__filemode_changes(void);
extern void test_diff_workdir__filemode_changes_with_filemode_false(void);
extern void test_diff_workdir__head_index_and_workdir_all_differ(void);
extern void test_diff_workdir__eof_newline_changes(void);
extern void test_diff_workdir__larger_hunks(void);
extern void test_diff_workdir__submodules(void);
extern void test_diff_workdir__cannot_diff_against_a_bare_repository(void);
extern void test_diff_workdir__to_null_tree(void);
extern void test_diff_workdir__checks_options_version(void);
extern void test_diff_workdir__can_diff_empty_untracked_file(void);
extern void test_diff_workdir__can_diff_empty_file(void);
extern void test_diff_workdir__to_index_issue_1397(void);
extern void test_diff_workdir__to_tree_issue_1397(void);
extern void test_diff_workdir__untracked_directory_scenarios(void);
extern void test_diff_workdir__untracked_directory_comes_last(void);
extern void test_diff_workdir__untracked_with_bom(void);
extern void test_diff_workdir__patience_diff(void);
extern void test_diff_workdir__with_stale_index(void);
extern void test_diff_workdir__can_update_index(void);
extern void test_diff_workdir__binary_detection(void);
extern void test_diff_workdir__to_index_conflicted(void);
extern void test_diff_workdir__only_writes_index_when_necessary(void);
extern void test_diff_workdir__to_index_pathlist(void);
extern void test_diff_workdir__symlink_changed_on_non_symlink_platform(void);
extern void test_diff_workdir__order(void);
extern void test_diff_workdir__ignore_blank_lines(void);
extern void test_diff_workdir__to_index_reversed_content_loads(void);
extern void test_diff_workdir__completely_ignored_shows_empty_diff(void);
extern void test_diff_workdir__cleanup(void);
extern void test_email_create__commit(void);
extern void test_email_create__rename(void);
extern void test_email_create__rename_as_add_delete(void);
extern void test_email_create__binary(void);
extern void test_email_create__binary_not_included(void);
extern void test_email_create__custom_summary_and_body(void);
extern void test_email_create__commit_subjects(void);
extern void test_email_create__initialize(void);
extern void test_email_create__cleanup(void);
extern void test_fetch_local__defaults(void);
extern void test_fetch_local__reachable_commit(void);
extern void test_fetch_local__initialize(void);
extern void test_fetch_local__cleanup(void);
extern void test_fetchhead_nonetwork__write(void);
extern void test_fetchhead_nonetwork__read(void);
extern void test_fetchhead_nonetwork__read_old_style(void);
extern void test_fetchhead_nonetwork__type_missing(void);
extern void test_fetchhead_nonetwork__name_missing(void);
extern void test_fetchhead_nonetwork__nonexistent(void);
extern void test_fetchhead_nonetwork__invalid_unterminated_last_line(void);
extern void test_fetchhead_nonetwork__invalid_oid(void);
extern void test_fetchhead_nonetwork__invalid_for_merge(void);
extern void test_fetchhead_nonetwork__invalid_description(void);
extern void test_fetchhead_nonetwork__unborn_with_upstream(void);
extern void test_fetchhead_nonetwork__fetch_into_repo_with_symrefs(void);
extern void test_fetchhead_nonetwork__fetch_into_repo_with_invalid_head(void);
extern void test_fetchhead_nonetwork__quote_in_branch_name(void);
extern void test_fetchhead_nonetwork__create_when_refpecs_given(void);
extern void test_fetchhead_nonetwork__create_with_multiple_refspecs(void);
extern void test_fetchhead_nonetwork__credentials_are_stripped(void);
extern void test_fetchhead_nonetwork__initialize(void);
extern void test_filter_bare__all_crlf(void);
extern void test_filter_bare__from_lf(void);
extern void test_filter_bare__nested_attributes(void);
extern void test_filter_bare__sanitizes(void);
extern void test_filter_bare__from_specific_commit_one(void);
extern void test_filter_bare__from_specific_commit_with_no_attributes_file(void);
extern void test_filter_bare__initialize(void);
extern void test_filter_bare__cleanup(void);
extern void test_filter_blob__all_crlf(void);
extern void test_filter_blob__from_lf(void);
extern void test_filter_blob__sanitizes(void);
extern void test_filter_blob__ident(void);
extern void test_filter_blob__initialize(void);
extern void test_filter_blob__cleanup(void);
extern void test_filter_crlf__to_worktree(void);
extern void test_filter_crlf__to_odb(void);
extern void test_filter_crlf__with_safecrlf(void);
extern void test_filter_crlf__with_safecrlf_and_unsafe_allowed(void);
extern void test_filter_crlf__no_safecrlf(void);
extern void test_filter_crlf__safecrlf_warn(void);
extern void test_filter_crlf__initialize(void);
extern void test_filter_crlf__cleanup(void);
extern void test_filter_custom__to_odb(void);
extern void test_filter_custom__to_workdir(void);
extern void test_filter_custom__can_register_a_custom_filter_in_the_repository(void);
extern void test_filter_custom__order_dependency(void);
extern void test_filter_custom__filter_registry_failure_cases(void);
extern void test_filter_custom__erroneous_filter_fails(void);
extern void test_filter_custom__initialize(void);
extern void test_filter_custom__cleanup(void);
extern void test_filter_file__apply(void);
extern void test_filter_file__apply_stream(void);
extern void test_filter_file__initialize(void);
extern void test_filter_file__cleanup(void);
extern void test_filter_ident__to_worktree(void);
extern void test_filter_ident__to_odb(void);
extern void test_filter_ident__initialize(void);
extern void test_filter_ident__cleanup(void);
extern void test_filter_query__filters(void);
extern void test_filter_query__autocrlf_true_implies_crlf(void);
extern void test_filter_query__unknown(void);
extern void test_filter_query__custom(void);
extern void test_filter_query__initialize(void);
extern void test_filter_query__cleanup(void);
extern void test_filter_stream__smallfile(void);
extern void test_filter_stream__bigfile(void);
extern void test_filter_stream__initialize(void);
extern void test_filter_stream__cleanup(void);
extern void test_filter_systemattrs__reads_system_attributes(void);
extern void test_filter_systemattrs__disables_system_attributes(void);
extern void test_filter_systemattrs__initialize(void);
extern void test_filter_systemattrs__cleanup(void);
extern void test_filter_wildcard__reverse(void);
extern void test_filter_wildcard__flip(void);
extern void test_filter_wildcard__none(void);
extern void test_filter_wildcard__initialize(void);
extern void test_filter_wildcard__cleanup(void);
extern void test_grafts_basic__graft_add(void);
extern void test_grafts_basic__grafted_revwalk(void);
extern void test_grafts_basic__grafted_objects(void);
extern void test_grafts_basic__grafted_merge_revwalk(void);
extern void test_grafts_basic__initialize(void);
extern void test_grafts_basic__cleanup(void);
extern void test_grafts_parse__single_oid(void);
extern void test_grafts_parse__single_oid_with_newline(void);
extern void test_grafts_parse__multiple_oids(void);
extern void test_grafts_parse__same_oid(void);
extern void test_grafts_parse__oid_with_parent(void);
extern void test_grafts_parse__oid_with_parent_and_newline(void);
extern void test_grafts_parse__oid_with_multiple_parents(void);
extern void test_grafts_parse__multiple_oids_with_multiple_parents(void);
extern void test_grafts_parse__multiple_spaces_fails(void);
extern void test_grafts_parse__trailing_space_fails(void);
extern void test_grafts_parse__invalid_character_inbetween_fails(void);
extern void test_grafts_parse__truncated_oid_fails(void);
extern void test_grafts_parse__truncated_parent_fails(void);
extern void test_grafts_parse__invalid_oid_fails(void);
extern void test_grafts_parse__invalid_parent_fails(void);
extern void test_grafts_parse__initialize(void);
extern void test_grafts_parse__cleanup(void);
extern void test_grafts_shallow__no_shallow_file(void);
extern void test_grafts_shallow__empty_shallow_file(void);
extern void test_grafts_shallow__shallow_repo(void);
extern void test_grafts_shallow__clears_errors(void);
extern void test_grafts_shallow__shallow_oids(void);
extern void test_grafts_shallow__cache_clearing(void);
extern void test_grafts_shallow__errors_on_borked(void);
extern void test_grafts_shallow__revwalk_behavior(void);
extern void test_grafts_shallow__grafted_object(void);
extern void test_grafts_shallow__initialize(void);
extern void test_grafts_shallow__cleanup(void);
extern void test_graph_ahead_behind__returns_correct_result(void);
extern void test_graph_ahead_behind__initialize(void);
extern void test_graph_ahead_behind__cleanup(void);
extern void test_graph_commitgraph__parse(void);
extern void test_graph_commitgraph__parse_octopus_merge(void);
extern void test_graph_commitgraph__writer(void);
extern void test_graph_commitgraph__validate(void);
extern void test_graph_commitgraph__validate_corrupt(void);
extern void test_graph_descendant_of__returns_correct_result(void);
extern void test_graph_descendant_of__nopath(void);
extern void test_graph_descendant_of__initialize(void);
extern void test_graph_descendant_of__cleanup(void);
extern void test_graph_reachable_from_any__returns_correct_result(void);
extern void test_graph_reachable_from_any__exhaustive(void);
extern void test_graph_reachable_from_any__initialize(void);
extern void test_graph_reachable_from_any__cleanup(void);
extern void test_ignore_path__honor_temporary_rules(void);
extern void test_ignore_path__allow_root(void);
extern void test_ignore_path__ignore_space(void);
extern void test_ignore_path__intermittent_space(void);
extern void test_ignore_path__trailing_space(void);
extern void test_ignore_path__escaped_trailing_spaces(void);
extern void test_ignore_path__ignore_dir(void);
extern void test_ignore_path__ignore_dir_with_trailing_space(void);
extern void test_ignore_path__ignore_root(void);
extern void test_ignore_path__full_paths(void);
extern void test_ignore_path__more_starstar_cases(void);
extern void test_ignore_path__leading_stars(void);
extern void test_ignore_path__globs_and_path_delimiters(void);
extern void test_ignore_path__globs_without_star(void);
extern void test_ignore_path__skip_gitignore_directory(void);
extern void test_ignore_path__subdirectory_gitignore(void);
extern void test_ignore_path__expand_tilde_to_homedir(void);
extern void test_ignore_path__gitignore_in_subdir(void);
extern void test_ignore_path__dont_ignore_files_for_folder(void);
extern void test_ignore_path__symlink_to_outside(void);
extern void test_ignore_path__test(void);
extern void test_ignore_path__unignore_dir_succeeds(void);
extern void test_ignore_path__case_insensitive_unignores_previous_rule(void);
extern void test_ignore_path__case_sensitive_unignore_does_nothing(void);
extern void test_ignore_path__ignored_subdirfiles_with_subdir_rule(void);
extern void test_ignore_path__ignored_subdirfiles_with_negations(void);
extern void test_ignore_path__negative_directory_rules_only_match_directories(void);
extern void test_ignore_path__escaped_character(void);
extern void test_ignore_path__escaped_newline(void);
extern void test_ignore_path__escaped_glob(void);
extern void test_ignore_path__escaped_comments(void);
extern void test_ignore_path__escaped_slash(void);
extern void test_ignore_path__escaped_space(void);
extern void test_ignore_path__invalid_pattern(void);
extern void test_ignore_path__negative_prefix_rule(void);
extern void test_ignore_path__negative_more_specific(void);
extern void test_ignore_path__initialize(void);
extern void test_ignore_path__cleanup(void);
extern void test_ignore_status__0(void);
extern void test_ignore_status__1(void);
extern void test_ignore_status__empty_repo_with_gitignore_rewrite(void);
extern void test_ignore_status__ignore_pattern_contains_space(void);
extern void test_ignore_status__ignore_pattern_ignorecase(void);
extern void test_ignore_status__subdirectories(void);
extern void test_ignore_status__subdirectories_recursion(void);
extern void test_ignore_status__subdirectories_not_at_root(void);
extern void test_ignore_status__leading_slash_ignores(void);
extern void test_ignore_status__multiple_leading_slash(void);
extern void test_ignore_status__contained_dir_with_matching_name(void);
extern void test_ignore_status__trailing_slash_star(void);
extern void test_ignore_status__adding_internal_ignores(void);
extern void test_ignore_status__add_internal_as_first_thing(void);
extern void test_ignore_status__internal_ignores_inside_deep_paths(void);
extern void test_ignore_status__automatically_ignore_bad_files(void);
extern void test_ignore_status__filenames_with_special_prefixes_do_not_interfere_with_status_retrieval(void);
extern void test_ignore_status__issue_1766_negated_ignores(void);
extern void test_ignore_status__more_breakage(void);
extern void test_ignore_status__negative_ignores_inside_ignores(void);
extern void test_ignore_status__negative_ignores_in_slash_star(void);
extern void test_ignore_status__negative_ignores_without_trailing_slash_inside_ignores(void);
extern void test_ignore_status__negative_directory_ignores(void);
extern void test_ignore_status__unignore_entry_in_ignored_dir(void);
extern void test_ignore_status__do_not_unignore_basename_prefix(void);
extern void test_ignore_status__filename_with_cr(void);
extern void test_ignore_status__subdir_doesnt_match_above(void);
extern void test_ignore_status__negate_exact_previous(void);
extern void test_ignore_status__negate_starstar(void);
extern void test_ignore_status__ignore_all_toplevel_dirs_include_files(void);
extern void test_ignore_status__subdir_ignore_all_toplevel_dirs_include_files(void);
extern void test_ignore_status__subdir_ignore_everything_except_certain_files(void);
extern void test_ignore_status__deeper(void);
extern void test_ignore_status__unignored_dir_with_ignored_contents(void);
extern void test_ignore_status__unignored_subdirs(void);
extern void test_ignore_status__skips_bom(void);
extern void test_ignore_status__leading_spaces_are_significant(void);
extern void test_ignore_status__override_nested_wildcard_unignore(void);
extern void test_ignore_status__initialize(void);
extern void test_ignore_status__cleanup(void);
extern void test_index_add__invalid_entries_succeeds_by_default(void);
extern void test_index_add__two_slash_prefixed(void);
extern void test_index_add__initialize(void);
extern void test_index_add__cleanup(void);
extern void test_index_addall__repo_lifecycle(void);
extern void test_index_addall__files_in_folders(void);
extern void test_index_addall__hidden_files(void);
extern void test_index_addall__callback_filtering(void);
extern void test_index_addall__handles_ignored_files_in_directory(void);
extern void test_index_addall__force_adds_ignored_directories(void);
extern void test_index_addall__adds_conflicts(void);
extern void test_index_addall__removes_deleted_conflicted_files(void);
extern void test_index_addall__initialize(void);
extern void test_index_addall__cleanup(void);
extern void test_index_bypath__add_directory(void);
extern void test_index_bypath__add_submodule(void);
extern void test_index_bypath__add_submodule_unregistered(void);
extern void test_index_bypath__add_hidden(void);
extern void test_index_bypath__add_keeps_existing_case(void);
extern void test_index_bypath__add_honors_existing_case(void);
extern void test_index_bypath__add_honors_existing_case_2(void);
extern void test_index_bypath__add_honors_existing_case_3(void);
extern void test_index_bypath__add_honors_existing_case_4(void);
extern void test_index_bypath__add_honors_mode(void);
extern void test_index_bypath__add_honors_conflict_mode(void);
extern void test_index_bypath__add_honors_conflict_case(void);
extern void test_index_bypath__add_honors_symlink(void);
extern void test_index_bypath__initialize(void);
extern void test_index_bypath__cleanup(void);
extern void test_index_cache__write_extension_at_root(void);
extern void test_index_cache__write_extension_invalidated_root(void);
extern void test_index_cache__read_tree_no_children(void);
extern void test_index_cache__two_levels(void);
extern void test_index_cache__read_tree_children(void);
extern void test_index_cache__initialize(void);
extern void test_index_cache__cleanup(void);
extern void test_index_collision__add_blob_with_conflicting_file(void);
extern void test_index_collision__add_blob_with_conflicting_dir(void);
extern void test_index_collision__add_with_highstage_1(void);
extern void test_index_collision__add_with_highstage_2(void);
extern void test_index_collision__initialize(void);
extern void test_index_collision__cleanup(void);
extern void test_index_conflicts__add(void);
extern void test_index_conflicts__add_fixes_incorrect_stage(void);
extern void test_index_conflicts__add_detects_invalid_filemode(void);
extern void test_index_conflicts__add_removes_stage_zero(void);
extern void test_index_conflicts__get(void);
extern void test_index_conflicts__iterate(void);
extern void test_index_conflicts__remove(void);
extern void test_index_conflicts__moved_to_reuc_on_add(void);
extern void test_index_conflicts__moved_to_reuc_on_remove(void);
extern void test_index_conflicts__remove_all_conflicts(void);
extern void test_index_conflicts__partial(void);
extern void test_index_conflicts__case_matters(void);
extern void test_index_conflicts__initialize(void);
extern void test_index_conflicts__cleanup(void);
extern void test_index_crlf__matches_core_git(void);
extern void test_index_crlf__autocrlf_false_no_attrs(void);
extern void test_index_crlf__autocrlf_true_no_attrs(void);
extern void test_index_crlf__autocrlf_input_no_attrs(void);
extern void test_index_crlf__autocrlf_false_text_auto_attr(void);
extern void test_index_crlf__autocrlf_true_text_auto_attr(void);
extern void test_index_crlf__autocrlf_input_text_auto_attr(void);
extern void test_index_crlf__safecrlf_true_autocrlf_input_text_auto_attr(void);
extern void test_index_crlf__safecrlf_true_autocrlf_input_text__no_attr(void);
extern void test_index_crlf__safecrlf_true_no_attrs(void);
extern void test_index_crlf__initialize(void);
extern void test_index_crlf__cleanup(void);
extern void test_index_filemodes__read(void);
extern void test_index_filemodes__untrusted(void);
extern void test_index_filemodes__trusted(void);
extern void test_index_filemodes__explicit(void);
extern void test_index_filemodes__invalid(void);
extern void test_index_filemodes__frombuffer_requires_files(void);
extern void test_index_filemodes__initialize(void);
extern void test_index_filemodes__cleanup(void);
extern void test_index_inmemory__can_create_an_inmemory_index(void);
extern void test_index_inmemory__cannot_add_bypath_to_an_inmemory_index(void);
extern void test_index_names__add(void);
extern void test_index_names__roundtrip(void);
extern void test_index_names__cleaned_on_reset_hard(void);
extern void test_index_names__cleaned_on_reset_mixed(void);
extern void test_index_names__cleaned_on_checkout_tree(void);
extern void test_index_names__cleaned_on_checkout_head(void);
extern void test_index_names__retained_on_checkout_index(void);
extern void test_index_names__initialize(void);
extern void test_index_names__cleanup(void);
extern void test_index_nsec__has_nanos(void);
extern void test_index_nsec__staging_maintains_other_nanos(void);
extern void test_index_nsec__status_doesnt_clear_nsecs(void);
extern void test_index_nsec__initialize(void);
extern void test_index_nsec__cleanup(void);
extern void test_index_racy__diff(void);
extern void test_index_racy__write_index_just_after_file(void);
extern void test_index_racy__smudges_index_entry_on_save(void);
extern void test_index_racy__detects_diff_of_change_in_identical_timestamp(void);
extern void test_index_racy__adding_to_index_is_uptodate(void);
extern void test_index_racy__reading_clears_uptodate_bit(void);
extern void test_index_racy__read_tree_clears_uptodate_bit(void);
extern void test_index_racy__read_index_smudges(void);
extern void test_index_racy__read_index_clears_uptodate_bit(void);
extern void test_index_racy__initialize(void);
extern void test_index_racy__cleanup(void);
extern void test_index_read_index__maintains_stat_cache(void);
extern void test_index_read_index__produces_treesame_indexes(void);
extern void test_index_read_index__read_and_writes(void);
extern void test_index_read_index__handles_conflicts(void);
extern void test_index_read_index__initialize(void);
extern void test_index_read_index__cleanup(void);
extern void test_index_read_tree__read_write_involution(void);
extern void test_index_rename__single_file(void);
extern void test_index_rename__casechanging(void);
extern void test_index_reuc__add(void);
extern void test_index_reuc__add_no_ancestor(void);
extern void test_index_reuc__read_bypath(void);
extern void test_index_reuc__ignore_case(void);
extern void test_index_reuc__read_byindex(void);
extern void test_index_reuc__updates_existing(void);
extern void test_index_reuc__remove(void);
extern void test_index_reuc__write(void);
extern void test_index_reuc__cleaned_on_reset_hard(void);
extern void test_index_reuc__cleaned_on_reset_mixed(void);
extern void test_index_reuc__retained_on_reset_soft(void);
extern void test_index_reuc__cleaned_on_checkout_tree(void);
extern void test_index_reuc__cleaned_on_checkout_head(void);
extern void test_index_reuc__retained_on_checkout_index(void);
extern void test_index_reuc__initialize(void);
extern void test_index_reuc__cleanup(void);
extern void test_index_splitindex__fail_on_open(void);
extern void test_index_splitindex__initialize(void);
extern void test_index_splitindex__cleanup(void);
extern void test_index_stage__add_always_adds_stage_0(void);
extern void test_index_stage__find_gets_first_stage(void);
extern void test_index_stage__initialize(void);
extern void test_index_stage__cleanup(void);
extern void test_index_tests__empty_index(void);
extern void test_index_tests__default_test_index(void);
extern void test_index_tests__gitgit_index(void);
extern void test_index_tests__find_in_existing(void);
extern void test_index_tests__find_in_empty(void);
extern void test_index_tests__find_prefix(void);
extern void test_index_tests__write(void);
extern void test_index_tests__sort0(void);
extern void test_index_tests__sort1(void);
extern void test_index_tests__add(void);
extern void test_index_tests__add_frombuffer(void);
extern void test_index_tests__dirty_and_clean(void);
extern void test_index_tests__dirty_fails_optionally(void);
extern void test_index_tests__add_frombuffer_reset_entry(void);
extern void test_index_tests__add_issue_1397(void);
extern void test_index_tests__add_bypath_to_a_bare_repository_returns_EBAREPO(void);
extern void test_index_tests__cannot_add_invalid_filename(void);
extern void test_index_tests__cannot_add_protected_invalid_filename(void);
extern void test_index_tests__write_tree_invalid_unowned_index(void);
extern void test_index_tests__write_invalid_filename(void);
extern void test_index_tests__honors_protect_filesystems(void);
extern void test_index_tests__protectntfs_on_by_default(void);
extern void test_index_tests__can_disable_protectntfs(void);
extern void test_index_tests__remove_entry(void);
extern void test_index_tests__remove_directory(void);
extern void test_index_tests__preserves_case(void);
extern void test_index_tests__elocked(void);
extern void test_index_tests__reload_from_disk(void);
extern void test_index_tests__corrupted_extension(void);
extern void test_index_tests__reload_while_ignoring_case(void);
extern void test_index_tests__change_icase_on_instance(void);
extern void test_index_tests__can_lock_index(void);
extern void test_index_tests__can_iterate(void);
extern void test_index_tests__can_modify_while_iterating(void);
extern void test_index_tests__initialize(void);
extern void test_index_tests__cleanup(void);
extern void test_index_tests256__empty_index(void);
extern void test_index_tests256__default_test_index(void);
extern void test_index_tests256__find_in_existing(void);
extern void test_index_tests256__find_in_empty(void);
extern void test_index_tests256__find_prefix(void);
extern void test_index_tests256__write(void);
extern void test_index_tests256__sort1(void);
extern void test_index_tests256__add(void);
extern void test_index_tests256__add_frombuffer(void);
extern void test_index_tests256__dirty_and_clean(void);
extern void test_index_tests256__dirty_fails_optionally(void);
extern void test_index_tests256__add_frombuffer_reset_entry(void);
extern void test_index_tests256__add_bypath_to_a_bare_repository_returns_EBAREPO(void);
extern void test_index_tests256__cannot_add_invalid_filename(void);
extern void test_index_tests256__cannot_add_protected_invalid_filename(void);
extern void test_index_tests256__write_tree_invalid_unowned_index(void);
extern void test_index_tests256__write_invalid_filename(void);
extern void test_index_tests256__honors_protect_filesystems(void);
extern void test_index_tests256__protectntfs_on_by_default(void);
extern void test_index_tests256__can_disable_protectntfs(void);
extern void test_index_tests256__remove_entry(void);
extern void test_index_tests256__remove_directory(void);
extern void test_index_tests256__preserves_case(void);
extern void test_index_tests256__elocked(void);
extern void test_index_tests256__reload_from_disk(void);
extern void test_index_tests256__reload_while_ignoring_case(void);
extern void test_index_tests256__change_icase_on_instance(void);
extern void test_index_tests256__can_lock_index(void);
extern void test_index_tests256__can_iterate(void);
extern void test_index_tests256__can_modify_while_iterating(void);
extern void test_index_tests256__initialize(void);
extern void test_index_tests256__cleanup(void);
extern void test_index_version__can_read_v4(void);
extern void test_index_version__can_write_v4(void);
extern void test_index_version__v4_uses_path_compression(void);
extern void test_index_version__cleanup(void);
extern void test_iterator_index__0(void);
extern void test_iterator_index__1(void);
extern void test_iterator_index__range(void);
extern void test_iterator_index__range_empty_0(void);
extern void test_iterator_index__range_empty_1(void);
extern void test_iterator_index__range_empty_2(void);
extern void test_iterator_index__range_icase(void);
extern void test_iterator_index__case_folding(void);
extern void test_iterator_index__icase_0(void);
extern void test_iterator_index__icase_1(void);
extern void test_iterator_index__pathlist(void);
extern void test_iterator_index__pathlist_with_dirs(void);
extern void test_iterator_index__pathlist_with_dirs_include_trees(void);
extern void test_iterator_index__pathlist_1(void);
extern void test_iterator_index__pathlist_2(void);
extern void test_iterator_index__pathlist_four(void);
extern void test_iterator_index__pathlist_icase(void);
extern void test_iterator_index__pathlist_with_directory(void);
extern void test_iterator_index__pathlist_for_deeply_nested_item(void);
extern void test_iterator_index__advance_over(void);
extern void test_iterator_index__advance_into(void);
extern void test_iterator_index__advance_into_and_over(void);
extern void test_iterator_index__include_conflicts(void);
extern void test_iterator_index__initialize(void);
extern void test_iterator_index__cleanup(void);
extern void test_iterator_tree__0(void);
extern void test_iterator_tree__1(void);
extern void test_iterator_tree__2(void);
extern void test_iterator_tree__3(void);
extern void test_iterator_tree__4(void);
extern void test_iterator_tree__4_ranged(void);
extern void test_iterator_tree__ranged_0(void);
extern void test_iterator_tree__ranged_1(void);
extern void test_iterator_tree__range_empty_0(void);
extern void test_iterator_tree__range_empty_1(void);
extern void test_iterator_tree__range_empty_2(void);
extern void test_iterator_tree__special_functions(void);
extern void test_iterator_tree__range_icase(void);
extern void test_iterator_tree__icase_0(void);
extern void test_iterator_tree__icase_1(void);
extern void test_iterator_tree__icase_2(void);
extern void test_iterator_tree__case_conflicts_0(void);
extern void test_iterator_tree__case_conflicts_1(void);
extern void test_iterator_tree__case_conflicts_2(void);
extern void test_iterator_tree__pathlist(void);
extern void test_iterator_tree__pathlist_icase(void);
extern void test_iterator_tree__pathlist_with_directory(void);
extern void test_iterator_tree__pathlist_with_directory_include_tree_nodes(void);
extern void test_iterator_tree__pathlist_no_match(void);
extern void test_iterator_tree__initialize(void);
extern void test_iterator_tree__cleanup(void);
extern void test_iterator_workdir__0(void);
extern void test_iterator_workdir__1(void);
extern void test_iterator_workdir__1_ranged_0(void);
extern void test_iterator_workdir__1_ranged_1(void);
extern void test_iterator_workdir__1_ranged_3(void);
extern void test_iterator_workdir__1_ranged_4(void);
extern void test_iterator_workdir__1_ranged_5(void);
extern void test_iterator_workdir__1_ranged_5_1_ranged_empty_0(void);
extern void test_iterator_workdir__1_ranged_empty_1(void);
extern void test_iterator_workdir__1_ranged_empty_2(void);
extern void test_iterator_workdir__builtin_ignores(void);
extern void test_iterator_workdir__handles_icase_range(void);
extern void test_iterator_workdir__icase(void);
extern void test_iterator_workdir__icase_starts_and_ends(void);
extern void test_iterator_workdir__depth(void);
extern void test_iterator_workdir__filesystem(void);
extern void test_iterator_workdir__filesystem2(void);
extern void test_iterator_workdir__filesystem_gunk(void);
extern void test_iterator_workdir__skips_unreadable_dirs(void);
extern void test_iterator_workdir__skips_fifos_and_special_files(void);
extern void test_iterator_workdir__pathlist(void);
extern void test_iterator_workdir__pathlist_with_dirs(void);
extern void test_iterator_workdir__pathlist_for_deeply_nested_item(void);
extern void test_iterator_workdir__bounded_submodules(void);
extern void test_iterator_workdir__advance_over(void);
extern void test_iterator_workdir__advance_over_with_pathlist(void);
extern void test_iterator_workdir__advance_into(void);
extern void test_iterator_workdir__pathlist_with_directory(void);
extern void test_iterator_workdir__pathlist_with_directory_include_trees(void);
extern void test_iterator_workdir__hash_when_requested(void);
extern void test_iterator_workdir__initialize(void);
extern void test_iterator_workdir__cleanup(void);
extern void test_mailmap_basic__entry(void);
extern void test_mailmap_basic__lookup_not_found(void);
extern void test_mailmap_basic__lookup(void);
extern void test_mailmap_basic__empty_email_query(void);
extern void test_mailmap_basic__name_matching(void);
extern void test_mailmap_basic__initialize(void);
extern void test_mailmap_basic__cleanup(void);
extern void test_mailmap_blame__hunks(void);
extern void test_mailmap_blame__hunks_no_mailmap(void);
extern void test_mailmap_blame__initialize(void);
extern void test_mailmap_blame__cleanup(void);
extern void test_mailmap_parsing__string(void);
extern void test_mailmap_parsing__windows_string(void);
extern void test_mailmap_parsing__fromrepo(void);
extern void test_mailmap_parsing__frombare(void);
extern void test_mailmap_parsing__file_config(void);
extern void test_mailmap_parsing__blob_config(void);
extern void test_mailmap_parsing__bare_blob_config(void);
extern void test_mailmap_parsing__initialize(void);
extern void test_mailmap_parsing__cleanup(void);
extern void test_merge_analysis__fastforward(void);
extern void test_merge_analysis__no_fastforward(void);
extern void test_merge_analysis__uptodate(void);
extern void test_merge_analysis__uptodate_merging_prev_commit(void);
extern void test_merge_analysis__unborn(void);
extern void test_merge_analysis__fastforward_with_config_noff(void);
extern void test_merge_analysis__no_fastforward_with_config_ffonly(void);
extern void test_merge_analysis__between_uptodate_refs(void);
extern void test_merge_analysis__between_noff_refs(void);
extern void test_merge_analysis__initialize_with_bare_repository(void);
extern void test_merge_analysis__initialize_with_nonbare_repository(void);
extern void test_merge_analysis__cleanup(void);
extern void test_merge_annotated_commit__lookup_annotated_tag(void);
extern void test_merge_annotated_commit__initialize(void);
extern void test_merge_annotated_commit__cleanup(void);
extern void test_merge_driver__custom(void);
extern void test_merge_driver__wildcard(void);
extern void test_merge_driver__shutdown_is_called(void);
extern void test_merge_driver__apply_can_defer(void);
extern void test_merge_driver__apply_can_conflict(void);
extern void test_merge_driver__default_can_be_specified(void);
extern void test_merge_driver__honors_builtin_mergedefault(void);
extern void test_merge_driver__honors_custom_mergedefault(void);
extern void test_merge_driver__mergedefault_deferring_falls_back_to_text(void);
extern void test_merge_driver__set_forces_text(void);
extern void test_merge_driver__unset_forces_binary(void);
extern void test_merge_driver__not_configured_driver_falls_back(void);
extern void test_merge_driver__initialize(void);
extern void test_merge_driver__cleanup(void);
extern void test_merge_files__automerge_from_bufs(void);
extern void test_merge_files__automerge_use_best_path_and_mode(void);
extern void test_merge_files__conflict_from_bufs(void);
extern void test_merge_files__automerge_from_index(void);
extern void test_merge_files__automerge_whitespace_eol(void);
extern void test_merge_files__automerge_whitespace_change(void);
extern void test_merge_files__doesnt_add_newline(void);
extern void test_merge_files__skips_large_files(void);
extern void test_merge_files__skips_binaries(void);
extern void test_merge_files__handles_binaries_when_favored(void);
extern void test_merge_files__crlf_conflict_markers_for_crlf_files(void);
extern void test_merge_files__conflicts_in_zdiff3(void);
extern void test_merge_files__initialize(void);
extern void test_merge_files__cleanup(void);
extern void test_merge_trees_automerge__automerge(void);
extern void test_merge_trees_automerge__favor_ours(void);
extern void test_merge_trees_automerge__favor_theirs(void);
extern void test_merge_trees_automerge__unrelated(void);
extern void test_merge_trees_automerge__initialize(void);
extern void test_merge_trees_automerge__cleanup(void);
extern void test_merge_trees_commits__automerge(void);
extern void test_merge_trees_commits__no_ancestor(void);
extern void test_merge_trees_commits__df_conflict(void);
extern void test_merge_trees_commits__fail_on_conflict(void);
extern void test_merge_trees_commits__initialize(void);
extern void test_merge_trees_commits__cleanup(void);
extern void test_merge_trees_modeconflict__df_conflict(void);
extern void test_merge_trees_modeconflict__initialize(void);
extern void test_merge_trees_modeconflict__cleanup(void);
extern void test_merge_trees_recursive__one_base_commit(void);
extern void test_merge_trees_recursive__one_base_commit_norecursive(void);
extern void test_merge_trees_recursive__two_base_commits(void);
extern void test_merge_trees_recursive__two_base_commits_norecursive(void);
extern void test_merge_trees_recursive__two_levels_of_multiple_bases(void);
extern void test_merge_trees_recursive__two_levels_of_multiple_bases_norecursive(void);
extern void test_merge_trees_recursive__three_levels_of_multiple_bases(void);
extern void test_merge_trees_recursive__three_levels_of_multiple_bases_norecursive(void);
extern void test_merge_trees_recursive__three_base_commits(void);
extern void test_merge_trees_recursive__three_base_commits_norecursive(void);
extern void test_merge_trees_recursive__conflict(void);
extern void test_merge_trees_recursive__oh_so_many_levels_of_recursion(void);
extern void test_merge_trees_recursive__conflicting_merge_base(void);
extern void test_merge_trees_recursive__conflicting_merge_base_with_diff3(void);
extern void test_merge_trees_recursive__conflicting_merge_base_since_resolved(void);
extern void test_merge_trees_recursive__recursionlimit(void);
extern void test_merge_trees_recursive__merge_base_for_virtual_commit(void);
extern void test_merge_trees_recursive__merge_base_for_virtual_commit_2(void);
extern void test_merge_trees_recursive__initialize(void);
extern void test_merge_trees_recursive__cleanup(void);
extern void test_merge_trees_renames__index(void);
extern void test_merge_trees_renames__no_rename_index(void);
extern void test_merge_trees_renames__submodules(void);
extern void test_merge_trees_renames__cache_recomputation(void);
extern void test_merge_trees_renames__emptyfile_renames(void);
extern void test_merge_trees_renames__initialize(void);
extern void test_merge_trees_renames__cleanup(void);
extern void test_merge_trees_treediff__simple(void);
extern void test_merge_trees_treediff__df_conflicts(void);
extern void test_merge_trees_treediff__strict_renames(void);
extern void test_merge_trees_treediff__rename_conflicts(void);
extern void test_merge_trees_treediff__best_renames(void);
extern void test_merge_trees_treediff__initialize(void);
extern void test_merge_trees_treediff__cleanup(void);
extern void test_merge_trees_trivial__2alt(void);
extern void test_merge_trees_trivial__3alt(void);
extern void test_merge_trees_trivial__4(void);
extern void test_merge_trees_trivial__5alt_1(void);
extern void test_merge_trees_trivial__5alt_2(void);
extern void test_merge_trees_trivial__6(void);
extern void test_merge_trees_trivial__8(void);
extern void test_merge_trees_trivial__7(void);
extern void test_merge_trees_trivial__10(void);
extern void test_merge_trees_trivial__9(void);
extern void test_merge_trees_trivial__13(void);
extern void test_merge_trees_trivial__14(void);
extern void test_merge_trees_trivial__11(void);
extern void test_merge_trees_trivial__initialize(void);
extern void test_merge_trees_trivial__cleanup(void);
extern void test_merge_trees_whitespace__conflict(void);
extern void test_merge_trees_whitespace__eol(void);
extern void test_merge_trees_whitespace__change(void);
extern void test_merge_trees_whitespace__initialize(void);
extern void test_merge_trees_whitespace__cleanup(void);
extern void test_merge_workdir_dirty__unaffected_dirty_files_allowed(void);
extern void test_merge_workdir_dirty__unstaged_deletes_maintained(void);
extern void test_merge_workdir_dirty__affected_dirty_files_disallowed(void);
extern void test_merge_workdir_dirty__staged_files_in_index_disallowed(void);
extern void test_merge_workdir_dirty__identical_staged_files_allowed(void);
extern void test_merge_workdir_dirty__honors_cache(void);
extern void test_merge_workdir_dirty__initialize(void);
extern void test_merge_workdir_dirty__cleanup(void);
extern void test_merge_workdir_recursive__writes_conflict_with_virtual_base(void);
extern void test_merge_workdir_recursive__conflicting_merge_base_with_diff3(void);
extern void test_merge_workdir_recursive__initialize(void);
extern void test_merge_workdir_recursive__cleanup(void);
extern void test_merge_workdir_renames__renames(void);
extern void test_merge_workdir_renames__ours(void);
extern void test_merge_workdir_renames__similar(void);
extern void test_merge_workdir_renames__initialize(void);
extern void test_merge_workdir_renames__cleanup(void);
extern void test_merge_workdir_setup__one_branch(void);
extern void test_merge_workdir_setup__one_oid(void);
extern void test_merge_workdir_setup__two_branches(void);
extern void test_merge_workdir_setup__three_branches(void);
extern void test_merge_workdir_setup__three_oids(void);
extern void test_merge_workdir_setup__branches_and_oids_1(void);
extern void test_merge_workdir_setup__branches_and_oids_2(void);
extern void test_merge_workdir_setup__branches_and_oids_3(void);
extern void test_merge_workdir_setup__branches_and_oids_4(void);
extern void test_merge_workdir_setup__three_same_branches(void);
extern void test_merge_workdir_setup__three_same_oids(void);
extern void test_merge_workdir_setup__remote_tracking_one_branch(void);
extern void test_merge_workdir_setup__remote_tracking_two_branches(void);
extern void test_merge_workdir_setup__remote_tracking_three_branches(void);
extern void test_merge_workdir_setup__normal_branch_and_remote_tracking_branch(void);
extern void test_merge_workdir_setup__remote_tracking_branch_and_normal_branch(void);
extern void test_merge_workdir_setup__two_remote_tracking_branch_and_two_normal_branches(void);
extern void test_merge_workdir_setup__pull_one(void);
extern void test_merge_workdir_setup__pull_two(void);
extern void test_merge_workdir_setup__pull_three(void);
extern void test_merge_workdir_setup__three_remotes(void);
extern void test_merge_workdir_setup__two_remotes(void);
extern void test_merge_workdir_setup__id_from_head(void);
extern void test_merge_workdir_setup__head_notfound(void);
extern void test_merge_workdir_setup__head_invalid_oid(void);
extern void test_merge_workdir_setup__head_foreach_nonewline(void);
extern void test_merge_workdir_setup__head_foreach_one(void);
extern void test_merge_workdir_setup__head_foreach_octopus(void);
extern void test_merge_workdir_setup__retained_after_success(void);
extern void test_merge_workdir_setup__removed_after_failure(void);
extern void test_merge_workdir_setup__unlocked_after_success(void);
extern void test_merge_workdir_setup__unlocked_after_conflict(void);
extern void test_merge_workdir_setup__initialize(void);
extern void test_merge_workdir_setup__cleanup(void);
extern void test_merge_workdir_simple__automerge(void);
extern void test_merge_workdir_simple__index_reload(void);
extern void test_merge_workdir_simple__automerge_crlf(void);
extern void test_merge_workdir_simple__mergefile(void);
extern void test_merge_workdir_simple__diff3(void);
extern void test_merge_workdir_simple__zdiff3(void);
extern void test_merge_workdir_simple__union(void);
extern void test_merge_workdir_simple__gitattributes_union(void);
extern void test_merge_workdir_simple__diff3_from_config(void);
extern void test_merge_workdir_simple__zdiff3_from_config(void);
extern void test_merge_workdir_simple__merge_overrides_config(void);
extern void test_merge_workdir_simple__checkout_ours(void);
extern void test_merge_workdir_simple__favor_ours(void);
extern void test_merge_workdir_simple__favor_theirs(void);
extern void test_merge_workdir_simple__directory_file(void);
extern void test_merge_workdir_simple__unrelated(void);
extern void test_merge_workdir_simple__unrelated_with_conflicts(void);
extern void test_merge_workdir_simple__binary(void);
extern void test_merge_workdir_simple__initialize(void);
extern void test_merge_workdir_simple__cleanup(void);
extern void test_merge_workdir_submodules__automerge(void);
extern void test_merge_workdir_submodules__take_changed(void);
extern void test_merge_workdir_submodules__update_delete_conflict(void);
extern void test_merge_workdir_submodules__initialize(void);
extern void test_merge_workdir_submodules__cleanup(void);
extern void test_merge_workdir_trivial__2alt(void);
extern void test_merge_workdir_trivial__3alt(void);
extern void test_merge_workdir_trivial__4(void);
extern void test_merge_workdir_trivial__5alt_1(void);
extern void test_merge_workdir_trivial__5alt_2(void);
extern void test_merge_workdir_trivial__6(void);
extern void test_merge_workdir_trivial__8(void);
extern void test_merge_workdir_trivial__7(void);
extern void test_merge_workdir_trivial__10(void);
extern void test_merge_workdir_trivial__9(void);
extern void test_merge_workdir_trivial__13(void);
extern void test_merge_workdir_trivial__14(void);
extern void test_merge_workdir_trivial__11(void);
extern void test_merge_workdir_trivial__initialize(void);
extern void test_merge_workdir_trivial__cleanup(void);
extern void test_message_trailer__simple(void);
extern void test_message_trailer__no_whitespace(void);
extern void test_message_trailer__extra_whitespace(void);
extern void test_message_trailer__no_newline(void);
extern void test_message_trailer__not_last_paragraph(void);
extern void test_message_trailer__conflicts(void);
extern void test_message_trailer__patch(void);
extern void test_message_trailer__continuation(void);
extern void test_message_trailer__invalid(void);
extern void test_message_trailer__ignores_dashes(void);
extern void test_network_cred__stock_userpass_validates_args(void);
extern void test_network_cred__stock_userpass_validates_that_method_is_allowed(void);
extern void test_network_cred__stock_userpass_properly_handles_username_in_url(void);
extern void test_network_fetchlocal__complete(void);
extern void test_network_fetchlocal__prune(void);
extern void test_network_fetchlocal__prune_overlapping(void);
extern void test_network_fetchlocal__fetchprune(void);
extern void test_network_fetchlocal__prune_tag(void);
extern void test_network_fetchlocal__partial(void);
extern void test_network_fetchlocal__clone_into_mirror(void);
extern void test_network_fetchlocal__all_refs(void);
extern void test_network_fetchlocal__multi_remotes(void);
extern void test_network_fetchlocal__call_progress(void);
extern void test_network_fetchlocal__prune_load_remote_prune_config(void);
extern void test_network_fetchlocal__prune_load_fetch_prune_config(void);
extern void test_network_fetchlocal__update_tips_error_is_propagated(void);
extern void test_network_fetchlocal__cleanup(void);
extern void test_network_refspecs__parsing(void);
extern void test_network_refspecs__transform_mid_star(void);
extern void test_network_refspecs__transform_loosened_star(void);
extern void test_network_refspecs__transform_nested_star(void);
extern void test_network_refspecs__no_dst(void);
extern void test_network_refspecs__invalid(void);
extern void test_network_refspecs__invalid_reverse(void);
extern void test_network_refspecs__matching(void);
extern void test_network_refspecs__parse_free(void);
extern void test_network_remote_defaultbranch__master(void);
extern void test_network_remote_defaultbranch__master_does_not_win(void);
extern void test_network_remote_defaultbranch__master_on_detached(void);
extern void test_network_remote_defaultbranch__no_default_branch(void);
extern void test_network_remote_defaultbranch__detached_sharing_nonbranch_id(void);
extern void test_network_remote_defaultbranch__unborn_HEAD_with_branches(void);
extern void test_network_remote_defaultbranch__initialize(void);
extern void test_network_remote_defaultbranch__cleanup(void);
extern void test_network_remote_delete__remove_remote_tracking_branches(void);
extern void test_network_remote_delete__remove_remote_configuration_settings(void);
extern void test_network_remote_delete__remove_branch_upstream_configuration_settings(void);
extern void test_network_remote_delete__initialize(void);
extern void test_network_remote_delete__cleanup(void);
extern void test_network_remote_isvalidname__can_detect_invalid_formats(void);
extern void test_network_remote_isvalidname__wont_hopefully_choke_on_valid_formats(void);
extern void test_network_remote_local__connected(void);
extern void test_network_remote_local__retrieve_advertised_references(void);
extern void test_network_remote_local__retrieve_advertised_before_connect(void);
extern void test_network_remote_local__retrieve_advertised_references_after_disconnect(void);
extern void test_network_remote_local__retrieve_advertised_references_from_spaced_repository(void);
extern void test_network_remote_local__nested_tags_are_completely_peeled(void);
extern void test_network_remote_local__shorthand_fetch_refspec0(void);
extern void test_network_remote_local__shorthand_fetch_refspec1(void);
extern void test_network_remote_local__tagopt(void);
extern void test_network_remote_local__push_to_bare_remote(void);
extern void test_network_remote_local__push_to_bare_remote_with_file_url(void);
extern void test_network_remote_local__push_to_non_bare_remote(void);
extern void test_network_remote_local__fetch(void);
extern void test_network_remote_local__reflog(void);
extern void test_network_remote_local__fetch_default_reflog_message(void);
extern void test_network_remote_local__opportunistic_update(void);
extern void test_network_remote_local__update_tips_for_new_remote(void);
extern void test_network_remote_local__push_delete(void);
extern void test_network_remote_local__anonymous_remote_inmemory_repo(void);
extern void test_network_remote_local__initialize(void);
extern void test_network_remote_local__cleanup(void);
extern void test_network_remote_push__delete_notification(void);
extern void test_network_remote_push__create_notification(void);
extern void test_network_remote_push__initialize(void);
extern void test_network_remote_push__cleanup(void);
extern void test_network_remote_remotes__parsing(void);
extern void test_network_remote_remotes__remote_ready(void);
extern void test_network_remote_remotes__urlresolve(void);
extern void test_network_remote_remotes__urlresolve_passthrough(void);
extern void test_network_remote_remotes__instance_url(void);
extern void test_network_remote_remotes__pushurl(void);
extern void test_network_remote_remotes__error_when_not_found(void);
extern void test_network_remote_remotes__error_when_no_push_available(void);
extern void test_network_remote_remotes__refspec_parsing(void);
extern void test_network_remote_remotes__add_fetchspec(void);
extern void test_network_remote_remotes__dup(void);
extern void test_network_remote_remotes__add_pushspec(void);
extern void test_network_remote_remotes__fnmatch(void);
extern void test_network_remote_remotes__transform(void);
extern void test_network_remote_remotes__transform_destination_to_source(void);
extern void test_network_remote_remotes__missing_refspecs(void);
extern void test_network_remote_remotes__nonmatch_upstream_refspec(void);
extern void test_network_remote_remotes__list(void);
extern void test_network_remote_remotes__loading_a_missing_remote_returns_ENOTFOUND(void);
extern void test_network_remote_remotes__loading_with_an_invalid_name_returns_EINVALIDSPEC(void);
extern void test_network_remote_remotes__add(void);
extern void test_network_remote_remotes__tagopt(void);
extern void test_network_remote_remotes__can_load_with_an_empty_url(void);
extern void test_network_remote_remotes__can_load_with_only_an_empty_pushurl(void);
extern void test_network_remote_remotes__returns_ENOTFOUND_when_neither_url_nor_pushurl(void);
extern void test_network_remote_remotes__query_refspecs(void);
extern void test_network_remote_remotes__initialize(void);
extern void test_network_remote_remotes__cleanup(void);
extern void test_network_remote_rename__renaming_a_remote_moves_related_configuration_section(void);
extern void test_network_remote_rename__renaming_a_remote_updates_branch_related_configuration_entries(void);
extern void test_network_remote_rename__renaming_a_remote_updates_default_fetchrefspec(void);
extern void test_network_remote_rename__renaming_a_remote_without_a_fetchrefspec_doesnt_create_one(void);
extern void test_network_remote_rename__renaming_a_remote_notifies_of_non_default_fetchrefspec(void);
extern void test_network_remote_rename__new_name_can_contain_dots(void);
extern void test_network_remote_rename__new_name_must_conform_to_reference_naming_conventions(void);
extern void test_network_remote_rename__renamed_name_is_persisted(void);
extern void test_network_remote_rename__cannot_overwrite_an_existing_remote(void);
extern void test_network_remote_rename__renaming_a_remote_moves_the_underlying_reference(void);
extern void test_network_remote_rename__overwrite_ref_in_target(void);
extern void test_network_remote_rename__nonexistent_returns_enotfound(void);
extern void test_network_remote_rename__symref_head(void);
extern void test_network_remote_rename__initialize(void);
extern void test_network_remote_rename__cleanup(void);
extern void test_notes_notes__can_create_a_note(void);
extern void test_notes_notes__can_create_a_note_from_commit(void);
extern void test_notes_notes__can_create_a_note_from_commit_given_an_existing_commit(void);
extern void test_notes_notes__can_retrieve_a_list_of_notes_for_a_given_namespace(void);
extern void test_notes_notes__can_cancel_foreach(void);
extern void test_notes_notes__retrieving_a_list_of_notes_for_an_unknown_namespace_returns_ENOTFOUND(void);
extern void test_notes_notes__inserting_a_note_without_passing_a_namespace_uses_the_default_namespace(void);
extern void test_notes_notes__can_insert_a_note_with_a_custom_namespace(void);
extern void test_notes_notes__creating_a_note_on_a_target_which_already_has_one_returns_EEXISTS(void);
extern void test_notes_notes__creating_a_note_on_a_target_can_overwrite_existing_note(void);
extern void test_notes_notes__can_read_a_note(void);
extern void test_notes_notes__can_read_a_note_from_a_commit(void);
extern void test_notes_notes__attempt_to_read_a_note_from_a_commit_with_no_note_fails(void);
extern void test_notes_notes__can_insert_a_note_in_an_existing_fanout(void);
extern void test_notes_notes__can_read_a_note_in_an_existing_fanout(void);
extern void test_notes_notes__can_remove_a_note(void);
extern void test_notes_notes__can_remove_a_note_from_commit(void);
extern void test_notes_notes__can_remove_a_note_in_an_existing_fanout(void);
extern void test_notes_notes__removing_a_note_which_doesnt_exists_returns_ENOTFOUND(void);
extern void test_notes_notes__can_iterate_default_namespace(void);
extern void test_notes_notes__can_iterate_custom_namespace(void);
extern void test_notes_notes__empty_iterate(void);
extern void test_notes_notes__iterate_from_commit(void);
extern void test_notes_notes__initialize(void);
extern void test_notes_notes__cleanup(void);
extern void test_notes_notesref__config_corenotesref(void);
extern void test_notes_notesref__initialize(void);
extern void test_notes_notesref__cleanup(void);
extern void test_object_blob_filter__unfiltered(void);
extern void test_object_blob_filter__stats(void);
extern void test_object_blob_filter__to_odb(void);
extern void test_object_blob_filter__initialize(void);
extern void test_object_blob_filter__cleanup(void);
extern void test_object_blob_fromstream__multiple_write(void);
extern void test_object_blob_fromstream__creating_a_blob_from_chunks_honors_the_attributes_directives(void);
extern void test_object_blob_fromstream__initialize(void);
extern void test_object_blob_fromstream__cleanup(void);
extern void test_object_blob_write__can_create_a_blob_in_a_standard_repo_from_a_file_located_in_the_working_directory(void);
extern void test_object_blob_write__can_create_a_blob_in_a_standard_repo_from_a_absolute_filepath_pointing_outside_of_the_working_directory(void);
extern void test_object_blob_write__can_create_a_blob_in_a_bare_repo_from_a_absolute_filepath(void);
extern void test_object_blob_write__cleanup(void);
extern void test_object_cache__cache_counts(void);
extern void test_object_cache__threadmania(void);
extern void test_object_cache__fast_thread_rush(void);
extern void test_object_cache__initialize_cache_no_blobs(void);
extern void test_object_cache__initialize_cache_tiny_blobs(void);
extern void test_object_cache__initialize_cache_all_blobs(void);
extern void test_object_cache__initialize_cache_no_trees(void);
extern void test_object_cache__cleanup(void);
extern void test_object_commit_commitstagedfile__generate_predictable_object_ids(void);
extern void test_object_commit_commitstagedfile__amend_commit(void);
extern void test_object_commit_commitstagedfile__initialize(void);
extern void test_object_commit_commitstagedfile__cleanup(void);
extern void test_object_commit_parse__sha1_parsing_commit_succeeds(void);
extern void test_object_commit_parse__sha1_parsing_commit_without_encoding_succeeds(void);
extern void test_object_commit_parse__sha1_parsing_commit_with_multiple_authors_succeeds(void);
extern void test_object_commit_parse__sha1_parsing_commit_with_multiple_committers_succeeds(void);
extern void test_object_commit_parse__sha1_parsing_commit_without_message_succeeds(void);
extern void test_object_commit_parse__sha1_parsing_commit_with_unknown_fields_succeeds(void);
extern void test_object_commit_parse__sha1_parsing_commit_with_invalid_tree_fails(void);
extern void test_object_commit_parse__sha1_parsing_commit_with_sha256_tree_fails(void);
extern void test_object_commit_parse__sha1_parsing_commit_without_tree_fails(void);
extern void test_object_commit_parse__sha1_parsing_commit_without_author_fails(void);
extern void test_object_commit_parse__sha1_parsing_commit_without_committer_fails(void);
extern void test_object_commit_parse__sha1_parsing_encoding_will_not_cause_oob_read(void);
extern void test_object_commit_parse__sha256_parsing_commit_succeeds(void);
extern void test_object_commit_parse__sha256_parsing_commit_without_encoding_succeeds(void);
extern void test_object_commit_parse__sha256_parsing_commit_with_multiple_authors_succeeds(void);
extern void test_object_commit_parse__sha256_parsing_commit_with_multiple_committers_succeeds(void);
extern void test_object_commit_parse__sha256_parsing_commit_without_message_succeeds(void);
extern void test_object_commit_parse__sha256_parsing_commit_with_unknown_fields_succeeds(void);
extern void test_object_commit_parse__sha256_parsing_commit_with_invalid_tree_fails(void);
extern void test_object_commit_parse__sha256_parsing_commit_with_sha1_tree_fails(void);
extern void test_object_commit_parse__sha256_parsing_commit_without_tree_fails(void);
extern void test_object_commit_parse__sha256_parsing_commit_without_author_fails(void);
extern void test_object_commit_parse__sha256_parsing_commit_without_committer_fails(void);
extern void test_object_commit_parse__sha256_parsing_encoding_will_not_cause_oob_read(void);
extern void test_object_lookup__lookup_wrong_type_returns_enotfound(void);
extern void test_object_lookup__lookup_nonexisting_returns_enotfound(void);
extern void test_object_lookup__lookup_wrong_type_by_abbreviated_id_returns_enotfound(void);
extern void test_object_lookup__lookup_wrong_type_eventually_returns_enotfound(void);
extern void test_object_lookup__lookup_corrupt_object_returns_error(void);
extern void test_object_lookup__lookup_object_with_wrong_hash_returns_error(void);
extern void test_object_lookup__initialize(void);
extern void test_object_lookup__cleanup(void);
extern void test_object_lookup256__lookup_wrong_type_returns_enotfound(void);
extern void test_object_lookup256__lookup_nonexisting_returns_enotfound(void);
extern void test_object_lookup256__lookup_wrong_type_by_abbreviated_id_returns_enotfound(void);
extern void test_object_lookup256__lookup_wrong_type_eventually_returns_enotfound(void);
extern void test_object_lookup256__lookup_corrupt_object_returns_error(void);
extern void test_object_lookup256__lookup_object_with_wrong_hash_returns_error(void);
extern void test_object_lookup256__initialize(void);
extern void test_object_lookup256__cleanup(void);
extern void test_object_lookupbypath__errors(void);
extern void test_object_lookupbypath__from_root_tree(void);
extern void test_object_lookupbypath__from_head_commit(void);
extern void test_object_lookupbypath__from_subdir_tree(void);
extern void test_object_lookupbypath__initialize(void);
extern void test_object_lookupbypath__cleanup(void);
extern void test_object_message__long_lines_without_spaces_should_be_unchanged(void);
extern void test_object_message__lines_with_spaces_at_the_beginning_should_be_unchanged(void);
extern void test_object_message__lines_with_intermediate_spaces_should_be_unchanged(void);
extern void test_object_message__consecutive_blank_lines_should_be_unified(void);
extern void test_object_message__only_consecutive_blank_lines_should_be_completely_removed(void);
extern void test_object_message__consecutive_blank_lines_at_the_beginning_should_be_removed(void);
extern void test_object_message__consecutive_blank_lines_at_the_end_should_be_removed(void);
extern void test_object_message__text_without_newline_at_end_should_end_with_newline(void);
extern void test_object_message__text_plus_spaces_without_newline_should_not_show_spaces_and_end_with_newline(void);
extern void test_object_message__text_plus_spaces_ending_with_newline_should_be_cleaned_and_newline_must_remain(void);
extern void test_object_message__spaces_with_newline_at_end_should_be_replaced_with_empty_string(void);
extern void test_object_message__spaces_without_newline_at_end_should_be_replaced_with_empty_string(void);
extern void test_object_message__consecutive_text_lines_should_be_unchanged(void);
extern void test_object_message__strip_comments(void);
extern void test_object_message__keep_comments(void);
extern void test_object_message__message_prettify(void);
extern void test_object_peel__peeling_an_object_into_its_own_type_returns_another_instance_of_it(void);
extern void test_object_peel__tag(void);
extern void test_object_peel__commit(void);
extern void test_object_peel__tree(void);
extern void test_object_peel__blob(void);
extern void test_object_peel__target_any_object_for_type_change(void);
extern void test_object_peel__initialize(void);
extern void test_object_peel__cleanup(void);
extern void test_object_raw_chars__find_invalid_chars_in_oid(void);
extern void test_object_raw_chars__build_valid_oid_from_raw_bytes(void);
extern void test_object_raw_compare__succeed_on_copy_oid(void);
extern void test_object_raw_compare__succeed_on_oid_comparison_lesser(void);
extern void test_object_raw_compare__succeed_on_oid_comparison_equal(void);
extern void test_object_raw_compare__succeed_on_oid_comparison_greater(void);
extern void test_object_raw_compare__compare_fmt_oids(void);
extern void test_object_raw_compare__compare_static_oids(void);
extern void test_object_raw_compare__compare_pathfmt_oids(void);
extern void test_object_raw_convert__succeed_on_oid_to_string_conversion(void);
extern void test_object_raw_convert__succeed_on_oid_to_string_conversion_big(void);
extern void test_object_raw_convert__convert_oid_partially(void);
extern void test_object_raw_fromstr__fail_on_invalid_oid_string(void);
extern void test_object_raw_fromstr__succeed_on_valid_oid_string(void);
extern void test_object_raw_hash__hash_by_blocks(void);
extern void test_object_raw_hash__hash_buffer_in_single_call(void);
extern void test_object_raw_hash__hash_vector(void);
extern void test_object_raw_hash__hash_junk_data(void);
extern void test_object_raw_hash__hash_commit_object(void);
extern void test_object_raw_hash__hash_tree_object(void);
extern void test_object_raw_hash__hash_tag_object(void);
extern void test_object_raw_hash__hash_zero_length_object(void);
extern void test_object_raw_hash__hash_one_byte_object(void);
extern void test_object_raw_hash__hash_two_byte_object(void);
extern void test_object_raw_hash__hash_multi_byte_object(void);
extern void test_object_raw_short__oid_shortener_no_duplicates(void);
extern void test_object_raw_short__oid_shortener_stresstest_git_oid_shorten(void);
extern void test_object_raw_short__oid_shortener_too_much_oids(void);
extern void test_object_raw_size__validate_oid_size(void);
extern void test_object_raw_type2string__convert_type_to_string(void);
extern void test_object_raw_type2string__convert_string_to_type(void);
extern void test_object_raw_type2string__check_type_is_loose(void);
extern void test_object_raw_write__loose_object(void);
extern void test_object_raw_write__loose_tree(void);
extern void test_object_raw_write__loose_tag(void);
extern void test_object_raw_write__zero_length(void);
extern void test_object_raw_write__one_byte(void);
extern void test_object_raw_write__two_byte(void);
extern void test_object_raw_write__several_bytes(void);
extern void test_object_shortid__select(void);
extern void test_object_shortid__initialize(void);
extern void test_object_shortid__cleanup(void);
extern void test_object_tag_list__list_all(void);
extern void test_object_tag_list__list_by_pattern(void);
extern void test_object_tag_list__initialize(void);
extern void test_object_tag_list__cleanup(void);
extern void test_object_tag_parse__valid_tag_parses(void);
extern void test_object_tag_parse__missing_tagger_parses(void);
extern void test_object_tag_parse__missing_message_parses(void);
extern void test_object_tag_parse__unknown_field_parses(void);
extern void test_object_tag_parse__missing_object_fails(void);
extern void test_object_tag_parse__malformatted_object_fails(void);
extern void test_object_tag_parse__missing_type_fails(void);
extern void test_object_tag_parse__invalid_type_fails(void);
extern void test_object_tag_parse__missing_tagname_fails(void);
extern void test_object_tag_parse__misformatted_tagger_fails(void);
extern void test_object_tag_parse__missing_message_fails(void);
extern void test_object_tag_parse__no_oob_read_when_searching_message(void);
extern void test_object_tag_peel__can_peel_to_a_commit(void);
extern void test_object_tag_peel__can_peel_several_nested_tags_to_a_commit(void);
extern void test_object_tag_peel__can_peel_to_a_non_commit(void);
extern void test_object_tag_peel__initialize(void);
extern void test_object_tag_peel__cleanup(void);
extern void test_object_tag_read__parse(void);
extern void test_object_tag_read__parse_without_tagger(void);
extern void test_object_tag_read__parse_without_message(void);
extern void test_object_tag_read__without_tagger_nor_message(void);
extern void test_object_tag_read__extra_header_fields(void);
extern void test_object_tag_read__initialize(void);
extern void test_object_tag_read__cleanup(void);
extern void test_object_tag_write__basic(void);
extern void test_object_tag_write__overwrite(void);
extern void test_object_tag_write__replace(void);
extern void test_object_tag_write__lightweight(void);
extern void test_object_tag_write__lightweight_over_existing(void);
extern void test_object_tag_write__delete(void);
extern void test_object_tag_write__creating_with_an_invalid_name_returns_EINVALIDSPEC(void);
extern void test_object_tag_write__deleting_with_an_invalid_name_returns_EINVALIDSPEC(void);
extern void test_object_tag_write__creating_an_annotation_stores_the_new_object_in_the_odb(void);
extern void test_object_tag_write__creating_an_annotation_does_not_create_a_reference(void);
extern void test_object_tag_write__error_when_create_tag_with_invalid_name(void);
extern void test_object_tag_write__initialize(void);
extern void test_object_tag_write__cleanup(void);
extern void test_object_tree_attributes__ensure_correctness_of_attributes_on_insertion(void);
extern void test_object_tree_attributes__group_writable_tree_entries_created_with_an_antique_git_version_can_still_be_accessed(void);
extern void test_object_tree_attributes__treebuilder_reject_invalid_filemode(void);
extern void test_object_tree_attributes__normalize_attributes_when_creating_a_tree_from_an_existing_one(void);
extern void test_object_tree_attributes__normalize_600(void);
extern void test_object_tree_attributes__initialize(void);
extern void test_object_tree_attributes__cleanup(void);
extern void test_object_tree_duplicateentries__cannot_create_a_duplicate_entry_through_the_treebuilder(void);
extern void test_object_tree_duplicateentries__cannot_create_a_duplicate_entry_building_a_tree_from_a_index_with_conflicts(void);
extern void test_object_tree_duplicateentries__initialize(void);
extern void test_object_tree_duplicateentries__cleanup(void);
extern void test_object_tree_frompath__retrieve_tree_from_path_to_treeentry(void);
extern void test_object_tree_frompath__fail_when_processing_an_invalid_path(void);
extern void test_object_tree_frompath__initialize(void);
extern void test_object_tree_frompath__cleanup(void);
extern void test_object_tree_parse__single_blob_parses(void);
extern void test_object_tree_parse__single_tree_parses(void);
extern void test_object_tree_parse__leading_filename_spaces_parse(void);
extern void test_object_tree_parse__multiple_entries_parse(void);
extern void test_object_tree_parse__invalid_mode_fails(void);
extern void test_object_tree_parse__missing_mode_fails(void);
extern void test_object_tree_parse__mode_doesnt_cause_oob_read(void);
extern void test_object_tree_parse__unreasonably_large_mode_fails(void);
extern void test_object_tree_parse__missing_filename_separator_fails(void);
extern void test_object_tree_parse__missing_filename_terminator_fails(void);
extern void test_object_tree_parse__empty_filename_fails(void);
extern void test_object_tree_parse__trailing_garbage_fails(void);
extern void test_object_tree_parse__leading_space_fails(void);
extern void test_object_tree_parse__truncated_oid_fails(void);
extern void test_object_tree_read__loaded(void);
extern void test_object_tree_read__two(void);
extern void test_object_tree_read__largefile(void);
extern void test_object_tree_read__initialize(void);
extern void test_object_tree_read__cleanup(void);
extern void test_object_tree_update__remove_blob(void);
extern void test_object_tree_update__remove_blob_deeper(void);
extern void test_object_tree_update__remove_all_entries(void);
extern void test_object_tree_update__replace_blob(void);
extern void test_object_tree_update__add_blobs(void);
extern void test_object_tree_update__add_blobs_unsorted(void);
extern void test_object_tree_update__add_conflict(void);
extern void test_object_tree_update__add_conflict2(void);
extern void test_object_tree_update__remove_invalid_submodule(void);
extern void test_object_tree_update__initialize(void);
extern void test_object_tree_update__cleanup(void);
extern void test_object_tree_walk__0(void);
extern void test_object_tree_walk__1(void);
extern void test_object_tree_walk__2(void);
extern void test_object_tree_walk__initialize(void);
extern void test_object_tree_walk__cleanup(void);
extern void test_object_tree_write__from_memory(void);
extern void test_object_tree_write__subtree(void);
extern void test_object_tree_write__sorted_subtrees(void);
extern void test_object_tree_write__removing_and_re_adding_in_treebuilder(void);
extern void test_object_tree_write__filtering(void);
extern void test_object_tree_write__cruel_paths(void);
extern void test_object_tree_write__protect_filesystems(void);
extern void test_object_tree_write__object_validity(void);
extern void test_object_tree_write__invalid_null_oid(void);
extern void test_object_tree_write__initialize(void);
extern void test_object_tree_write__cleanup(void);
extern void test_object_validate__valid_sha1(void);
extern void test_object_validate__cannot_parse_sha256_as_sha1(void);
extern void test_object_validate__invalid_sha1(void);
extern void test_object_validate__valid_sha256(void);
extern void test_object_validate__invalid_sha256(void);
extern void test_object_validate__cannot_parse_sha1_as_sha256(void);
extern void test_odb_alternates__chained(void);
extern void test_odb_alternates__long_chain(void);
extern void test_odb_alternates__cleanup(void);
extern void test_odb_backend_loose__read_from_odb(void);
extern void test_odb_backend_loose__read_from_repo(void);
extern void test_odb_backend_loose__initialize(void);
extern void test_odb_backend_loose__cleanup(void);
extern void test_odb_backend_mempack__write_succeeds(void);
extern void test_odb_backend_mempack__read_of_missing_object_fails(void);
extern void test_odb_backend_mempack__exists_of_missing_object_fails(void);
extern void test_odb_backend_mempack__exists_with_existing_objects_succeeds(void);
extern void test_odb_backend_mempack__blob_create_from_buffer_succeeds(void);
extern void test_odb_backend_mempack__initialize(void);
extern void test_odb_backend_mempack__cleanup(void);
extern void test_odb_backend_multiple__read_with_empty_first_succeeds(void);
extern void test_odb_backend_multiple__read_with_first_matching_stops(void);
extern void test_odb_backend_multiple__read_prefix_with_first_empty_succeeds(void);
extern void test_odb_backend_multiple__read_prefix_with_first_matching_reads_both(void);
extern void test_odb_backend_multiple__read_prefix_with_first_matching_succeeds_without_hash_verification(void);
extern void test_odb_backend_multiple__initialize(void);
extern void test_odb_backend_multiple__cleanup(void);
extern void test_odb_backend_nobackend__write_fails_gracefully(void);
extern void test_odb_backend_nobackend__initialize(void);
extern void test_odb_backend_nobackend__cleanup(void);
extern void test_odb_backend_nonrefreshing__exists_is_invoked_once_on_failure(void);
extern void test_odb_backend_nonrefreshing__read_is_invoked_once_on_failure(void);
extern void test_odb_backend_nonrefreshing__readprefix_is_invoked_once_on_failure(void);
extern void test_odb_backend_nonrefreshing__readheader_is_invoked_once_on_failure(void);
extern void test_odb_backend_nonrefreshing__exists_is_invoked_once_on_success(void);
extern void test_odb_backend_nonrefreshing__read_is_invoked_once_on_success(void);
extern void test_odb_backend_nonrefreshing__readprefix_is_invoked_once_on_success(void);
extern void test_odb_backend_nonrefreshing__readheader_is_invoked_once_on_success(void);
extern void test_odb_backend_nonrefreshing__read_is_invoked_once_when_revparsing_a_full_oid(void);
extern void test_odb_backend_nonrefreshing__initialize(void);
extern void test_odb_backend_nonrefreshing__cleanup(void);
extern void test_odb_backend_refreshing__exists_is_invoked_twice_on_failure(void);
extern void test_odb_backend_refreshing__read_is_invoked_twice_on_failure(void);
extern void test_odb_backend_refreshing__readprefix_is_invoked_twice_on_failure(void);
extern void test_odb_backend_refreshing__readheader_is_invoked_twice_on_failure(void);
extern void test_odb_backend_refreshing__exists_is_invoked_once_on_success(void);
extern void test_odb_backend_refreshing__read_is_invoked_once_on_success(void);
extern void test_odb_backend_refreshing__readprefix_is_invoked_once_on_success(void);
extern void test_odb_backend_refreshing__readheader_is_invoked_once_on_success(void);
extern void test_odb_backend_refreshing__read_is_invoked_twice_when_revparsing_a_full_oid(void);
extern void test_odb_backend_refreshing__refresh_is_invoked(void);
extern void test_odb_backend_refreshing__refresh_suppressed_with_no_refresh(void);
extern void test_odb_backend_refreshing__initialize(void);
extern void test_odb_backend_refreshing__cleanup(void);
extern void test_odb_backend_simple__read_of_object_succeeds(void);
extern void test_odb_backend_simple__read_of_nonexisting_object_fails(void);
extern void test_odb_backend_simple__read_with_hash_mismatch_fails(void);
extern void test_odb_backend_simple__read_with_hash_mismatch_succeeds_without_verification(void);
extern void test_odb_backend_simple__read_prefix_succeeds(void);
extern void test_odb_backend_simple__read_prefix_of_nonexisting_object_fails(void);
extern void test_odb_backend_simple__read_with_ambiguous_prefix_fails(void);
extern void test_odb_backend_simple__read_with_highly_ambiguous_prefix(void);
extern void test_odb_backend_simple__exists_succeeds(void);
extern void test_odb_backend_simple__exists_fails_for_nonexisting_object(void);
extern void test_odb_backend_simple__exists_prefix_succeeds(void);
extern void test_odb_backend_simple__exists_with_ambiguous_prefix_fails(void);
extern void test_odb_backend_simple__exists_with_highly_ambiguous_prefix(void);
extern void test_odb_backend_simple__null_oid_is_ignored(void);
extern void test_odb_backend_simple__initialize(void);
extern void test_odb_backend_simple__cleanup(void);
extern void test_odb_emptyobjects__blob_notfound(void);
extern void test_odb_emptyobjects__read_tree(void);
extern void test_odb_emptyobjects__read_tree_odb(void);
extern void test_odb_emptyobjects__initialize(void);
extern void test_odb_emptyobjects__cleanup(void);
extern void test_odb_foreach__foreach(void);
extern void test_odb_foreach__one_pack(void);
extern void test_odb_foreach__interrupt_foreach(void);
extern void test_odb_foreach__files_in_objects_dir(void);
extern void test_odb_foreach__cleanup(void);
extern void test_odb_freshen__loose_blob(void);
extern void test_odb_freshen__readonly_object(void);
extern void test_odb_freshen__loose_tree(void);
extern void test_odb_freshen__tree_during_commit(void);
extern void test_odb_freshen__packed_object(void);
extern void test_odb_freshen__initialize(void);
extern void test_odb_freshen__cleanup(void);
extern void test_odb_largefiles__write_from_memory(void);
extern void test_odb_largefiles__streamwrite(void);
extern void test_odb_largefiles__streamread(void);
extern void test_odb_largefiles__read_into_memory(void);
extern void test_odb_largefiles__read_into_memory_rejected_on_32bit(void);
extern void test_odb_largefiles__read_header(void);
extern void test_odb_largefiles__initialize(void);
extern void test_odb_largefiles__cleanup(void);
extern void test_odb_loose__exists_sha1(void);
extern void test_odb_loose__exists_sha256(void);
extern void test_odb_loose__simple_reads_sha1(void);
extern void test_odb_loose__simple_reads_sha256(void);
extern void test_odb_loose__streaming_reads_sha1(void);
extern void test_odb_loose__streaming_reads_sha256(void);
extern void test_odb_loose__read_header_sha1(void);
extern void test_odb_loose__read_header_sha256(void);
extern void test_odb_loose__permissions_standard(void);
extern void test_odb_loose__permissions_readonly(void);
extern void test_odb_loose__permissions_readwrite(void);
extern void test_odb_loose__does_not_fsync_by_default(void);
extern void test_odb_loose__fsync_obeys_odb_option(void);
extern void test_odb_loose__fsync_obeys_global_setting(void);
extern void test_odb_loose__fsync_obeys_repo_setting(void);
extern void test_odb_loose__initialize(void);
extern void test_odb_loose__cleanup(void);
extern void test_odb_mixed__dup_oid(void);
extern void test_odb_mixed__dup_oid_prefix_0(void);
extern void test_odb_mixed__expand_ids(void);
extern void test_odb_mixed__expand_ids_cached(void);
extern void test_odb_mixed__initialize(void);
extern void test_odb_mixed__cleanup(void);
extern void test_odb_open__exists(void);
extern void test_odb_open__initialize(void);
extern void test_odb_open__cleanup(void);
extern void test_odb_packed__mass_read(void);
extern void test_odb_packed__read_header_0(void);
extern void test_odb_packed__read_header_1(void);
extern void test_odb_packed__initialize(void);
extern void test_odb_packed__cleanup(void);
extern void test_odb_packed256__mass_read(void);
extern void test_odb_packed256__read_header_0(void);
extern void test_odb_packed256__read_header_1(void);
extern void test_odb_packed256__initialize(void);
extern void test_odb_packed256__cleanup(void);
extern void test_odb_packedone__mass_read(void);
extern void test_odb_packedone__read_header_0(void);
extern void test_odb_packedone__initialize(void);
extern void test_odb_packedone__cleanup(void);
extern void test_odb_packedone256__mass_read(void);
extern void test_odb_packedone256__read_header_0(void);
extern void test_odb_packedone256__initialize(void);
extern void test_odb_packedone256__cleanup(void);
extern void test_odb_sorting__basic_backends_sorting(void);
extern void test_odb_sorting__alternate_backends_sorting(void);
extern void test_odb_sorting__override_default_backend_priority(void);
extern void test_odb_sorting__initialize(void);
extern void test_odb_sorting__cleanup(void);
extern void test_odb_streamwrite__can_accept_chunks(void);
extern void test_odb_streamwrite__can_detect_missing_bytes(void);
extern void test_odb_streamwrite__can_detect_additional_bytes(void);
extern void test_odb_streamwrite__initialize(void);
extern void test_odb_streamwrite__cleanup(void);
extern void test_online_badssl__expired(void);
extern void test_online_badssl__wrong_host(void);
extern void test_online_badssl__self_signed(void);
extern void test_online_badssl__old_cipher(void);
extern void test_online_clone__network_full(void);
extern void test_online_clone__network_bare(void);
extern void test_online_clone__empty_repository(void);
extern void test_online_clone__can_checkout_a_cloned_repo(void);
extern void test_online_clone__clone_mirror(void);
extern void test_online_clone__custom_remote_callbacks(void);
extern void test_online_clone__custom_headers(void);
extern void test_online_clone__long_custom_header(void);
extern void test_online_clone__cred_callback_failure_return_code_is_tunnelled(void);
extern void test_online_clone__cred_callback_called_again_on_auth_failure(void);
extern void test_online_clone__credentials(void);
extern void test_online_clone__credentials_via_custom_headers(void);
extern void test_online_clone__bitbucket_style(void);
extern void test_online_clone__bitbucket_uses_creds_in_url(void);
extern void test_online_clone__bitbucket_falls_back_to_specified_creds(void);
extern void test_online_clone__googlesource(void);
extern void test_online_clone__can_cancel(void);
extern void test_online_clone__ssh_github(void);
extern void test_online_clone__ssh_auth_methods(void);
extern void test_online_clone__ssh_certcheck_accepts_unknown(void);
extern void test_online_clone__ssh_certcheck_override_knownhosts(void);
extern void test_online_clone__ssh_with_paths(void);
extern void test_online_clone__ssh_cannot_change_username(void);
extern void test_online_clone__ssh_cert(void);
extern void test_online_clone__ssh_memory_auth(void);
extern void test_online_clone__certificate_invalid(void);
extern void test_online_clone__certificate_valid(void);
extern void test_online_clone__start_with_http(void);
extern void test_online_clone__proxy_http_host_port_in_opts(void);
extern void test_online_clone__proxy_http_host_port_in_env(void);
extern void test_online_clone__proxy_http_host_port_in_config(void);
extern void test_online_clone__proxy_invalid_url(void);
extern void test_online_clone__proxy_credentials_request(void);
extern void test_online_clone__proxy_credentials_in_well_formed_url(void);
extern void test_online_clone__proxy_credentials_in_host_port_format(void);
extern void test_online_clone__proxy_credentials_in_environment(void);
extern void test_online_clone__proxy_credentials_in_url_https(void);
extern void test_online_clone__proxy_auto_not_detected(void);
extern void test_online_clone__proxy_cred_callback_after_failed_url_creds(void);
extern void test_online_clone__azurerepos(void);
extern void test_online_clone__path_whitespace(void);
extern void test_online_clone__redirect_default_succeeds_for_initial(void);
extern void test_online_clone__redirect_default_fails_for_subsequent(void);
extern void test_online_clone__redirect_none(void);
extern void test_online_clone__redirect_initial_succeeds_for_initial(void);
extern void test_online_clone__redirect_initial_fails_for_subsequent(void);
extern void test_online_clone__namespace_bare(void);
extern void test_online_clone__namespace_with_specified_branch(void);
extern void test_online_clone__sha256(void);
extern void test_online_clone__connect_timeout_configurable(void);
extern void test_online_clone__connect_timeout_default(void);
extern void test_online_clone__timeout_configurable_times_out(void);
extern void test_online_clone__timeout_configurable_succeeds_slowly(void);
extern void test_online_clone__initialize(void);
extern void test_online_clone__cleanup(void);
extern void test_online_customcert__file(void);
extern void test_online_customcert__path(void);
extern void test_online_customcert__initialize(void);
extern void test_online_customcert__cleanup(void);
extern void test_online_fetch__default_http(void);
extern void test_online_fetch__default_https(void);
extern void test_online_fetch__no_tags_git(void);
extern void test_online_fetch__no_tags_http(void);
extern void test_online_fetch__fetch_twice(void);
extern void test_online_fetch__fetch_with_empty_http_proxy(void);
extern void test_online_fetch__doesnt_retrieve_a_pack_when_the_repository_is_up_to_date(void);
extern void test_online_fetch__report_unchanged_tips(void);
extern void test_online_fetch__can_cancel(void);
extern void test_online_fetch__ls_disconnected(void);
extern void test_online_fetch__remote_symrefs(void);
extern void test_online_fetch__twice(void);
extern void test_online_fetch__proxy(void);
extern void test_online_fetch__redirect_config(void);
extern void test_online_fetch__reachable_commit(void);
extern void test_online_fetch__reachable_commit_without_destination(void);
extern void test_online_fetch__initialize(void);
extern void test_online_fetch__cleanup(void);
extern void test_online_fetchhead__wildcard_spec(void);
extern void test_online_fetchhead__explicit_spec(void);
extern void test_online_fetchhead__no_merges(void);
extern void test_online_fetchhead__explicit_dst_refspec_creates_branch(void);
extern void test_online_fetchhead__empty_dst_refspec_creates_no_branch(void);
extern void test_online_fetchhead__colon_only_dst_refspec_creates_no_branch(void);
extern void test_online_fetchhead__creds_get_stripped(void);
extern void test_online_fetchhead__initialize(void);
extern void test_online_fetchhead__cleanup(void);
extern void test_online_push__noop(void);
extern void test_online_push__b1(void);
extern void test_online_push__b2(void);
extern void test_online_push__b3(void);
extern void test_online_push__b4(void);
extern void test_online_push__b5(void);
extern void test_online_push__b5_cancel(void);
extern void test_online_push__multi(void);
extern void test_online_push__implicit_tgt(void);
extern void test_online_push__fast_fwd(void);
extern void test_online_push__tag_commit(void);
extern void test_online_push__tag_tree(void);
extern void test_online_push__tag_blob(void);
extern void test_online_push__tag_lightweight(void);
extern void test_online_push__tag_to_tag(void);
extern void test_online_push__force(void);
extern void test_online_push__options(void);
extern void test_online_push__delete(void);
extern void test_online_push__bad_refspecs(void);
extern void test_online_push__expressions(void);
extern void test_online_push__notes(void);
extern void test_online_push__configured(void);
extern void test_online_push__initialize(void);
extern void test_online_push__cleanup(void);
extern void test_online_remotes__single_branch(void);
extern void test_online_remotes__restricted_refspecs(void);
extern void test_online_remotes__detached_remote_fails_downloading(void);
extern void test_online_remotes__detached_remote_fails_uploading(void);
extern void test_online_remotes__detached_remote_fails_pushing(void);
extern void test_online_remotes__detached_remote_succeeds_ls(void);
extern void test_online_shallow__clone_depth_zero(void);
extern void test_online_shallow__clone_depth_one(void);
extern void test_online_shallow__clone_depth_five(void);
extern void test_online_shallow__unshallow(void);
extern void test_online_shallow__deepen_six(void);
extern void test_online_shallow__shorten_four(void);
extern void test_online_shallow__preserve_unrelated_roots(void);
extern void test_pack_filelimit__open_repo_with_multiple_packfiles(void);
extern void test_pack_filelimit__initialize_tiny(void);
extern void test_pack_filelimit__initialize_medium(void);
extern void test_pack_filelimit__initialize_unlimited(void);
extern void test_pack_filelimit__cleanup(void);
extern void test_pack_indexer__out_of_order(void);
extern void test_pack_indexer__missing_trailer(void);
extern void test_pack_indexer__leaky(void);
extern void test_pack_indexer__fix_thin(void);
extern void test_pack_indexer__corrupt_length(void);
extern void test_pack_indexer__incomplete_pack_fails_with_strict(void);
extern void test_pack_indexer__out_of_order_with_connectivity_checks(void);
extern void test_pack_indexer__no_tmp_files(void);
extern void test_pack_midx__parse(void);
extern void test_pack_midx__lookup(void);
extern void test_pack_midx__writer(void);
extern void test_pack_midx__odb_create(void);
extern void test_pack_packbuilder__create_pack(void);
extern void test_pack_packbuilder__get_name(void);
extern void test_pack_packbuilder__write_default_path(void);
extern void test_pack_packbuilder__permissions_standard(void);
extern void test_pack_packbuilder__permissions_readonly(void);
extern void test_pack_packbuilder__permissions_readwrite(void);
extern void test_pack_packbuilder__does_not_fsync_by_default(void);
extern void test_pack_packbuilder__fsync_global_setting(void);
extern void test_pack_packbuilder__fsync_repo_setting(void);
extern void test_pack_packbuilder__foreach(void);
extern void test_pack_packbuilder__foreach_with_cancel(void);
extern void test_pack_packbuilder__keep_file_check(void);
extern void test_pack_packbuilder__initialize(void);
extern void test_pack_packbuilder__cleanup(void);
extern void test_pack_sharing__open_two_repos(void);
extern void test_pack_threadsafety__open_repo_in_multiple_threads(void);
extern void test_pack_threadsafety__initialize(void);
extern void test_pack_threadsafety__cleanup(void);
extern void test_patch_parse__original_to_change_middle(void);
extern void test_patch_parse__leading_and_trailing_garbage(void);
extern void test_patch_parse__nonpatches_fail_with_notfound(void);
extern void test_patch_parse__invalid_patches_fails(void);
extern void test_patch_parse__no_newline_at_end_of_new_file(void);
extern void test_patch_parse__no_newline_at_end_of_old_file(void);
extern void test_patch_parse__files_with_whitespaces_succeeds(void);
extern void test_patch_parse__lifetime_of_patch_does_not_depend_on_buffer(void);
extern void test_patch_parse__binary_file_with_missing_paths(void);
extern void test_patch_parse__binary_file_with_whitespace_paths(void);
extern void test_patch_parse__binary_file_with_empty_quoted_paths(void);
extern void test_patch_parse__binary_file_path_with_spaces(void);
extern void test_patch_parse__binary_file_path_without_body_paths(void);
extern void test_patch_parse__binary_file_with_truncated_delta(void);
extern void test_patch_parse__memory_leak_on_multiple_paths(void);
extern void test_patch_parse__truncated_no_newline_at_end_of_file(void);
extern void test_patch_parse__line_number_overflow(void);
extern void test_patch_print__change_middle(void);
extern void test_patch_print__change_middle_nocontext(void);
extern void test_patch_print__change_firstline(void);
extern void test_patch_print__change_lastline(void);
extern void test_patch_print__prepend(void);
extern void test_patch_print__prepend_nocontext(void);
extern void test_patch_print__append(void);
extern void test_patch_print__append_nocontext(void);
extern void test_patch_print__prepend_and_append(void);
extern void test_patch_print__to_empty_file(void);
extern void test_patch_print__from_empty_file(void);
extern void test_patch_print__add(void);
extern void test_patch_print__delete(void);
extern void test_patch_print__rename_exact(void);
extern void test_patch_print__rename_exact_with_mode(void);
extern void test_patch_print__rename_similar(void);
extern void test_patch_print__rename_exact_quotedname(void);
extern void test_patch_print__rename_similar_quotedname(void);
extern void test_patch_print__modechange_unchanged(void);
extern void test_patch_print__modechange_modified(void);
extern void test_patch_print__binary_literal(void);
extern void test_patch_print__binary_delta(void);
extern void test_patch_print__binary_add(void);
extern void test_patch_print__binary_delete(void);
extern void test_patch_print__not_reversible(void);
extern void test_patch_print__binary_not_shown(void);
extern void test_patch_print__binary_add_not_shown(void);
extern void test_path_validate__length(void);
extern void test_path_validate__length_with_core_longpath(void);
extern void test_path_validate__cleanup(void);
extern void test_perf_merge__m1(void);
extern void test_rebase_abort__merge(void);
extern void test_rebase_abort__merge_immediately_after_init(void);
extern void test_rebase_abort__merge_by_id(void);
extern void test_rebase_abort__merge_by_revspec(void);
extern void test_rebase_abort__merge_by_id_immediately_after_init(void);
extern void test_rebase_abort__detached_head(void);
extern void test_rebase_abort__old_style_head_file(void);
extern void test_rebase_abort__initialize(void);
extern void test_rebase_abort__cleanup(void);
extern void test_rebase_inmemory__not_in_rebase_state(void);
extern void test_rebase_inmemory__can_resolve_conflicts(void);
extern void test_rebase_inmemory__no_common_ancestor(void);
extern void test_rebase_inmemory__with_directories(void);
extern void test_rebase_inmemory__initialize(void);
extern void test_rebase_inmemory__cleanup(void);
extern void test_rebase_iterator__iterates(void);
extern void test_rebase_iterator__iterates_inmemory(void);
extern void test_rebase_iterator__initialize(void);
extern void test_rebase_iterator__cleanup(void);
extern void test_rebase_merge__next(void);
extern void test_rebase_merge__next_with_conflicts(void);
extern void test_rebase_merge__next_stops_with_iterover(void);
extern void test_rebase_merge__commit(void);
extern void test_rebase_merge__commit_with_id(void);
extern void test_rebase_merge__blocked_when_dirty(void);
extern void test_rebase_merge__commit_updates_rewritten(void);
extern void test_rebase_merge__commit_drops_already_applied(void);
extern void test_rebase_merge__finish(void);
extern void test_rebase_merge__detached_finish(void);
extern void test_rebase_merge__finish_with_ids(void);
extern void test_rebase_merge__no_common_ancestor(void);
extern void test_rebase_merge__copy_notes_off_by_default(void);
extern void test_rebase_merge__copy_notes_specified_in_options(void);
extern void test_rebase_merge__copy_notes_specified_in_config(void);
extern void test_rebase_merge__copy_notes_disabled_in_config(void);
extern void test_rebase_merge__custom_checkout_options(void);
extern void test_rebase_merge__custom_merge_options(void);
extern void test_rebase_merge__with_directories(void);
extern void test_rebase_merge__initialize(void);
extern void test_rebase_merge__cleanup(void);
extern void test_rebase_setup__blocked_when_in_progress(void);
extern void test_rebase_setup__merge(void);
extern void test_rebase_setup__merge_root(void);
extern void test_rebase_setup__merge_onto_and_upstream(void);
extern void test_rebase_setup__merge_onto_upstream_and_branch(void);
extern void test_rebase_setup__merge_onto_upstream_and_branch_by_id(void);
extern void test_rebase_setup__branch_with_merges(void);
extern void test_rebase_setup__orphan_branch(void);
extern void test_rebase_setup__merge_null_branch_uses_HEAD(void);
extern void test_rebase_setup__merge_from_detached(void);
extern void test_rebase_setup__merge_branch_by_id(void);
extern void test_rebase_setup__blocked_for_staged_change(void);
extern void test_rebase_setup__blocked_for_unstaged_change(void);
extern void test_rebase_setup__not_blocked_for_untracked_add(void);
extern void test_rebase_setup__initialize(void);
extern void test_rebase_setup__cleanup(void);
extern void test_rebase_sign__passthrough_create_cb(void);
extern void test_rebase_sign__create_gpg_signed(void);
extern void test_rebase_sign__create_propagates_error(void);
extern void test_rebase_sign__passthrough_signing_cb(void);
extern void test_rebase_sign__gpg_with_no_field(void);
extern void test_rebase_sign__custom_signature_field(void);
extern void test_rebase_sign__initialize(void);
extern void test_rebase_sign__cleanup(void);
extern void test_rebase_submodule__init_untracked(void);
extern void test_rebase_submodule__initialize(void);
extern void test_rebase_submodule__cleanup(void);
extern void test_refs_basic__reference_realloc(void);
extern void test_refs_basic__longpaths(void);
extern void test_refs_basic__initialize(void);
extern void test_refs_basic__cleanup(void);
extern void test_refs_branches_checkedout__simple_repo(void);
extern void test_refs_branches_checkedout__worktree(void);
extern void test_refs_branches_checkedout__head_is_not_checked_out(void);
extern void test_refs_branches_checkedout__master_in_bare_repo_is_not_checked_out(void);
extern void test_refs_branches_create__can_create_a_local_branch(void);
extern void test_refs_branches_create__can_not_create_a_branch_if_its_name_collide_with_an_existing_one(void);
extern void test_refs_branches_create__can_force_create_over_an_existing_branch(void);
extern void test_refs_branches_create__cannot_force_create_over_current_branch_in_nonbare_repo(void);
extern void test_refs_branches_create__can_force_create_over_current_branch_in_bare_repo(void);
extern void test_refs_branches_create__creating_a_branch_with_an_invalid_name_returns_EINVALIDSPEC(void);
extern void test_refs_branches_create__can_create_branch_with_unicode(void);
extern void test_refs_branches_create__name_vs_namespace(void);
extern void test_refs_branches_create__name_vs_namespace_fail(void);
extern void test_refs_branches_create__error_when_create_branch_with_invalid_name(void);
extern void test_refs_branches_create__initialize(void);
extern void test_refs_branches_create__cleanup(void);
extern void test_refs_branches_delete__can_not_delete_a_branch_pointed_at_by_HEAD(void);
extern void test_refs_branches_delete__can_delete_a_branch_even_if_HEAD_is_missing(void);
extern void test_refs_branches_delete__can_delete_a_branch_when_HEAD_is_unborn(void);
extern void test_refs_branches_delete__can_delete_a_branch_pointed_at_by_detached_HEAD(void);
extern void test_refs_branches_delete__can_delete_a_local_branch(void);
extern void test_refs_branches_delete__can_delete_a_local_branch_with_multivar(void);
extern void test_refs_branches_delete__can_delete_a_remote_branch(void);
extern void test_refs_branches_delete__deleting_a_branch_removes_related_configuration_data(void);
extern void test_refs_branches_delete__removes_reflog(void);
extern void test_refs_branches_delete__removes_empty_folders(void);
extern void test_refs_branches_delete__initialize(void);
extern void test_refs_branches_delete__cleanup(void);
extern void test_refs_branches_ishead__can_tell_if_a_branch_is_pointed_at_by_HEAD(void);
extern void test_refs_branches_ishead__can_properly_handle_unborn_HEAD(void);
extern void test_refs_branches_ishead__can_properly_handle_missing_HEAD(void);
extern void test_refs_branches_ishead__can_tell_if_a_branch_is_not_pointed_at_by_HEAD(void);
extern void test_refs_branches_ishead__wont_be_fooled_by_a_non_branch(void);
extern void test_refs_branches_ishead__only_direct_references_are_considered(void);
extern void test_refs_branches_ishead__initialize(void);
extern void test_refs_branches_ishead__cleanup(void);
extern void test_refs_branches_iterator__retrieve_all_branches(void);
extern void test_refs_branches_iterator__retrieve_remote_branches(void);
extern void test_refs_branches_iterator__retrieve_local_branches(void);
extern void test_refs_branches_iterator__retrieve_remote_symbolic_HEAD_when_present(void);
extern void test_refs_branches_iterator__mix_of_packed_and_loose(void);
extern void test_refs_branches_iterator__initialize(void);
extern void test_refs_branches_iterator__cleanup(void);
extern void test_refs_branches_lookup__can_retrieve_a_local_branch_local(void);
extern void test_refs_branches_lookup__can_retrieve_a_local_branch_all(void);
extern void test_refs_branches_lookup__trying_to_retrieve_a_local_branch_remote(void);
extern void test_refs_branches_lookup__can_retrieve_a_remote_tracking_branch_remote(void);
extern void test_refs_branches_lookup__can_retrieve_a_remote_tracking_branch_all(void);
extern void test_refs_branches_lookup__trying_to_retrieve_a_remote_tracking_branch_local(void);
extern void test_refs_branches_lookup__trying_to_retrieve_an_unknown_branch_returns_ENOTFOUND(void);
extern void test_refs_branches_lookup__trying_to_retrieve_a_branch_with_an_invalid_name_returns_EINVALIDSPEC(void);
extern void test_refs_branches_lookup__initialize(void);
extern void test_refs_branches_lookup__cleanup(void);
extern void test_refs_branches_move__can_move_a_local_branch(void);
extern void test_refs_branches_move__can_move_a_local_branch_to_a_different_namespace(void);
extern void test_refs_branches_move__can_move_a_local_branch_to_a_partially_colliding_namespace(void);
extern void test_refs_branches_move__can_not_move_a_branch_if_its_destination_name_collide_with_an_existing_one(void);
extern void test_refs_branches_move__moving_a_branch_with_an_invalid_name_returns_EINVALIDSPEC(void);
extern void test_refs_branches_move__can_not_move_a_non_branch(void);
extern void test_refs_branches_move__can_force_move_over_an_existing_branch(void);
extern void test_refs_branches_move__moving_a_branch_moves_related_configuration_data(void);
extern void test_refs_branches_move__moving_the_branch_pointed_at_by_HEAD_updates_HEAD(void);
extern void test_refs_branches_move__can_move_with_unicode(void);
extern void test_refs_branches_move__moves_reflog_correctly(void);
extern void test_refs_branches_move__failed_move_restores_reflog(void);
extern void test_refs_branches_move__initialize(void);
extern void test_refs_branches_move__cleanup(void);
extern void test_refs_branches_name__can_get_local_branch_name(void);
extern void test_refs_branches_name__can_get_remote_branch_name(void);
extern void test_refs_branches_name__error_when_ref_is_no_branch(void);
extern void test_refs_branches_name__is_name_valid(void);
extern void test_refs_branches_name__initialize(void);
extern void test_refs_branches_name__cleanup(void);
extern void test_refs_branches_remote__can_get_remote_for_branch(void);
extern void test_refs_branches_remote__no_matching_remote_returns_error(void);
extern void test_refs_branches_remote__local_remote_returns_error(void);
extern void test_refs_branches_remote__ambiguous_remote_returns_error(void);
extern void test_refs_branches_remote__initialize(void);
extern void test_refs_branches_remote__cleanup(void);
extern void test_refs_branches_upstream__can_retrieve_the_remote_tracking_reference_of_a_local_branch(void);
extern void test_refs_branches_upstream__can_retrieve_the_local_upstream_reference_of_a_local_branch(void);
extern void test_refs_branches_upstream__cannot_retrieve_a_remote_upstream_reference_from_a_non_branch(void);
extern void test_refs_branches_upstream__trying_to_retrieve_a_remote_tracking_reference_from_a_plain_local_branch_returns_GIT_ENOTFOUND(void);
extern void test_refs_branches_upstream__trying_to_retrieve_a_remote_tracking_reference_from_a_branch_with_no_fetchspec_returns_GIT_ENOTFOUND(void);
extern void test_refs_branches_upstream__upstream_remote(void);
extern void test_refs_branches_upstream__upstream_merge(void);
extern void test_refs_branches_upstream__upstream_remote_empty_value(void);
extern void test_refs_branches_upstream__retrieve_a_remote_tracking_reference_from_a_branch_with_no_remote_returns_GIT_ENOTFOUND(void);
extern void test_refs_branches_upstream__set_unset_upstream(void);
extern void test_refs_branches_upstream__no_fetch_refspec(void);
extern void test_refs_branches_upstream__initialize(void);
extern void test_refs_branches_upstream__cleanup(void);
extern void test_refs_branches_upstreamname__can_retrieve_the_remote_tracking_reference_name_of_a_local_branch(void);
extern void test_refs_branches_upstreamname__can_retrieve_the_local_upstream_reference_name_of_a_local_branch(void);
extern void test_refs_branches_upstreamname__initialize(void);
extern void test_refs_branches_upstreamname__cleanup(void);
extern void test_refs_crashes__double_free(void);
extern void test_refs_crashes__empty_packedrefs(void);
extern void test_refs_create__symbolic(void);
extern void test_refs_create__symbolic_with_arbitrary_content(void);
extern void test_refs_create__deep_symbolic(void);
extern void test_refs_create__oid(void);
extern void test_refs_create__oid_unknown_succeeds_without_strict(void);
extern void test_refs_create__oid_unknown_fails_by_default(void);
extern void test_refs_create__propagate_eexists(void);
extern void test_refs_create__existing_dir_propagates_edirectory(void);
extern void test_refs_create__creating_a_reference_with_an_invalid_name_returns_EINVALIDSPEC(void);
extern void test_refs_create__creating_a_loose_ref_with_invalid_windows_name(void);
extern void test_refs_create__does_not_fsync_by_default(void);
extern void test_refs_create__fsyncs_when_global_opt_set(void);
extern void test_refs_create__fsyncs_when_repo_config_set(void);
extern void test_refs_create__initialize(void);
extern void test_refs_create__cleanup(void);
extern void test_refs_delete__packed_loose(void);
extern void test_refs_delete__packed_only(void);
extern void test_refs_delete__remove(void);
extern void test_refs_delete__head(void);
extern void test_refs_delete__initialize(void);
extern void test_refs_delete__cleanup(void);
extern void test_refs_dup__direct(void);
extern void test_refs_dup__symbolic(void);
extern void test_refs_dup__initialize(void);
extern void test_refs_dup__cleanup(void);
extern void test_refs_foreachglob__retrieve_all_refs(void);
extern void test_refs_foreachglob__retrieve_remote_branches(void);
extern void test_refs_foreachglob__retrieve_local_branches(void);
extern void test_refs_foreachglob__retrieve_nonexistant(void);
extern void test_refs_foreachglob__retrieve_partially_named_references(void);
extern void test_refs_foreachglob__can_cancel(void);
extern void test_refs_foreachglob__initialize(void);
extern void test_refs_foreachglob__cleanup(void);
extern void test_refs_isvalidname__can_detect_invalid_formats(void);
extern void test_refs_isvalidname__wont_hopefully_choke_on_valid_formats(void);
extern void test_refs_iterator__list(void);
extern void test_refs_iterator__empty(void);
extern void test_refs_iterator__foreach(void);
extern void test_refs_iterator__foreach_through_symlink(void);
extern void test_refs_iterator__foreach_can_cancel(void);
extern void test_refs_iterator__foreach_name(void);
extern void test_refs_iterator__foreach_name_can_cancel(void);
extern void test_refs_iterator__concurrent_delete(void);
extern void test_refs_iterator__initialize(void);
extern void test_refs_iterator__cleanup(void);
extern void test_refs_list__all(void);
extern void test_refs_list__do_not_retrieve_references_which_name_end_with_a_lock_extension(void);
extern void test_refs_list__initialize(void);
extern void test_refs_list__cleanup(void);
extern void test_refs_listall__from_repository_opened_through_workdir_path(void);
extern void test_refs_listall__from_repository_opened_through_gitdir_path(void);
extern void test_refs_listall__from_repository_with_no_trailing_newline(void);
extern void test_refs_lookup__with_resolve(void);
extern void test_refs_lookup__invalid_name(void);
extern void test_refs_lookup__oid(void);
extern void test_refs_lookup__namespace(void);
extern void test_refs_lookup__dwim_notfound(void);
extern void test_refs_lookup__initialize(void);
extern void test_refs_lookup__cleanup(void);
extern void test_refs_namespaces__get_and_set(void);
extern void test_refs_namespaces__namespace_doesnt_show_normal_refs(void);
extern void test_refs_namespaces__initialize(void);
extern void test_refs_namespaces__cleanup(void);
extern void test_refs_normalize__can_normalize_a_direct_reference_name(void);
extern void test_refs_normalize__cannot_normalize_any_direct_reference_name(void);
extern void test_refs_normalize__symbolic(void);
extern void test_refs_normalize__jgit_suite(void);
extern void test_refs_normalize__buffer_has_to_be_big_enough_to_hold_the_normalized_version(void);
extern void test_refs_normalize__refspec_pattern(void);
extern void test_refs_overwrite__symbolic(void);
extern void test_refs_overwrite__object_id(void);
extern void test_refs_overwrite__object_id_with_symbolic(void);
extern void test_refs_overwrite__symbolic_with_object_id(void);
extern void test_refs_overwrite__initialize(void);
extern void test_refs_overwrite__cleanup(void);
extern void test_refs_pack__empty(void);
extern void test_refs_pack__loose(void);
extern void test_refs_pack__symbolic(void);
extern void test_refs_pack__initialize(void);
extern void test_refs_pack__cleanup(void);
extern void test_refs_peel__can_peel_a_tag(void);
extern void test_refs_peel__can_peel_a_branch(void);
extern void test_refs_peel__can_peel_a_symbolic_reference(void);
extern void test_refs_peel__cannot_peel_into_a_non_existing_target(void);
extern void test_refs_peel__can_peel_into_any_non_tag_object(void);
extern void test_refs_peel__can_peel_fully_peeled_packed_refs(void);
extern void test_refs_peel__can_peel_fully_peeled_tag_to_tag(void);
extern void test_refs_peel__initialize(void);
extern void test_refs_peel__cleanup(void);
extern void test_refs_races__create_matching_zero_old(void);
extern void test_refs_races__create_matching(void);
extern void test_refs_races__symbolic_create_matching(void);
extern void test_refs_races__delete(void);
extern void test_refs_races__switch_oid_to_symbolic(void);
extern void test_refs_races__switch_symbolic_to_oid(void);
extern void test_refs_races__initialize(void);
extern void test_refs_races__cleanup(void);
extern void test_refs_read__loose_tag(void);
extern void test_refs_read__nonexisting_tag(void);
extern void test_refs_read__symbolic(void);
extern void test_refs_read__nested_symbolic(void);
extern void test_refs_read__head_then_master(void);
extern void test_refs_read__master_then_head(void);
extern void test_refs_read__packed(void);
extern void test_refs_read__loose_first(void);
extern void test_refs_read__chomped(void);
extern void test_refs_read__trailing(void);
extern void test_refs_read__unfound_return_ENOTFOUND(void);
extern void test_refs_read__can_determine_if_a_reference_is_a_local_branch(void);
extern void test_refs_read__can_determine_if_a_reference_is_a_tag(void);
extern void test_refs_read__can_determine_if_a_reference_is_a_note(void);
extern void test_refs_read__invalid_name_returns_EINVALIDSPEC(void);
extern void test_refs_read__initialize(void);
extern void test_refs_read__cleanup(void);
extern void test_refs_reflog_drop__dropping_a_non_exisiting_entry_from_the_log_returns_ENOTFOUND(void);
extern void test_refs_reflog_drop__can_drop_an_entry(void);
extern void test_refs_reflog_drop__can_drop_an_entry_and_rewrite_the_log_history(void);
extern void test_refs_reflog_drop__can_drop_the_oldest_entry(void);
extern void test_refs_reflog_drop__can_drop_the_oldest_entry_and_rewrite_the_log_history(void);
extern void test_refs_reflog_drop__can_drop_all_the_entries(void);
extern void test_refs_reflog_drop__can_persist_deletion_on_disk(void);
extern void test_refs_reflog_drop__initialize(void);
extern void test_refs_reflog_drop__cleanup(void);
extern void test_refs_reflog_messages__setting_head_updates_reflog(void);
extern void test_refs_reflog_messages__setting_head_to_same_target_ignores_reflog(void);
extern void test_refs_reflog_messages__detaching_writes_reflog(void);
extern void test_refs_reflog_messages__orphan_branch_does_not_count(void);
extern void test_refs_reflog_messages__branch_birth(void);
extern void test_refs_reflog_messages__commit_on_symbolic_ref_updates_head_reflog(void);
extern void test_refs_reflog_messages__show_merge_for_merge_commits(void);
extern void test_refs_reflog_messages__creating_a_direct_reference(void);
extern void test_refs_reflog_messages__newline_gets_replaced(void);
extern void test_refs_reflog_messages__renaming_ref(void);
extern void test_refs_reflog_messages__updating_a_direct_reference(void);
extern void test_refs_reflog_messages__creating_branches_default_messages(void);
extern void test_refs_reflog_messages__moving_branch_default_message(void);
extern void test_refs_reflog_messages__detaching_head_default_message(void);
extern void test_refs_reflog_messages__initialize(void);
extern void test_refs_reflog_messages__cleanup(void);
extern void test_refs_reflog_reflog__append_then_read(void);
extern void test_refs_reflog_reflog__renaming_the_reference_moves_the_reflog(void);
extern void test_refs_reflog_reflog__deleting_the_reference_deletes_the_reflog(void);
extern void test_refs_reflog_reflog__removes_empty_reflog_dir(void);
extern void test_refs_reflog_reflog__fails_gracefully_on_nonempty_reflog_dir(void);
extern void test_refs_reflog_reflog__reference_has_reflog(void);
extern void test_refs_reflog_reflog__reading_the_reflog_from_a_reference_with_no_log_returns_an_empty_one(void);
extern void test_refs_reflog_reflog__reading_a_reflog_with_invalid_format_succeeds(void);
extern void test_refs_reflog_reflog__cannot_write_a_moved_reflog(void);
extern void test_refs_reflog_reflog__renaming_with_an_invalid_name_returns_EINVALIDSPEC(void);
extern void test_refs_reflog_reflog__write_only_std_locations(void);
extern void test_refs_reflog_reflog__write_when_explicitly_active(void);
extern void test_refs_reflog_reflog__append_to_HEAD_when_changing_current_branch(void);
extern void test_refs_reflog_reflog__do_not_append_when_no_update(void);
extern void test_refs_reflog_reflog__logallrefupdates_bare_set_false(void);
extern void test_refs_reflog_reflog__logallrefupdates_bare_set_always(void);
extern void test_refs_reflog_reflog__logallrefupdates_bare_unset(void);
extern void test_refs_reflog_reflog__logallrefupdates_nonbare_set_false(void);
extern void test_refs_reflog_reflog__initialize(void);
extern void test_refs_reflog_reflog__cleanup(void);
extern void test_refs_rename__loose(void);
extern void test_refs_rename__packed(void);
extern void test_refs_rename__packed_doesnt_pack_others(void);
extern void test_refs_rename__name_collision(void);
extern void test_refs_rename__invalid_name(void);
extern void test_refs_rename__force_loose_packed(void);
extern void test_refs_rename__force_loose(void);
extern void test_refs_rename__overwrite(void);
extern void test_refs_rename__prefix(void);
extern void test_refs_rename__move_up(void);
extern void test_refs_rename__propagate_eexists(void);
extern void test_refs_rename__initialize(void);
extern void test_refs_rename__cleanup(void);
extern void test_refs_revparse__nonexistant_object(void);
extern void test_refs_revparse__invalid_reference_name(void);
extern void test_refs_revparse__shas(void);
extern void test_refs_revparse__head(void);
extern void test_refs_revparse__full_refs(void);
extern void test_refs_revparse__partial_refs(void);
extern void test_refs_revparse__describe_output(void);
extern void test_refs_revparse__nth_parent(void);
extern void test_refs_revparse__not_tag(void);
extern void test_refs_revparse__to_type(void);
extern void test_refs_revparse__linear_history(void);
extern void test_refs_revparse__chaining(void);
extern void test_refs_revparse__upstream(void);
extern void test_refs_revparse__ordinal(void);
extern void test_refs_revparse__previous_head(void);
extern void test_refs_revparse__reflog_of_a_ref_under_refs(void);
extern void test_refs_revparse__revwalk(void);
extern void test_refs_revparse__date(void);
extern void test_refs_revparse__invalid_date(void);
extern void test_refs_revparse__colon(void);
extern void test_refs_revparse__disambiguation(void);
extern void test_refs_revparse__a_too_short_objectid_returns_EAMBIGUOUS(void);
extern void test_refs_revparse__a_not_precise_enough_objectid_returns_EAMBIGUOUS(void);
extern void test_refs_revparse__issue_994(void);
extern void test_refs_revparse__try_to_retrieve_branch_before_described_tag(void);
extern void test_refs_revparse__try_to_retrieve_sha_before_branch(void);
extern void test_refs_revparse__try_to_retrieve_branch_before_abbrev_sha(void);
extern void test_refs_revparse__at_at_end_of_refname(void);
extern void test_refs_revparse__range(void);
extern void test_refs_revparse__parses_range_operator(void);
extern void test_refs_revparse__ext_retrieves_both_the_reference_and_its_target(void);
extern void test_refs_revparse__ext_can_expand_short_reference_names(void);
extern void test_refs_revparse__ext_returns_NULL_reference_when_expression_points_at_a_revision(void);
extern void test_refs_revparse__ext_returns_NULL_reference_when_expression_points_at_a_tree_content(void);
extern void test_refs_revparse__uneven_sizes(void);
extern void test_refs_revparse__parses_at_head(void);
extern void test_refs_revparse__initialize(void);
extern void test_refs_revparse__cleanup(void);
extern void test_refs_setter__update_direct(void);
extern void test_refs_setter__update_symbolic(void);
extern void test_refs_setter__cant_update_direct_with_symbolic(void);
extern void test_refs_setter__cant_update_symbolic_with_direct(void);
extern void test_refs_setter__initialize(void);
extern void test_refs_setter__cleanup(void);
extern void test_refs_shorthand__0(void);
extern void test_refs_tags_name__is_name_valid(void);
extern void test_refs_transactions__single_ref_oid(void);
extern void test_refs_transactions__single_ref_symbolic(void);
extern void test_refs_transactions__single_ref_mix_types(void);
extern void test_refs_transactions__single_ref_delete(void);
extern void test_refs_transactions__single_create(void);
extern void test_refs_transactions__unlocked_set(void);
extern void test_refs_transactions__error_on_locking_locked_ref(void);
extern void test_refs_transactions__commit_unlocks_unmodified_ref(void);
extern void test_refs_transactions__free_unlocks_unmodified_ref(void);
extern void test_refs_transactions__initialize(void);
extern void test_refs_transactions__cleanup(void);
extern void test_refs_unicode__create_and_lookup(void);
extern void test_refs_unicode__initialize(void);
extern void test_refs_unicode__cleanup(void);
extern void test_refs_update__updating_the_target_of_a_symref_with_an_invalid_name_returns_EINVALIDSPEC(void);
extern void test_refs_update__initialize(void);
extern void test_refs_update__cleanup(void);
extern void test_remote_create__manual(void);
extern void test_remote_create__named(void);
extern void test_remote_create__named_fail_on_invalid_name(void);
extern void test_remote_create__named_fail_on_invalid_url(void);
extern void test_remote_create__named_fail_on_conflicting_name(void);
extern void test_remote_create__with_fetchspec(void);
extern void test_remote_create__with_empty_fetchspec(void);
extern void test_remote_create__with_fetchspec_invalid_name(void);
extern void test_remote_create__with_fetchspec_invalid_url(void);
extern void test_remote_create__anonymous(void);
extern void test_remote_create__anonymous_invalid_url(void);
extern void test_remote_create__detached(void);
extern void test_remote_create__detached_invalid_url(void);
extern void test_remote_create__with_opts_named(void);
extern void test_remote_create__with_opts_named_and_fetchspec(void);
extern void test_remote_create__with_opts_named_no_fetchspec(void);
extern void test_remote_create__with_opts_anonymous(void);
extern void test_remote_create__with_opts_detached(void);
extern void test_remote_create__with_opts_insteadof_disabled(void);
extern void test_remote_create__with_opts_invalid_name(void);
extern void test_remote_create__with_opts_conflicting_name(void);
extern void test_remote_create__with_opts_invalid_url(void);
extern void test_remote_create__initialize(void);
extern void test_remote_create__cleanup(void);
extern void test_remote_fetch__dont_update_refs_if_not_descendant_and_not_force(void);
extern void test_remote_fetch__do_update_refs_if_not_descendant_and_force(void);
extern void test_remote_fetch__initialize(void);
extern void test_remote_fetch__cleanup(void);
extern void test_remote_httpproxy__config_overrides(void);
extern void test_remote_httpproxy__config_empty_overrides(void);
extern void test_remote_httpproxy__config_overrides_detached_remote(void);
extern void test_remote_httpproxy__env(void);
extern void test_remote_httpproxy__initialize(void);
extern void test_remote_httpproxy__cleanup(void);
extern void test_remote_insteadof__not_applicable(void);
extern void test_remote_insteadof__url_insteadof_fetch(void);
extern void test_remote_insteadof__url_insteadof_push(void);
extern void test_remote_insteadof__url_insteadof_both(void);
extern void test_remote_insteadof__pushurl_insteadof_fetch(void);
extern void test_remote_insteadof__pushurl_insteadof_push(void);
extern void test_remote_insteadof__pushurl_insteadof_both(void);
extern void test_remote_insteadof__anonymous_remote_fetch(void);
extern void test_remote_insteadof__anonymous_remote_push(void);
extern void test_remote_insteadof__anonymous_remote_both(void);
extern void test_remote_insteadof__initialize(void);
extern void test_remote_insteadof__cleanup(void);
extern void test_remote_list__always_checks_disk_config(void);
extern void test_remote_list__initialize(void);
extern void test_remote_list__cleanup(void);
extern void test_repo_config__can_open_global_when_there_is_no_file(void);
extern void test_repo_config__can_open_missing_global_with_separators(void);
extern void test_repo_config__read_with_no_configs_at_all(void);
extern void test_repo_config__initialize(void);
extern void test_repo_config__cleanup(void);
extern void test_repo_discover__discovering_repo_with_exact_path_succeeds(void);
extern void test_repo_discover__discovering_nonexistent_dir_fails(void);
extern void test_repo_discover__discovering_repo_with_subdirectory_succeeds(void);
extern void test_repo_discover__discovering_repository_with_alternative_gitdir_succeeds(void);
extern void test_repo_discover__discovering_repository_with_malformed_alternative_gitdir_fails(void);
extern void test_repo_discover__discovering_repository_with_ceiling(void);
extern void test_repo_discover__other_ceiling(void);
extern void test_repo_discover__ceiling_should_not_affect_gitdir_redirection(void);
extern void test_repo_discover__discovery_starting_at_file_succeeds(void);
extern void test_repo_discover__discovery_starting_at_system_root_causes_no_hang(void);
extern void test_repo_discover__initialize(void);
extern void test_repo_discover__cleanup(void);
extern void test_repo_env__open(void);
extern void test_repo_env__work_tree(void);
extern void test_repo_env__commondir(void);
extern void test_repo_env__config(void);
extern void test_repo_env__initialize(void);
extern void test_repo_env__cleanup(void);
extern void test_repo_extensions__builtin(void);
extern void test_repo_extensions__negate_builtin(void);
extern void test_repo_extensions__unsupported(void);
extern void test_repo_extensions__adds_extension(void);
extern void test_repo_extensions__initialize(void);
extern void test_repo_extensions__cleanup(void);
extern void test_repo_getters__is_empty_correctly_deals_with_pristine_looking_repos(void);
extern void test_repo_getters__is_empty_can_detect_used_repositories(void);
extern void test_repo_getters__is_empty_can_detect_repositories_with_defaultbranch_config_empty(void);
extern void test_repo_getters__retrieving_the_odb_honors_the_refcount(void);
extern void test_repo_getters__commit_parents(void);
extern void test_repo_hashfile__simple(void);
extern void test_repo_hashfile__filtered_in_workdir(void);
extern void test_repo_hashfile__filtered_outside_workdir(void);
extern void test_repo_hashfile__initialize(void);
extern void test_repo_hashfile__cleanup(void);
extern void test_repo_head__unborn_head(void);
extern void test_repo_head__set_head_Attaches_HEAD_to_un_unborn_branch_when_the_branch_doesnt_exist(void);
extern void test_repo_head__set_head_Returns_ENOTFOUND_when_the_reference_doesnt_exist(void);
extern void test_repo_head__set_head_Fails_when_the_reference_points_to_a_non_commitish(void);
extern void test_repo_head__set_head_Attaches_HEAD_when_the_reference_points_to_a_branch(void);
extern void test_repo_head__set_head_Detaches_HEAD_when_the_reference_doesnt_point_to_a_branch(void);
extern void test_repo_head__set_head_detached_Return_ENOTFOUND_when_the_object_doesnt_exist(void);
extern void test_repo_head__set_head_detached_Fails_when_the_object_isnt_a_commitish(void);
extern void test_repo_head__set_head_detached_Detaches_HEAD_and_make_it_point_to_the_peeled_commit(void);
extern void test_repo_head__detach_head_Detaches_HEAD_and_make_it_point_to_the_peeled_commit(void);
extern void test_repo_head__detach_head_Fails_if_HEAD_and_point_to_a_non_commitish(void);
extern void test_repo_head__detaching_an_unborn_branch_returns_GIT_EUNBORNBRANCH(void);
extern void test_repo_head__retrieving_an_unborn_branch_returns_GIT_EUNBORNBRANCH(void);
extern void test_repo_head__retrieving_a_missing_head_returns_GIT_ENOTFOUND(void);
extern void test_repo_head__can_tell_if_an_unborn_head_is_detached(void);
extern void test_repo_head__initialize(void);
extern void test_repo_head__cleanup(void);
extern void test_repo_headtree__can_retrieve_the_root_tree_from_a_detached_head(void);
extern void test_repo_headtree__can_retrieve_the_root_tree_from_a_non_detached_head(void);
extern void test_repo_headtree__when_head_is_unborn_returns_EUNBORNBRANCH(void);
extern void test_repo_headtree__when_head_is_missing_returns_ENOTFOUND(void);
extern void test_repo_headtree__initialize(void);
extern void test_repo_headtree__cleanup(void);
extern void test_repo_init__standard_repo(void);
extern void test_repo_init__standard_repo_noslash(void);
extern void test_repo_init__bare_repo(void);
extern void test_repo_init__bare_repo_noslash(void);
extern void test_repo_init__bare_repo_escaping_current_workdir(void);
extern void test_repo_init__reinit_bare_repo(void);
extern void test_repo_init__reinit_nondefault_version(void);
extern void test_repo_init__reinit_unsupported_version(void);
extern void test_repo_init__additional_templates(void);
extern void test_repo_init__detect_filemode(void);
extern void test_repo_init__detect_ignorecase(void);
extern void test_repo_init__symlinks_win32_enabled_by_global_config(void);
extern void test_repo_init__symlinks_win32_off_by_default(void);
extern void test_repo_init__symlinks_posix_detected(void);
extern void test_repo_init__detect_precompose_unicode_required(void);
extern void test_repo_init__reinit_doesnot_overwrite_ignorecase(void);
extern void test_repo_init__reinit_overwrites_filemode(void);
extern void test_repo_init__sets_logAllRefUpdates_according_to_type_of_repository(void);
extern void test_repo_init__extended_0(void);
extern void test_repo_init__extended_1(void);
extern void test_repo_init__relative_gitdir(void);
extern void test_repo_init__relative_gitdir_2(void);
extern void test_repo_init__can_reinit_an_initialized_repository(void);
extern void test_repo_init__init_with_initial_commit(void);
extern void test_repo_init__at_filesystem_root(void);
extern void test_repo_init__nonexisting_directory(void);
extern void test_repo_init__nonexisting_root(void);
extern void test_repo_init__unwriteable_directory(void);
extern void test_repo_init__defaultbranch_config(void);
extern void test_repo_init__defaultbranch_config_empty(void);
extern void test_repo_init__longpath(void);
extern void test_repo_init__absolute_path_with_backslashes(void);
extern void test_repo_init__initialize(void);
extern void test_repo_init__cleanup(void);
extern void test_repo_message__none(void);
extern void test_repo_message__message(void);
extern void test_repo_message__initialize(void);
extern void test_repo_message__cleanup(void);
extern void test_repo_new__has_nothing(void);
extern void test_repo_new__is_bare_until_workdir_set(void);
extern void test_repo_new__sha1(void);
extern void test_repo_new__sha256(void);
extern void test_repo_objectformat__unspecified(void);
extern void test_repo_objectformat__sha1(void);
extern void test_repo_objectformat__sha256(void);
extern void test_repo_objectformat__invalid(void);
extern void test_repo_objectformat__initialize(void);
extern void test_repo_objectformat__cleanup(void);
extern void test_repo_open__bare_empty_repo(void);
extern void test_repo_open__format_version_1(void);
extern void test_repo_open__standard_empty_repo_through_gitdir(void);
extern void test_repo_open__standard_empty_repo_through_workdir(void);
extern void test_repo_open__open_with_discover(void);
extern void test_repo_open__check_if_repository(void);
extern void test_repo_open__gitlinked(void);
extern void test_repo_open__with_symlinked_config(void);
extern void test_repo_open__from_git_new_workdir(void);
extern void test_repo_open__failures(void);
extern void test_repo_open__bad_gitlinks(void);
extern void test_repo_open__win32_path(void);
extern void test_repo_open__opening_a_non_existing_repository_returns_ENOTFOUND(void);
extern void test_repo_open__no_config(void);
extern void test_repo_open__force_bare(void);
extern void test_repo_open__validates_dir_ownership(void);
extern void test_repo_open__validates_bare_repo_ownership(void);
extern void test_repo_open__can_allowlist_dirs_with_problematic_ownership(void);
extern void test_repo_open__safe_directory_fails_with_trailing_slash(void);
extern void test_repo_open__can_wildcard_allowlist_with_problematic_ownership(void);
extern void test_repo_open__can_allowlist_bare_gitdir(void);
extern void test_repo_open__can_wildcard_allowlist_bare_gitdir(void);
extern void test_repo_open__can_handle_prefixed_safe_paths(void);
extern void test_repo_open__prefixed_safe_paths_must_have_two_slashes(void);
extern void test_repo_open__can_handle_win32_prefixed_safe_paths(void);
extern void test_repo_open__can_handle_win32_unc_safe_paths(void);
extern void test_repo_open__can_reset_safe_directory_list(void);
extern void test_repo_open__initialize(void);
extern void test_repo_open__cleanup(void);
extern void test_repo_pathspec__workdir0(void);
extern void test_repo_pathspec__workdir1(void);
extern void test_repo_pathspec__workdir2(void);
extern void test_repo_pathspec__workdir3(void);
extern void test_repo_pathspec__workdir4(void);
extern void test_repo_pathspec__index0(void);
extern void test_repo_pathspec__index1(void);
extern void test_repo_pathspec__tree0(void);
extern void test_repo_pathspec__tree5(void);
extern void test_repo_pathspec__in_memory(void);
extern void test_repo_pathspec__initialize(void);
extern void test_repo_pathspec__cleanup(void);
extern void test_repo_reservedname__includes_shortname_on_win32(void);
extern void test_repo_reservedname__includes_shortname_when_requested(void);
extern void test_repo_reservedname__custom_shortname_recognized(void);
extern void test_repo_reservedname__submodule_pointer(void);
extern void test_repo_reservedname__submodule_pointer_during_create(void);
extern void test_repo_reservedname__cleanup(void);
extern void test_repo_setters__setting_a_workdir_turns_a_bare_repository_into_a_standard_one(void);
extern void test_repo_setters__setting_a_workdir_prettifies_its_path(void);
extern void test_repo_setters__setting_a_workdir_creates_a_gitlink(void);
extern void test_repo_setters__setting_a_new_index_on_a_repo_which_has_already_loaded_one_properly_honors_the_refcount(void);
extern void test_repo_setters__setting_a_new_odb_on_a_repo_which_already_loaded_one_properly_honors_the_refcount(void);
extern void test_repo_setters__initialize(void);
extern void test_repo_setters__cleanup(void);
extern void test_repo_shallow__no_shallow_file(void);
extern void test_repo_shallow__empty_shallow_file(void);
extern void test_repo_shallow__shallow_repo(void);
extern void test_repo_shallow__clears_errors(void);
extern void test_repo_shallow__initialize(void);
extern void test_repo_shallow__cleanup(void);
extern void test_repo_state__none_with_HEAD_attached(void);
extern void test_repo_state__none_with_HEAD_detached(void);
extern void test_repo_state__merge(void);
extern void test_repo_state__revert(void);
extern void test_repo_state__revert_sequence(void);
extern void test_repo_state__cherry_pick(void);
extern void test_repo_state__cherrypick_sequence(void);
extern void test_repo_state__bisect(void);
extern void test_repo_state__rebase_interactive(void);
extern void test_repo_state__rebase_merge(void);
extern void test_repo_state__rebase(void);
extern void test_repo_state__apply_mailbox(void);
extern void test_repo_state__apply_mailbox_or_rebase(void);
extern void test_repo_state__initialize(void);
extern void test_repo_state__cleanup(void);
extern void test_repo_template__external_templates_specified_in_options(void);
extern void test_repo_template__external_templates_specified_in_config(void);
extern void test_repo_template__external_templates_with_leading_dot(void);
extern void test_repo_template__extended_with_template_and_shared_mode(void);
extern void test_repo_template__templated_head_is_used(void);
extern void test_repo_template__initial_head_option_overrides_template_head(void);
extern void test_repo_template__empty_template_path(void);
extern void test_repo_template__nonexistent_template_path(void);
extern void test_repo_template__initialize(void);
extern void test_repo_template__cleanup(void);
extern void test_reset_default__resetting_filepaths_against_a_null_target_removes_them_from_the_index(void);
extern void test_reset_default__resetting_filepaths_replaces_their_corresponding_index_entries(void);
extern void test_reset_default__resetting_filepaths_clears_previous_conflicts(void);
extern void test_reset_default__resetting_unknown_filepaths_does_not_fail(void);
extern void test_reset_default__staged_rename_reset_delete(void);
extern void test_reset_default__initialize(void);
extern void test_reset_default__cleanup(void);
extern void test_reset_hard__resetting_reverts_modified_files(void);
extern void test_reset_hard__cannot_reset_in_a_bare_repository(void);
extern void test_reset_hard__resetting_reverts_unmerged(void);
extern void test_reset_hard__cleans_up_merge(void);
extern void test_reset_hard__reflog_is_correct(void);
extern void test_reset_hard__switch_file_to_dir(void);
extern void test_reset_hard__initialize(void);
extern void test_reset_hard__cleanup(void);
extern void test_reset_mixed__cannot_reset_in_a_bare_repository(void);
extern void test_reset_mixed__resetting_refreshes_the_index_to_the_commit_tree(void);
extern void test_reset_mixed__reflog_is_correct(void);
extern void test_reset_mixed__initialize(void);
extern void test_reset_mixed__cleanup(void);
extern void test_reset_soft__can_reset_the_non_detached_Head_to_the_specified_commit(void);
extern void test_reset_soft__can_reset_the_detached_Head_to_the_specified_commit(void);
extern void test_reset_soft__resetting_to_the_commit_pointed_at_by_the_Head_does_not_change_the_target_of_the_Head(void);
extern void test_reset_soft__resetting_to_a_tag_sets_the_Head_to_the_peeled_commit(void);
extern void test_reset_soft__cannot_reset_to_a_tag_not_pointing_at_a_commit(void);
extern void test_reset_soft__resetting_against_an_unborn_head_repo_makes_the_head_no_longer_unborn(void);
extern void test_reset_soft__fails_when_merging(void);
extern void test_reset_soft__fails_when_index_contains_conflicts_independently_of_MERGE_HEAD_file_existence(void);
extern void test_reset_soft__reflog_is_correct(void);
extern void test_reset_soft__initialize(void);
extern void test_reset_soft__cleanup(void);
extern void test_revert_bare__automerge(void);
extern void test_revert_bare__conflicts(void);
extern void test_revert_bare__orphan(void);
extern void test_revert_bare__initialize(void);
extern void test_revert_bare__cleanup(void);
extern void test_revert_rename__automerge(void);
extern void test_revert_rename__initialize(void);
extern void test_revert_rename__cleanup(void);
extern void test_revert_workdir__automerge(void);
extern void test_revert_workdir__conflicts(void);
extern void test_revert_workdir__orphan(void);
extern void test_revert_workdir__again(void);
extern void test_revert_workdir__again_after_automerge(void);
extern void test_revert_workdir__again_after_edit(void);
extern void test_revert_workdir__again_after_edit_two(void);
extern void test_revert_workdir__conflict_use_ours(void);
extern void test_revert_workdir__rename_1_of_2(void);
extern void test_revert_workdir__rename(void);
extern void test_revert_workdir__head(void);
extern void test_revert_workdir__nonmerge_fails_mainline_specified(void);
extern void test_revert_workdir__merge_fails_without_mainline_specified(void);
extern void test_revert_workdir__merge_first_parent(void);
extern void test_revert_workdir__merge_second_parent(void);
extern void test_revert_workdir__initialize(void);
extern void test_revert_workdir__cleanup(void);
extern void test_revwalk_basic__sorting_modes(void);
extern void test_revwalk_basic__glob_heads(void);
extern void test_revwalk_basic__glob_heads_with_invalid(void);
extern void test_revwalk_basic__glob_invalid_symbolic_ref(void);
extern void test_revwalk_basic__push_head(void);
extern void test_revwalk_basic__sorted_after_reset(void);
extern void test_revwalk_basic__push_head_hide_ref(void);
extern void test_revwalk_basic__push_head_hide_ref_nobase(void);
extern void test_revwalk_basic__multiple_push_1(void);
extern void test_revwalk_basic__multiple_push_2(void);
extern void test_revwalk_basic__disallow_non_commit(void);
extern void test_revwalk_basic__hide_then_push(void);
extern void test_revwalk_basic__topo_crash(void);
extern void test_revwalk_basic__from_new_to_old(void);
extern void test_revwalk_basic__push_range(void);
extern void test_revwalk_basic__push_range_merge_base(void);
extern void test_revwalk_basic__push_range_no_range(void);
extern void test_revwalk_basic__push_mixed(void);
extern void test_revwalk_basic__push_all(void);
extern void test_revwalk_basic__mimic_git_rev_list(void);
extern void test_revwalk_basic__big_timestamp(void);
extern void test_revwalk_basic__old_hidden_commit_one(void);
extern void test_revwalk_basic__old_hidden_commit_two(void);
extern void test_revwalk_basic__newer_hidden_commit_hides_old_commits(void);
extern void test_revwalk_basic__initialize(void);
extern void test_revwalk_basic__cleanup(void);
extern void test_revwalk_hidecb__hide_all_cb(void);
extern void test_revwalk_hidecb__hide_none_cb(void);
extern void test_revwalk_hidecb__unset_cb_before_walk(void);
extern void test_revwalk_hidecb__change_cb_before_walk(void);
extern void test_revwalk_hidecb__add_hide_cb_during_walking(void);
extern void test_revwalk_hidecb__hide_some_commits(void);
extern void test_revwalk_hidecb__test_payload(void);
extern void test_revwalk_hidecb__initialize(void);
extern void test_revwalk_hidecb__cleanup(void);
extern void test_revwalk_mergebase__single1(void);
extern void test_revwalk_mergebase__single2(void);
extern void test_revwalk_mergebase__merged_branch(void);
extern void test_revwalk_mergebase__two_way_merge(void);
extern void test_revwalk_mergebase__no_common_ancestor_returns_ENOTFOUND(void);
extern void test_revwalk_mergebase__prefer_youngest_merge_base(void);
extern void test_revwalk_mergebase__multiple_merge_bases(void);
extern void test_revwalk_mergebase__multiple_merge_bases_many_commits(void);
extern void test_revwalk_mergebase__no_off_by_one_missing(void);
extern void test_revwalk_mergebase__many_no_common_ancestor_returns_ENOTFOUND(void);
extern void test_revwalk_mergebase__many_merge_branch(void);
extern void test_revwalk_mergebase__octopus_no_common_ancestor_returns_ENOTFOUND(void);
extern void test_revwalk_mergebase__octopus_merge_branch(void);
extern void test_revwalk_mergebase__remove_redundant(void);
extern void test_revwalk_mergebase__initialize(void);
extern void test_revwalk_mergebase__cleanup(void);
extern void test_revwalk_signatureparsing__do_not_choke_when_name_contains_angle_brackets(void);
extern void test_revwalk_signatureparsing__initialize(void);
extern void test_revwalk_signatureparsing__cleanup(void);
extern void test_revwalk_simplify__first_parent(void);
extern void test_revwalk_simplify__cleanup(void);
extern void test_stash_apply__with_default(void);
extern void test_stash_apply__with_existing_file(void);
extern void test_stash_apply__merges_new_file(void);
extern void test_stash_apply__with_reinstate_index(void);
extern void test_stash_apply__conflict_index_with_default(void);
extern void test_stash_apply__conflict_index_with_reinstate_index(void);
extern void test_stash_apply__conflict_untracked_with_default(void);
extern void test_stash_apply__conflict_untracked_with_reinstate_index(void);
extern void test_stash_apply__conflict_workdir_with_default(void);
extern void test_stash_apply__conflict_workdir_with_reinstate_index(void);
extern void test_stash_apply__conflict_commit_with_default(void);
extern void test_stash_apply__conflict_commit_with_reinstate_index(void);
extern void test_stash_apply__fails_with_uncommitted_changes_in_index(void);
extern void test_stash_apply__pop(void);
extern void test_stash_apply__executes_notify_cb(void);
extern void test_stash_apply__calls_progress_cb(void);
extern void test_stash_apply__progress_cb_can_abort(void);
extern void test_stash_apply__uses_reflog_like_indices_1(void);
extern void test_stash_apply__uses_reflog_like_indices_2(void);
extern void test_stash_apply__initialize(void);
extern void test_stash_apply__cleanup(void);
extern void test_stash_drop__cannot_drop_from_an_empty_stash(void);
extern void test_stash_drop__cannot_drop_a_non_existing_stashed_state(void);
extern void test_stash_drop__can_purge_the_stash_from_the_top(void);
extern void test_stash_drop__can_purge_the_stash_from_the_bottom(void);
extern void test_stash_drop__dropping_an_entry_rewrites_reflog_history(void);
extern void test_stash_drop__dropping_the_last_entry_removes_the_stash(void);
extern void test_stash_drop__dropping_the_top_stash_updates_the_stash_reference(void);
extern void test_stash_drop__initialize(void);
extern void test_stash_drop__cleanup(void);
extern void test_stash_foreach__enumerating_a_empty_repository_doesnt_fail(void);
extern void test_stash_foreach__can_enumerate_a_repository(void);
extern void test_stash_foreach__initialize(void);
extern void test_stash_foreach__cleanup(void);
extern void test_stash_save__does_not_keep_index_by_default(void);
extern void test_stash_save__can_keep_index(void);
extern void test_stash_save__can_keep_all(void);
extern void test_stash_save__can_include_untracked_files(void);
extern void test_stash_save__untracked_skips_ignored(void);
extern void test_stash_save__can_include_untracked_and_ignored_files(void);
extern void test_stash_save__untracked_regression(void);
extern void test_stash_save__can_accept_a_message(void);
extern void test_stash_save__cannot_stash_against_an_unborn_branch(void);
extern void test_stash_save__cannot_stash_against_a_bare_repository(void);
extern void test_stash_save__can_stash_against_a_detached_head(void);
extern void test_stash_save__stashing_updates_the_reflog(void);
extern void test_stash_save__multiline_message(void);
extern void test_stash_save__cannot_stash_when_there_are_no_local_change(void);
extern void test_stash_save__can_stage_normal_then_stage_untracked(void);
extern void test_stash_save__including_untracked_without_any_untracked_file_creates_an_empty_tree(void);
extern void test_stash_save__ignored_directory(void);
extern void test_stash_save__skip_submodules(void);
extern void test_stash_save__deleted_in_index_modified_in_workdir(void);
extern void test_stash_save__option_paths(void);
extern void test_stash_save__initialize(void);
extern void test_stash_save__cleanup(void);
extern void test_stash_submodules__does_not_stash_modified_submodules(void);
extern void test_stash_submodules__stash_is_empty_with_modified_submodules(void);
extern void test_stash_submodules__initialize(void);
extern void test_stash_submodules__cleanup(void);
extern void test_status_renames__head2index_one(void);
extern void test_status_renames__head2index_two(void);
extern void test_status_renames__head2index_no_rename_from_rewrite(void);
extern void test_status_renames__head2index_rename_from_rewrite(void);
extern void test_status_renames__index2workdir_one(void);
extern void test_status_renames__index2workdir_two(void);
extern void test_status_renames__index2workdir_rename_from_rewrite(void);
extern void test_status_renames__both_one(void);
extern void test_status_renames__both_two(void);
extern void test_status_renames__both_rename_from_rewrite(void);
extern void test_status_renames__rewrites_only_for_renames(void);
extern void test_status_renames__both_casechange_one(void);
extern void test_status_renames__both_casechange_two(void);
extern void test_status_renames__zero_byte_file_does_not_fail(void);
extern void test_status_renames__precomposed_unicode_rename(void);
extern void test_status_renames__precomposed_unicode_toggle_is_rename(void);
extern void test_status_renames__rename_threshold(void);
extern void test_status_renames__case_insensitive_h2i_and_i2wc(void);
extern void test_status_renames__initialize(void);
extern void test_status_renames__cleanup(void);
extern void test_status_single__hash_single_file(void);
extern void test_status_single__hash_single_empty_file(void);
extern void test_status_submodules__api(void);
extern void test_status_submodules__0(void);
extern void test_status_submodules__1(void);
extern void test_status_submodules__single_file(void);
extern void test_status_submodules__moved_head(void);
extern void test_status_submodules__dirty_workdir_only(void);
extern void test_status_submodules__uninitialized(void);
extern void test_status_submodules__contained_untracked_repo(void);
extern void test_status_submodules__broken_stuff_that_git_allows(void);
extern void test_status_submodules__entry_but_dir_tracked(void);
extern void test_status_submodules__mixed_case(void);
extern void test_status_submodules__initialize(void);
extern void test_status_submodules__cleanup(void);
extern void test_status_worktree__whole_repository(void);
extern void test_status_worktree__show_index_and_workdir(void);
extern void test_status_worktree__show_index_only(void);
extern void test_status_worktree__show_workdir_only(void);
extern void test_status_worktree__empty_repository(void);
extern void test_status_worktree__purged_worktree(void);
extern void test_status_worktree__swap_subdir_and_file(void);
extern void test_status_worktree__swap_subdir_with_recurse_and_pathspec(void);
extern void test_status_worktree__within_subdir(void);
extern void test_status_worktree__single_file(void);
extern void test_status_worktree__single_nonexistent_file(void);
extern void test_status_worktree__single_nonexistent_file_empty_repo(void);
extern void test_status_worktree__single_file_empty_repo(void);
extern void test_status_worktree__single_folder(void);
extern void test_status_worktree__ignores(void);
extern void test_status_worktree__issue_592(void);
extern void test_status_worktree__issue_592_2(void);
extern void test_status_worktree__issue_592_3(void);
extern void test_status_worktree__issue_592_4(void);
extern void test_status_worktree__issue_592_5(void);
extern void test_status_worktree__issue_592_ignores_0(void);
extern void test_status_worktree__issue_592_ignored_dirs_with_tracked_content(void);
extern void test_status_worktree__conflict_with_diff3(void);
extern void test_status_worktree__filemode_changes(void);
extern void test_status_worktree__filemode_non755(void);
extern void test_status_worktree__interruptable_foreach(void);
extern void test_status_worktree__line_endings_dont_count_as_changes_with_autocrlf(void);
extern void test_status_worktree__line_endings_dont_count_as_changes_with_autocrlf_issue_1397(void);
extern void test_status_worktree__conflicted_item(void);
extern void test_status_worktree__conflict_has_no_oid(void);
extern void test_status_worktree__file_status_honors_core_ignorecase_true(void);
extern void test_status_worktree__file_status_honors_core_ignorecase_false(void);
extern void test_status_worktree__file_status_honors_case_ignorecase_regarding_untracked_files(void);
extern void test_status_worktree__simple_delete(void);
extern void test_status_worktree__simple_delete_indexed(void);
extern void test_status_worktree__sorting_by_case(void);
extern void test_status_worktree__long_filenames(void);
extern void test_status_worktree__update_stat_cache_0(void);
extern void test_status_worktree__unreadable(void);
extern void test_status_worktree__unreadable_not_included(void);
extern void test_status_worktree__unreadable_as_untracked(void);
extern void test_status_worktree__update_index_with_symlink_doesnt_change_mode(void);
extern void test_status_worktree__with_directory_in_pathlist(void);
extern void test_status_worktree__at_head_parent(void);
extern void test_status_worktree__skip_hash(void);
extern void test_status_worktree__cleanup(void);
extern void test_status_worktree_init__cannot_retrieve_the_status_of_a_bare_repository(void);
extern void test_status_worktree_init__first_commit_in_progress(void);
extern void test_status_worktree_init__status_file_without_index_or_workdir(void);
extern void test_status_worktree_init__status_file_with_clean_index_and_empty_workdir(void);
extern void test_status_worktree_init__bracket_in_filename(void);
extern void test_status_worktree_init__space_in_filename(void);
extern void test_status_worktree_init__disable_pathspec_match(void);
extern void test_status_worktree_init__new_staged_file_must_handle_crlf(void);
extern void test_stream_deprecated__register_tls(void);
extern void test_stream_deprecated__cleanup(void);
extern void test_stream_registration__insecure(void);
extern void test_stream_registration__tls(void);
extern void test_stream_registration__both(void);
extern void test_stream_registration__cleanup(void);
extern void test_stress_diff__rename_big_files(void);
extern void test_stress_diff__rename_many_files(void);
extern void test_stress_diff__initialize(void);
extern void test_stress_diff__cleanup(void);
extern void test_submodule_add__url_absolute(void);
extern void test_submodule_add__url_relative(void);
extern void test_submodule_add__url_relative_to_origin(void);
extern void test_submodule_add__url_relative_to_workdir(void);
extern void test_submodule_add__path_exists_in_index(void);
extern void test_submodule_add__file_exists_in_index(void);
extern void test_submodule_add__submodule_clone(void);
extern void test_submodule_add__submodule_clone_into_nonempty_dir_succeeds(void);
extern void test_submodule_add__submodule_clone_twice_fails(void);
extern void test_submodule_add__cleanup(void);
extern void test_submodule_escape__from_gitdir(void);
extern void test_submodule_escape__from_gitdir_windows(void);
extern void test_submodule_escape__cleanup(void);
extern void test_submodule_init__absolute_url(void);
extern void test_submodule_init__relative_url(void);
extern void test_submodule_init__relative_url_detached_head(void);
extern void test_submodule_init__cleanup(void);
extern void test_submodule_inject_option__url(void);
extern void test_submodule_inject_option__path(void);
extern void test_submodule_inject_option__initialize(void);
extern void test_submodule_inject_option__cleanup(void);
extern void test_submodule_lookup__simple_lookup(void);
extern void test_submodule_lookup__can_be_dupped(void);
extern void test_submodule_lookup__accessors(void);
extern void test_submodule_lookup__foreach(void);
extern void test_submodule_lookup__duplicated_path(void);
extern void test_submodule_lookup__lookup_even_with_unborn_head(void);
extern void test_submodule_lookup__lookup_even_with_missing_index(void);
extern void test_submodule_lookup__backslashes(void);
extern void test_submodule_lookup__just_added(void);
extern void test_submodule_lookup__prefix_name(void);
extern void test_submodule_lookup__dotpath_in_name(void);
extern void test_submodule_lookup__renamed(void);
extern void test_submodule_lookup__cached(void);
extern void test_submodule_lookup__lookup_in_bare_repository_fails(void);
extern void test_submodule_lookup__foreach_in_bare_repository_fails(void);
extern void test_submodule_lookup__fail_invalid_gitmodules(void);
extern void test_submodule_lookup__initialize(void);
extern void test_submodule_lookup__cleanup(void);
extern void test_submodule_modify__init(void);
extern void test_submodule_modify__sync(void);
extern void test_submodule_modify__set_ignore(void);
extern void test_submodule_modify__set_update(void);
extern void test_submodule_modify__set_fetch_recurse_submodules(void);
extern void test_submodule_modify__set_branch(void);
extern void test_submodule_modify__set_url(void);
extern void test_submodule_modify__set_relative_url(void);
extern void test_submodule_modify__initialize(void);
extern void test_submodule_nosubs__lookup(void);
extern void test_submodule_nosubs__foreach(void);
extern void test_submodule_nosubs__add(void);
extern void test_submodule_nosubs__bad_gitmodules(void);
extern void test_submodule_nosubs__add_and_delete(void);
extern void test_submodule_nosubs__cleanup(void);
extern void test_submodule_open__opening_via_lookup_succeeds(void);
extern void test_submodule_open__direct_open_succeeds(void);
extern void test_submodule_open__direct_open_succeeds_for_broken_sm_with_gitdir(void);
extern void test_submodule_open__initialize(void);
extern void test_submodule_open__cleanup(void);
extern void test_submodule_repository_init__basic(void);
extern void test_submodule_status__unchanged(void);
extern void test_submodule_status__ignore_none(void);
extern void test_submodule_status__ignore_untracked(void);
extern void test_submodule_status__ignore_dirty(void);
extern void test_submodule_status__ignore_all(void);
extern void test_submodule_status__iterator(void);
extern void test_submodule_status__untracked_dirs_containing_ignored_files(void);
extern void test_submodule_status__initialize(void);
extern void test_submodule_status__cleanup(void);
extern void test_submodule_update__uninitialized_submodule_no_init(void);
extern void test_submodule_update__update_submodule(void);
extern void test_submodule_update__update_submodule_with_path(void);
extern void test_submodule_update__update_and_init_submodule(void);
extern void test_submodule_update__update_skip_configured_missing_submodule(void);
extern void test_submodule_update__update_already_checked_out_submodule(void);
extern void test_submodule_update__update_blocks_on_dirty_wd(void);
extern void test_submodule_update__can_force_update(void);
extern void test_submodule_update__cleanup(void);
extern void test_threads_atomic__atomic32_set(void);
extern void test_threads_atomic__atomic32_get(void);
extern void test_threads_atomic__atomic32_inc(void);
extern void test_threads_atomic__atomic32_add(void);
extern void test_threads_atomic__atomic32_dec(void);
extern void test_threads_atomic__atomic64_set(void);
extern void test_threads_atomic__atomic64_get(void);
extern void test_threads_atomic__atomic64_add(void);
extern void test_threads_atomic__cas_pointer(void);
extern void test_threads_atomic__cas_intptr(void);
extern void test_threads_atomic__swap(void);
extern void test_threads_atomic__load_ptr(void);
extern void test_threads_atomic__load_intptr(void);
extern void test_threads_basic__cache(void);
extern void test_threads_basic__multiple_init(void);
extern void test_threads_basic__set_error(void);
extern void test_threads_basic__exit(void);
extern void test_threads_basic__initialize(void);
extern void test_threads_basic__cleanup(void);
extern void test_threads_diff__concurrent_diffs(void);
extern void test_threads_diff__with_concurrent_index_modified(void);
extern void test_threads_diff__initialize(void);
extern void test_threads_diff__cleanup(void);
extern void test_threads_iterator__workdir(void);
extern void test_threads_iterator__cleanup(void);
extern void test_threads_refdb__edit_while_iterate(void);
extern void test_threads_refdb__initialize(void);
extern void test_threads_refdb__cleanup(void);
extern void test_threads_tlsdata__can_set_and_get(void);
extern void test_threads_tlsdata__threads(void);
extern void test_trace_trace__sets(void);
extern void test_trace_trace__can_reset(void);
extern void test_trace_trace__can_unset(void);
extern void test_trace_trace__skips_higher_level(void);
extern void test_trace_trace__writes(void);
extern void test_trace_trace__writes_lower_level(void);
extern void test_trace_trace__initialize(void);
extern void test_trace_trace__cleanup(void);
extern void test_trace_windows_stacktrace__basic(void);
extern void test_trace_windows_stacktrace__leaks(void);
extern void test_trace_windows_stacktrace__aux1(void);
extern void test_transport_register__custom_transport(void);
extern void test_transport_register__custom_transport_error_doubleregister(void);
extern void test_transport_register__custom_transport_error_remove_non_existing(void);
extern void test_transport_register__custom_transport_ssh(void);
extern void test_transport_register__custom_transport_callbacks(void);
extern void test_transport_ssh_exec__reject_injection_username(void);
extern void test_transport_ssh_exec__reject_injection_hostname(void);
extern void test_transport_ssh_exec__reject_injection_path(void);
extern void test_transports_smart_packet__parsing_garbage_fails(void);
extern void test_transports_smart_packet__flush_parses(void);
extern void test_transports_smart_packet__data_pkt(void);
extern void test_transports_smart_packet__sideband_progress_pkt(void);
extern void test_transports_smart_packet__sideband_err_pkt(void);
extern void test_transports_smart_packet__ack_pkt(void);
extern void test_transports_smart_packet__nak_pkt(void);
extern void test_transports_smart_packet__error_pkt(void);
extern void test_transports_smart_packet__comment_pkt(void);
extern void test_transports_smart_packet__ok_pkt(void);
extern void test_transports_smart_packet__ng_pkt(void);
extern void test_transports_smart_packet__unpack_pkt(void);
extern void test_transports_smart_packet__ref_pkt(void);
extern void test_win32_forbidden__can_open_index(void);
extern void test_win32_forbidden__can_add_forbidden_filename_with_entry(void);
extern void test_win32_forbidden__cannot_add_dot_git_even_with_entry(void);
extern void test_win32_forbidden__cannot_add_forbidden_filename_from_filesystem(void);
extern void test_win32_forbidden__can_diff_tree_to_index(void);
extern void test_win32_forbidden__can_diff_tree_to_tree(void);
extern void test_win32_forbidden__can_diff_index_to_workdir(void);
extern void test_win32_forbidden__checking_out_forbidden_index_fails(void);
extern void test_win32_forbidden__can_query_submodules(void);
extern void test_win32_forbidden__can_blame_file(void);
extern void test_win32_forbidden__initialize(void);
extern void test_win32_forbidden__cleanup(void);
extern void test_win32_longpath__errmsg_on_checkout(void);
extern void test_win32_longpath__workdir_path_validated(void);
extern void test_win32_longpath__status_and_add(void);
extern void test_win32_longpath__status_and_add_with_filter(void);
extern void test_win32_longpath__initialize(void);
extern void test_win32_longpath__cleanup(void);
extern void test_win32_systemdir__finds_etc_in_path(void);
extern void test_win32_systemdir__finds_mingw64_etc_in_path(void);
extern void test_win32_systemdir__prefers_etc_to_mingw64_in_path(void);
extern void test_win32_systemdir__finds_etc_in_registry(void);
extern void test_win32_systemdir__finds_mingw64_etc_in_registry(void);
extern void test_win32_systemdir__prefers_etc_to_mingw64_in_registry(void);
extern void test_win32_systemdir__prefers_path_to_registry(void);
extern void test_win32_systemdir__no_git_installed(void);
extern void test_win32_systemdir__initialize(void);
extern void test_win32_systemdir__cleanup(void);
extern void test_worktree_bare__list(void);
extern void test_worktree_bare__add(void);
extern void test_worktree_bare__repository_path(void);
extern void test_worktree_bare__initialize(void);
extern void test_worktree_bare__cleanup(void);
extern void test_worktree_config__open(void);
extern void test_worktree_config__set_level_local(void);
extern void test_worktree_config__requires_extension(void);
extern void test_worktree_config__exists(void);
extern void test_worktree_config__set_level_worktree(void);
extern void test_worktree_config__initialize(void);
extern void test_worktree_config__cleanup(void);
extern void test_worktree_merge__merge_head(void);
extern void test_worktree_merge__merge_setup(void);
extern void test_worktree_merge__merge_conflict(void);
extern void test_worktree_merge__initialize(void);
extern void test_worktree_merge__cleanup(void);
extern void test_worktree_open__repository(void);
extern void test_worktree_open__repository_through_workdir(void);
extern void test_worktree_open__repository_through_gitlink(void);
extern void test_worktree_open__repository_through_gitdir(void);
extern void test_worktree_open__open_discovered_worktree(void);
extern void test_worktree_open__repository_with_nonexistent_parent(void);
extern void test_worktree_open__open_from_repository(void);
extern void test_worktree_open__open_from_nonworktree_fails(void);
extern void test_worktree_open__initialize(void);
extern void test_worktree_open__cleanup(void);
extern void test_worktree_reflog__read_worktree_HEAD(void);
extern void test_worktree_reflog__read_parent_HEAD(void);
extern void test_worktree_reflog__read(void);
extern void test_worktree_reflog__append_then_read(void);
extern void test_worktree_reflog__initialize(void);
extern void test_worktree_reflog__cleanup(void);
extern void test_worktree_refs__list_no_difference_in_worktree(void);
extern void test_worktree_refs__list_worktree_specific(void);
extern void test_worktree_refs__list_worktree_specific_hidden_in_main_repo(void);
extern void test_worktree_refs__read_head(void);
extern void test_worktree_refs__set_head_fails_when_worktree_wants_linked_repos_HEAD(void);
extern void test_worktree_refs__set_head_fails_when_main_repo_wants_worktree_head(void);
extern void test_worktree_refs__set_head_works_for_current_HEAD(void);
extern void test_worktree_refs__set_head_fails_when_already_checked_out(void);
extern void test_worktree_refs__delete_fails_for_checked_out_branch(void);
extern void test_worktree_refs__delete_succeeds_after_pruning_worktree(void);
extern void test_worktree_refs__delete_unrelated_branch_on_worktree(void);
extern void test_worktree_refs__delete_unrelated_branch_on_parent(void);
extern void test_worktree_refs__renaming_reference_updates_worktree_heads(void);
extern void test_worktree_refs__creating_refs_uses_commondir(void);
extern void test_worktree_refs__initialize(void);
extern void test_worktree_refs__cleanup(void);
extern void test_worktree_repository__head(void);
extern void test_worktree_repository__head_fails_for_invalid_worktree(void);
extern void test_worktree_repository__head_detached(void);
extern void test_worktree_repository__head_detached_fails_for_invalid_worktree(void);
extern void test_worktree_repository__initialize(void);
extern void test_worktree_repository__cleanup(void);
extern void test_worktree_submodule__submodule_worktree_parent(void);
extern void test_worktree_submodule__submodule_worktree_child(void);
extern void test_worktree_submodule__open_discovered_submodule_worktree(void);
extern void test_worktree_submodule__resolve_relative_url(void);
extern void test_worktree_submodule__initialize(void);
extern void test_worktree_submodule__cleanup(void);
extern void test_worktree_worktree__list(void);
extern void test_worktree_worktree__list_with_invalid_worktree_dirs(void);
extern void test_worktree_worktree__list_in_worktree_repo(void);
extern void test_worktree_worktree__list_without_worktrees(void);
extern void test_worktree_worktree__lookup(void);
extern void test_worktree_worktree__lookup_nonexistent_worktree(void);
extern void test_worktree_worktree__open(void);
extern void test_worktree_worktree__open_invalid_commondir(void);
extern void test_worktree_worktree__open_invalid_gitdir(void);
extern void test_worktree_worktree__open_invalid_parent(void);
extern void test_worktree_worktree__init(void);
extern void test_worktree_worktree__add_remove_add(void);
extern void test_worktree_worktree__add_locked(void);
extern void test_worktree_worktree__init_existing_branch(void);
extern void test_worktree_worktree__add_with_explicit_branch(void);
extern void test_worktree_worktree__add_no_checkout(void);
extern void test_worktree_worktree__init_existing_worktree(void);
extern void test_worktree_worktree__init_existing_path(void);
extern void test_worktree_worktree__init_submodule(void);
extern void test_worktree_worktree__validate(void);
extern void test_worktree_worktree__name(void);
extern void test_worktree_worktree__path(void);
extern void test_worktree_worktree__validate_invalid_commondir(void);
extern void test_worktree_worktree__validate_invalid_gitdir(void);
extern void test_worktree_worktree__validate_invalid_parent(void);
extern void test_worktree_worktree__lock_with_reason(void);
extern void test_worktree_worktree__lock_without_reason(void);
extern void test_worktree_worktree__unlock_unlocked_worktree(void);
extern void test_worktree_worktree__unlock_locked_worktree(void);
extern void test_worktree_worktree__prune_without_opts_fails(void);
extern void test_worktree_worktree__prune_valid(void);
extern void test_worktree_worktree__prune_locked(void);
extern void test_worktree_worktree__prune_gitdir_only(void);
extern void test_worktree_worktree__prune_worktree(void);
extern void test_worktree_worktree__foreach_worktree_lists_all_worktrees(void);
extern void test_worktree_worktree__validate_invalid_worktreedir(void);
extern void test_worktree_worktree__is_prunable_missing_repo(void);
extern void test_worktree_worktree__initialize(void);
extern void test_worktree_worktree__cleanup(void);
static const struct clar_func _clar_cb_apply_both[] = {
    { "generated_diff", &test_apply_both__generated_diff },
    { "parsed_diff", &test_apply_both__parsed_diff },
    { "removes_file", &test_apply_both__removes_file },
    { "adds_file", &test_apply_both__adds_file },
    { "application_failure_leaves_index_unmodified", &test_apply_both__application_failure_leaves_index_unmodified },
    { "index_must_match_workdir", &test_apply_both__index_must_match_workdir },
    { "index_mode_must_match_workdir", &test_apply_both__index_mode_must_match_workdir },
    { "application_failure_leaves_workdir_unmodified", &test_apply_both__application_failure_leaves_workdir_unmodified },
    { "keeps_nonconflicting_changes", &test_apply_both__keeps_nonconflicting_changes },
    { "can_apply_nonconflicting_file_changes", &test_apply_both__can_apply_nonconflicting_file_changes },
    { "honors_crlf_attributes", &test_apply_both__honors_crlf_attributes },
    { "rename", &test_apply_both__rename },
    { "rename_and_modify", &test_apply_both__rename_and_modify },
    { "rename_a_to_b_to_c", &test_apply_both__rename_a_to_b_to_c },
    { "rename_a_to_b_to_c_exact", &test_apply_both__rename_a_to_b_to_c_exact },
    { "rename_circular", &test_apply_both__rename_circular },
    { "rename_2_to_1", &test_apply_both__rename_2_to_1 },
    { "rename_1_to_2", &test_apply_both__rename_1_to_2 },
    { "two_deltas_one_file", &test_apply_both__two_deltas_one_file },
    { "two_deltas_one_new_file", &test_apply_both__two_deltas_one_new_file },
    { "rename_and_modify_deltas", &test_apply_both__rename_and_modify_deltas },
    { "rename_delta_after_modify_delta", &test_apply_both__rename_delta_after_modify_delta },
    { "cant_rename_after_modify_nonexistent_target_path", &test_apply_both__cant_rename_after_modify_nonexistent_target_path },
    { "cant_modify_source_path_after_rename", &test_apply_both__cant_modify_source_path_after_rename },
    { "readd_deleted_file", &test_apply_both__readd_deleted_file },
    { "cant_remove_file_twice", &test_apply_both__cant_remove_file_twice },
    { "cant_add_invalid_filename", &test_apply_both__cant_add_invalid_filename }
};
static const struct clar_func _clar_cb_apply_callbacks[] = {
    { "delta_aborts", &test_apply_callbacks__delta_aborts },
    { "delta_can_skip", &test_apply_callbacks__delta_can_skip },
    { "hunk_can_skip", &test_apply_callbacks__hunk_can_skip }
};
static const struct clar_func _clar_cb_apply_check[] = {
    { "generate_diff", &test_apply_check__generate_diff },
    { "parsed_diff", &test_apply_check__parsed_diff },
    { "binary", &test_apply_check__binary },
    { "does_not_apply", &test_apply_check__does_not_apply }
};
static const struct clar_func _clar_cb_apply_fromdiff[] = {
    { "change_middle", &test_apply_fromdiff__change_middle },
    { "change_middle_nocontext", &test_apply_fromdiff__change_middle_nocontext },
    { "change_firstline", &test_apply_fromdiff__change_firstline },
    { "lastline", &test_apply_fromdiff__lastline },
    { "change_middle_and_lastline_nocontext", &test_apply_fromdiff__change_middle_and_lastline_nocontext },
    { "prepend", &test_apply_fromdiff__prepend },
    { "prepend_nocontext", &test_apply_fromdiff__prepend_nocontext },
    { "prepend_and_change", &test_apply_fromdiff__prepend_and_change },
    { "prepend_and_change_nocontext", &test_apply_fromdiff__prepend_and_change_nocontext },
    { "delete_and_change", &test_apply_fromdiff__delete_and_change },
    { "delete_and_change_nocontext", &test_apply_fromdiff__delete_and_change_nocontext },
    { "delete_firstline", &test_apply_fromdiff__delete_firstline },
    { "append", &test_apply_fromdiff__append },
    { "append_nocontext", &test_apply_fromdiff__append_nocontext },
    { "prepend_and_append", &test_apply_fromdiff__prepend_and_append },
    { "to_empty_file", &test_apply_fromdiff__to_empty_file },
    { "from_empty_file", &test_apply_fromdiff__from_empty_file },
    { "add", &test_apply_fromdiff__add },
    { "delete", &test_apply_fromdiff__delete },
    { "no_change", &test_apply_fromdiff__no_change },
    { "binary_add", &test_apply_fromdiff__binary_add },
    { "binary_no_change", &test_apply_fromdiff__binary_no_change },
    { "binary_change_delta", &test_apply_fromdiff__binary_change_delta },
    { "binary_change_literal", &test_apply_fromdiff__binary_change_literal },
    { "binary_delete", &test_apply_fromdiff__binary_delete },
    { "patching_correctly_truncates_source", &test_apply_fromdiff__patching_correctly_truncates_source }
};
static const struct clar_func _clar_cb_apply_fromfile[] = {
    { "change_middle", &test_apply_fromfile__change_middle },
    { "change_middle_nocontext", &test_apply_fromfile__change_middle_nocontext },
    { "change_firstline", &test_apply_fromfile__change_firstline },
    { "lastline", &test_apply_fromfile__lastline },
    { "change_middle_shrink", &test_apply_fromfile__change_middle_shrink },
    { "change_middle_shrink_nocontext", &test_apply_fromfile__change_middle_shrink_nocontext },
    { "change_middle_grow", &test_apply_fromfile__change_middle_grow },
    { "change_middle_grow_nocontext", &test_apply_fromfile__change_middle_grow_nocontext },
    { "prepend", &test_apply_fromfile__prepend },
    { "prepend_nocontext", &test_apply_fromfile__prepend_nocontext },
    { "append", &test_apply_fromfile__append },
    { "append_nocontext", &test_apply_fromfile__append_nocontext },
    { "prepend_and_append", &test_apply_fromfile__prepend_and_append },
    { "to_empty_file", &test_apply_fromfile__to_empty_file },
    { "from_empty_file", &test_apply_fromfile__from_empty_file },
    { "add", &test_apply_fromfile__add },
    { "delete", &test_apply_fromfile__delete },
    { "rename_exact", &test_apply_fromfile__rename_exact },
    { "rename_similar", &test_apply_fromfile__rename_similar },
    { "rename_similar_quotedname", &test_apply_fromfile__rename_similar_quotedname },
    { "modechange", &test_apply_fromfile__modechange },
    { "modechange_with_modification", &test_apply_fromfile__modechange_with_modification },
    { "noisy", &test_apply_fromfile__noisy },
    { "noisy_nocontext", &test_apply_fromfile__noisy_nocontext },
    { "fail_truncated_1", &test_apply_fromfile__fail_truncated_1 },
    { "fail_truncated_2", &test_apply_fromfile__fail_truncated_2 },
    { "fail_truncated_3", &test_apply_fromfile__fail_truncated_3 },
    { "fail_corrupt_githeader", &test_apply_fromfile__fail_corrupt_githeader },
    { "empty_context", &test_apply_fromfile__empty_context },
    { "append_no_nl", &test_apply_fromfile__append_no_nl },
    { "fail_missing_new_file", &test_apply_fromfile__fail_missing_new_file },
    { "fail_missing_old_file", &test_apply_fromfile__fail_missing_old_file },
    { "fail_no_changes", &test_apply_fromfile__fail_no_changes },
    { "fail_missing_hunk_header", &test_apply_fromfile__fail_missing_hunk_header },
    { "fail_not_a_patch", &test_apply_fromfile__fail_not_a_patch },
    { "binary_add", &test_apply_fromfile__binary_add },
    { "binary_change_delta", &test_apply_fromfile__binary_change_delta },
    { "binary_change_literal", &test_apply_fromfile__binary_change_literal },
    { "binary_delete", &test_apply_fromfile__binary_delete },
    { "binary_change_does_not_apply", &test_apply_fromfile__binary_change_does_not_apply },
    { "binary_change_must_be_reversible", &test_apply_fromfile__binary_change_must_be_reversible },
    { "empty_file_not_allowed", &test_apply_fromfile__empty_file_not_allowed }
};
static const struct clar_func _clar_cb_apply_index[] = {
    { "generate_diff", &test_apply_index__generate_diff },
    { "parsed_diff", &test_apply_index__parsed_diff },
    { "removes_file", &test_apply_index__removes_file },
    { "adds_file", &test_apply_index__adds_file },
    { "modified_workdir_with_unmodified_index_is_ok", &test_apply_index__modified_workdir_with_unmodified_index_is_ok },
    { "application_failure_leaves_index_unmodified", &test_apply_index__application_failure_leaves_index_unmodified },
    { "keeps_nonconflicting_changes", &test_apply_index__keeps_nonconflicting_changes },
    { "can_apply_nonconflicting_file_changes", &test_apply_index__can_apply_nonconflicting_file_changes },
    { "change_mode", &test_apply_index__change_mode }
};
static const struct clar_func _clar_cb_apply_partial[] = {
    { "prepend_and_change_skip_addition", &test_apply_partial__prepend_and_change_skip_addition },
    { "prepend_and_change_nocontext_skip_addition", &test_apply_partial__prepend_and_change_nocontext_skip_addition },
    { "prepend_and_change_nocontext_abort_addition", &test_apply_partial__prepend_and_change_nocontext_abort_addition },
    { "prepend_and_change_skip_change", &test_apply_partial__prepend_and_change_skip_change },
    { "prepend_and_change_nocontext_skip_change", &test_apply_partial__prepend_and_change_nocontext_skip_change },
    { "prepend_and_change_nocontext_abort_change", &test_apply_partial__prepend_and_change_nocontext_abort_change },
    { "delete_and_change_skip_deletion", &test_apply_partial__delete_and_change_skip_deletion },
    { "delete_and_change_nocontext_skip_deletion", &test_apply_partial__delete_and_change_nocontext_skip_deletion },
    { "delete_and_change_nocontext_abort_deletion", &test_apply_partial__delete_and_change_nocontext_abort_deletion },
    { "delete_and_change_skip_change", &test_apply_partial__delete_and_change_skip_change },
    { "delete_and_change_nocontext_skip_change", &test_apply_partial__delete_and_change_nocontext_skip_change },
    { "delete_and_change_nocontext_abort_change", &test_apply_partial__delete_and_change_nocontext_abort_change }
};
static const struct clar_func _clar_cb_apply_tree[] = {
    { "one", &test_apply_tree__one },
    { "adds_file", &test_apply_tree__adds_file }
};
static const struct clar_func _clar_cb_apply_workdir[] = {
    { "generated_diff", &test_apply_workdir__generated_diff },
    { "parsed_diff", &test_apply_workdir__parsed_diff },
    { "removes_file", &test_apply_workdir__removes_file },
    { "adds_file", &test_apply_workdir__adds_file },
    { "modified_index_with_unmodified_workdir_is_ok", &test_apply_workdir__modified_index_with_unmodified_workdir_is_ok },
    { "application_failure_leaves_workdir_unmodified", &test_apply_workdir__application_failure_leaves_workdir_unmodified },
    { "keeps_nonconflicting_changes", &test_apply_workdir__keeps_nonconflicting_changes },
    { "can_apply_nonconflicting_file_changes", &test_apply_workdir__can_apply_nonconflicting_file_changes },
    { "change_mode", &test_apply_workdir__change_mode },
    { "apply_many_changes_one", &test_apply_workdir__apply_many_changes_one },
    { "apply_many_changes_two", &test_apply_workdir__apply_many_changes_two }
};
static const struct clar_func _clar_cb_attr_file[] = {
    { "simple_read", &test_attr_file__simple_read },
    { "match_variants", &test_attr_file__match_variants },
    { "assign_variants", &test_attr_file__assign_variants },
    { "check_attr_examples", &test_attr_file__check_attr_examples },
    { "whitespace", &test_attr_file__whitespace }
};
static const struct clar_func _clar_cb_attr_flags[] = {
    { "bare", &test_attr_flags__bare },
    { "index_vs_workdir", &test_attr_flags__index_vs_workdir },
    { "subdir", &test_attr_flags__subdir }
};
static const struct clar_func _clar_cb_attr_lookup[] = {
    { "simple", &test_attr_lookup__simple },
    { "match_variants", &test_attr_lookup__match_variants },
    { "assign_variants", &test_attr_lookup__assign_variants },
    { "check_attr_examples", &test_attr_lookup__check_attr_examples },
    { "from_buffer", &test_attr_lookup__from_buffer }
};
static const struct clar_func _clar_cb_attr_macro[] = {
    { "macros", &test_attr_macro__macros },
    { "bad_macros", &test_attr_macro__bad_macros },
    { "macros_in_root_wd_apply", &test_attr_macro__macros_in_root_wd_apply },
    { "changing_macro_in_root_wd_updates_attributes", &test_attr_macro__changing_macro_in_root_wd_updates_attributes },
    { "macros_in_subdir_do_not_apply", &test_attr_macro__macros_in_subdir_do_not_apply },
    { "adding_macro_succeeds", &test_attr_macro__adding_macro_succeeds },
    { "adding_boolean_macros_succeeds", &test_attr_macro__adding_boolean_macros_succeeds },
    { "redefining_macro_succeeds", &test_attr_macro__redefining_macro_succeeds },
    { "recursive_macro_resolves", &test_attr_macro__recursive_macro_resolves }
};
static const struct clar_func _clar_cb_attr_repo[] = {
    { "get_one", &test_attr_repo__get_one },
    { "get_one_start_deep", &test_attr_repo__get_one_start_deep },
    { "get_many", &test_attr_repo__get_many },
    { "get_many_in_place", &test_attr_repo__get_many_in_place },
    { "foreach", &test_attr_repo__foreach },
    { "manpage_example", &test_attr_repo__manpage_example },
    { "staging_properly_normalizes_line_endings_according_to_gitattributes_directives", &test_attr_repo__staging_properly_normalizes_line_endings_according_to_gitattributes_directives },
    { "bare_repo_with_index", &test_attr_repo__bare_repo_with_index },
    { "inmemory_repo_without_index", &test_attr_repo__inmemory_repo_without_index },
    { "sysdir", &test_attr_repo__sysdir },
    { "sysdir_with_session", &test_attr_repo__sysdir_with_session },
    { "rewrite", &test_attr_repo__rewrite },
    { "rewrite_sysdir", &test_attr_repo__rewrite_sysdir },
    { "unlink", &test_attr_repo__unlink }
};
static const struct clar_func _clar_cb_blame_buffer[] = {
    { "4_edits", &test_blame_buffer__4_edits },
    { "two_added_lines_and_one_modified", &test_blame_buffer__two_added_lines_and_one_modified },
    { "two_added_lines", &test_blame_buffer__two_added_lines },
    { "added_blocks", &test_blame_buffer__added_blocks },
    { "overlapping_blocks", &test_blame_buffer__overlapping_blocks },
    { "2_add_splits_hunk", &test_blame_buffer__2_add_splits_hunk },
    { "index", &test_blame_buffer__index },
    { "added_line", &test_blame_buffer__added_line },
    { "added_lines", &test_blame_buffer__added_lines },
    { "deleted_line", &test_blame_buffer__deleted_line },
    { "add_splits_hunk", &test_blame_buffer__add_splits_hunk },
    { "delete_crosses_hunk_boundary", &test_blame_buffer__delete_crosses_hunk_boundary },
    { "replace_line", &test_blame_buffer__replace_line },
    { "add_lines_at_end", &test_blame_buffer__add_lines_at_end }
};
static const struct clar_func _clar_cb_blame_getters[] = {
    { "byindex", &test_blame_getters__byindex },
    { "byline", &test_blame_getters__byline }
};
static const struct clar_func _clar_cb_blame_harder[] = {
    { "m", &test_blame_harder__m },
    { "c", &test_blame_harder__c },
    { "cc", &test_blame_harder__cc },
    { "ccc", &test_blame_harder__ccc }
};
static const struct clar_func _clar_cb_blame_simple[] = {
    { "trivial_testrepo", &test_blame_simple__trivial_testrepo },
    { "trivial_blamerepo", &test_blame_simple__trivial_blamerepo },
    { "trivial_libgit2", &test_blame_simple__trivial_libgit2 },
    { "trivial_libgit2_under_cache_pressure", &test_blame_simple__trivial_libgit2_under_cache_pressure },
    { "can_restrict_lines_min", &test_blame_simple__can_restrict_lines_min },
    { "can_ignore_whitespace_change", &test_blame_simple__can_ignore_whitespace_change },
    { "can_restrict_lines_max", &test_blame_simple__can_restrict_lines_max },
    { "can_restrict_lines_both", &test_blame_simple__can_restrict_lines_both },
    { "can_blame_huge_file", &test_blame_simple__can_blame_huge_file },
    { "can_restrict_to_newish_commits", &test_blame_simple__can_restrict_to_newish_commits },
    { "can_restrict_to_first_parent_commits", &test_blame_simple__can_restrict_to_first_parent_commits }
};
static const struct clar_func _clar_cb_checkout_binaryunicode[] = {
    { "noautocrlf", &test_checkout_binaryunicode__noautocrlf },
    { "autocrlf", &test_checkout_binaryunicode__autocrlf }
};
static const struct clar_func _clar_cb_checkout_conflict[] = {
    { "ignored", &test_checkout_conflict__ignored },
    { "ours", &test_checkout_conflict__ours },
    { "theirs", &test_checkout_conflict__theirs },
    { "diff3", &test_checkout_conflict__diff3 },
    { "automerge", &test_checkout_conflict__automerge },
    { "directory_file", &test_checkout_conflict__directory_file },
    { "directory_file_with_custom_labels", &test_checkout_conflict__directory_file_with_custom_labels },
    { "link_file", &test_checkout_conflict__link_file },
    { "links", &test_checkout_conflict__links },
    { "add_add", &test_checkout_conflict__add_add },
    { "mode_change", &test_checkout_conflict__mode_change },
    { "renames", &test_checkout_conflict__renames },
    { "rename_keep_ours", &test_checkout_conflict__rename_keep_ours },
    { "name_mangled_file_exists_in_workdir", &test_checkout_conflict__name_mangled_file_exists_in_workdir },
    { "update_only", &test_checkout_conflict__update_only },
    { "path_filters", &test_checkout_conflict__path_filters },
    { "report_progress", &test_checkout_conflict__report_progress }
};
static const struct clar_func _clar_cb_checkout_crlf[] = {
    { "matches_core_git", &test_checkout_crlf__matches_core_git },
    { "detect_crlf_autocrlf_false", &test_checkout_crlf__detect_crlf_autocrlf_false },
    { "autocrlf_false_index_size_is_unfiltered_size", &test_checkout_crlf__autocrlf_false_index_size_is_unfiltered_size },
    { "detect_crlf_autocrlf_true", &test_checkout_crlf__detect_crlf_autocrlf_true },
    { "detect_crlf_autocrlf_true_utf8", &test_checkout_crlf__detect_crlf_autocrlf_true_utf8 },
    { "autocrlf_true_index_size_is_filtered_size", &test_checkout_crlf__autocrlf_true_index_size_is_filtered_size },
    { "with_ident", &test_checkout_crlf__with_ident },
    { "autocrlf_false_no_attrs", &test_checkout_crlf__autocrlf_false_no_attrs },
    { "autocrlf_true_no_attrs", &test_checkout_crlf__autocrlf_true_no_attrs },
    { "autocrlf_input_no_attrs", &test_checkout_crlf__autocrlf_input_no_attrs },
    { "autocrlf_false_text_auto_attr", &test_checkout_crlf__autocrlf_false_text_auto_attr },
    { "autocrlf_true_text_auto_attr", &test_checkout_crlf__autocrlf_true_text_auto_attr },
    { "autocrlf_input_text_auto_attr", &test_checkout_crlf__autocrlf_input_text_auto_attr },
    { "can_write_empty_file", &test_checkout_crlf__can_write_empty_file }
};
static const struct clar_func _clar_cb_checkout_head[] = {
    { "unborn_head_returns_GIT_EUNBORNBRANCH", &test_checkout_head__unborn_head_returns_GIT_EUNBORNBRANCH },
    { "with_index_only_tree", &test_checkout_head__with_index_only_tree },
    { "do_not_remove_untracked_file", &test_checkout_head__do_not_remove_untracked_file },
    { "do_not_remove_untracked_file_in_subdir", &test_checkout_head__do_not_remove_untracked_file_in_subdir },
    { "do_remove_untracked_paths", &test_checkout_head__do_remove_untracked_paths },
    { "do_remove_tracked_subdir", &test_checkout_head__do_remove_tracked_subdir },
    { "typechange_workdir", &test_checkout_head__typechange_workdir },
    { "typechange_index_and_workdir", &test_checkout_head__typechange_index_and_workdir },
    { "workdir_filemode_is_simplified", &test_checkout_head__workdir_filemode_is_simplified },
    { "obeys_filemode_true", &test_checkout_head__obeys_filemode_true },
    { "obeys_filemode_false", &test_checkout_head__obeys_filemode_false }
};
static const struct clar_func _clar_cb_checkout_icase[] = {
    { "refuses_to_overwrite_files_for_files", &test_checkout_icase__refuses_to_overwrite_files_for_files },
    { "overwrites_files_for_files_when_forced", &test_checkout_icase__overwrites_files_for_files_when_forced },
    { "refuses_to_overwrite_links_for_files", &test_checkout_icase__refuses_to_overwrite_links_for_files },
    { "overwrites_links_for_files_when_forced", &test_checkout_icase__overwrites_links_for_files_when_forced },
    { "overwrites_empty_folders_for_files", &test_checkout_icase__overwrites_empty_folders_for_files },
    { "refuses_to_overwrite_populated_folders_for_files", &test_checkout_icase__refuses_to_overwrite_populated_folders_for_files },
    { "overwrites_folders_for_files_when_forced", &test_checkout_icase__overwrites_folders_for_files_when_forced },
    { "refuses_to_overwrite_files_for_folders", &test_checkout_icase__refuses_to_overwrite_files_for_folders },
    { "overwrites_files_for_folders_when_forced", &test_checkout_icase__overwrites_files_for_folders_when_forced },
    { "refuses_to_overwrite_links_for_folders", &test_checkout_icase__refuses_to_overwrite_links_for_folders },
    { "overwrites_links_for_folders_when_forced", &test_checkout_icase__overwrites_links_for_folders_when_forced },
    { "ignores_unstaged_casechange", &test_checkout_icase__ignores_unstaged_casechange },
    { "conflicts_with_casechanged_subtrees", &test_checkout_icase__conflicts_with_casechanged_subtrees }
};
static const struct clar_func _clar_cb_checkout_index[] = {
    { "cannot_checkout_a_bare_repository", &test_checkout_index__cannot_checkout_a_bare_repository },
    { "can_create_missing_files", &test_checkout_index__can_create_missing_files },
    { "can_remove_untracked_files", &test_checkout_index__can_remove_untracked_files },
    { "can_disable_pathspec_match", &test_checkout_index__can_disable_pathspec_match },
    { "honor_the_specified_pathspecs", &test_checkout_index__honor_the_specified_pathspecs },
    { "honor_the_gitattributes_directives", &test_checkout_index__honor_the_gitattributes_directives },
    { "honor_coreautocrlf_setting_set_to_true", &test_checkout_index__honor_coreautocrlf_setting_set_to_true },
    { "honor_coresymlinks_default_true", &test_checkout_index__honor_coresymlinks_default_true },
    { "honor_coresymlinks_default_false", &test_checkout_index__honor_coresymlinks_default_false },
    { "coresymlinks_set_to_true_fails_when_unsupported", &test_checkout_index__coresymlinks_set_to_true_fails_when_unsupported },
    { "honor_coresymlinks_setting_set_to_true", &test_checkout_index__honor_coresymlinks_setting_set_to_true },
    { "honor_coresymlinks_setting_set_to_false", &test_checkout_index__honor_coresymlinks_setting_set_to_false },
    { "donot_overwrite_modified_file_by_default", &test_checkout_index__donot_overwrite_modified_file_by_default },
    { "can_overwrite_modified_file", &test_checkout_index__can_overwrite_modified_file },
    { "options_disable_filters", &test_checkout_index__options_disable_filters },
    { "options_dir_modes", &test_checkout_index__options_dir_modes },
    { "options_override_file_modes", &test_checkout_index__options_override_file_modes },
    { "options_open_flags", &test_checkout_index__options_open_flags },
    { "can_notify_of_skipped_files", &test_checkout_index__can_notify_of_skipped_files },
    { "wont_notify_of_expected_line_ending_changes", &test_checkout_index__wont_notify_of_expected_line_ending_changes },
    { "calls_progress_callback", &test_checkout_index__calls_progress_callback },
    { "can_overcome_name_clashes", &test_checkout_index__can_overcome_name_clashes },
    { "validates_struct_version", &test_checkout_index__validates_struct_version },
    { "can_update_prefixed_files", &test_checkout_index__can_update_prefixed_files },
    { "can_checkout_a_newly_initialized_repository", &test_checkout_index__can_checkout_a_newly_initialized_repository },
    { "issue_1397", &test_checkout_index__issue_1397 },
    { "target_directory", &test_checkout_index__target_directory },
    { "target_directory_from_bare", &test_checkout_index__target_directory_from_bare },
    { "can_get_repo_from_index", &test_checkout_index__can_get_repo_from_index },
    { "writes_conflict_file", &test_checkout_index__writes_conflict_file },
    { "adding_conflict_removes_stage_0", &test_checkout_index__adding_conflict_removes_stage_0 },
    { "conflicts_honor_coreautocrlf", &test_checkout_index__conflicts_honor_coreautocrlf }
};
static const struct clar_func _clar_cb_checkout_nasty[] = {
    { "dotgit_tree", &test_checkout_nasty__dotgit_tree },
    { "dotcapitalgit_tree", &test_checkout_nasty__dotcapitalgit_tree },
    { "dot_tree", &test_checkout_nasty__dot_tree },
    { "dot_dotgit_tree", &test_checkout_nasty__dot_dotgit_tree },
    { "dotdot_dotgit_tree", &test_checkout_nasty__dotdot_dotgit_tree },
    { "dotdot_tree", &test_checkout_nasty__dotdot_tree },
    { "dotgit_path", &test_checkout_nasty__dotgit_path },
    { "dotcapitalgit_path", &test_checkout_nasty__dotcapitalgit_path },
    { "dot_dotgit_path", &test_checkout_nasty__dot_dotgit_path },
    { "dot_dotcapitalgit_path", &test_checkout_nasty__dot_dotcapitalgit_path },
    { "dotdot_dotgit_path", &test_checkout_nasty__dotdot_dotgit_path },
    { "dotdot_dotcapitalgit_path", &test_checkout_nasty__dotdot_dotcapitalgit_path },
    { "dot_path", &test_checkout_nasty__dot_path },
    { "dot_path_two", &test_checkout_nasty__dot_path_two },
    { "dotdot_path", &test_checkout_nasty__dotdot_path },
    { "dotgit_backslash_path", &test_checkout_nasty__dotgit_backslash_path },
    { "dotcapitalgit_backslash_path", &test_checkout_nasty__dotcapitalgit_backslash_path },
    { "dot_backslash_dotcapitalgit_path", &test_checkout_nasty__dot_backslash_dotcapitalgit_path },
    { "dot_git_dot", &test_checkout_nasty__dot_git_dot },
    { "git_tilde1", &test_checkout_nasty__git_tilde1 },
    { "git_custom_shortname", &test_checkout_nasty__git_custom_shortname },
    { "only_looks_like_a_git_shortname", &test_checkout_nasty__only_looks_like_a_git_shortname },
    { "dot_git_colon", &test_checkout_nasty__dot_git_colon },
    { "dot_git_colon_stuff", &test_checkout_nasty__dot_git_colon_stuff },
    { "dotgit_alternate_data_stream", &test_checkout_nasty__dotgit_alternate_data_stream },
    { "dot_git_hfs_ignorable", &test_checkout_nasty__dot_git_hfs_ignorable },
    { "honors_core_protecthfs", &test_checkout_nasty__honors_core_protecthfs },
    { "honors_core_protectntfs", &test_checkout_nasty__honors_core_protectntfs },
    { "symlink1", &test_checkout_nasty__symlink1 },
    { "symlink2", &test_checkout_nasty__symlink2 },
    { "symlink3", &test_checkout_nasty__symlink3 },
    { "gitmodules_symlink", &test_checkout_nasty__gitmodules_symlink }
};
static const struct clar_func _clar_cb_checkout_tree[] = {
    { "cannot_checkout_a_non_treeish", &test_checkout_tree__cannot_checkout_a_non_treeish },
    { "can_checkout_a_subdirectory_from_a_commit", &test_checkout_tree__can_checkout_a_subdirectory_from_a_commit },
    { "can_checkout_and_remove_directory", &test_checkout_tree__can_checkout_and_remove_directory },
    { "can_checkout_a_subdirectory_from_a_subtree", &test_checkout_tree__can_checkout_a_subdirectory_from_a_subtree },
    { "calls_progress_callback", &test_checkout_tree__calls_progress_callback },
    { "doesnt_write_unrequested_files_to_worktree", &test_checkout_tree__doesnt_write_unrequested_files_to_worktree },
    { "can_switch_branches", &test_checkout_tree__can_switch_branches },
    { "can_remove_untracked", &test_checkout_tree__can_remove_untracked },
    { "can_remove_ignored", &test_checkout_tree__can_remove_ignored },
    { "conflict_on_ignored_when_not_overwriting", &test_checkout_tree__conflict_on_ignored_when_not_overwriting },
    { "can_overwrite_ignored_by_default", &test_checkout_tree__can_overwrite_ignored_by_default },
    { "conflict_on_ignored_folder_when_not_overwriting", &test_checkout_tree__conflict_on_ignored_folder_when_not_overwriting },
    { "can_overwrite_ignored_folder_by_default", &test_checkout_tree__can_overwrite_ignored_folder_by_default },
    { "can_update_only", &test_checkout_tree__can_update_only },
    { "can_checkout_with_pattern", &test_checkout_tree__can_checkout_with_pattern },
    { "pathlist_checkout_ignores_non_matches", &test_checkout_tree__pathlist_checkout_ignores_non_matches },
    { "can_disable_pattern_match", &test_checkout_tree__can_disable_pattern_match },
    { "checking_out_a_conflicting_type_change_returns_ECONFLICT", &test_checkout_tree__checking_out_a_conflicting_type_change_returns_ECONFLICT },
    { "checking_out_a_conflicting_type_change_returns_ECONFLICT_2", &test_checkout_tree__checking_out_a_conflicting_type_change_returns_ECONFLICT_2 },
    { "checking_out_a_conflicting_content_change_returns_ECONFLICT", &test_checkout_tree__checking_out_a_conflicting_content_change_returns_ECONFLICT },
    { "donot_update_deleted_file_by_default", &test_checkout_tree__donot_update_deleted_file_by_default },
    { "can_cancel_checkout_from_notify", &test_checkout_tree__can_cancel_checkout_from_notify },
    { "can_checkout_with_last_workdir_item_missing", &test_checkout_tree__can_checkout_with_last_workdir_item_missing },
    { "issue_1397", &test_checkout_tree__issue_1397 },
    { "can_write_to_empty_dirs", &test_checkout_tree__can_write_to_empty_dirs },
    { "fails_when_dir_in_use", &test_checkout_tree__fails_when_dir_in_use },
    { "can_continue_when_dir_in_use", &test_checkout_tree__can_continue_when_dir_in_use },
    { "target_directory_from_bare", &test_checkout_tree__target_directory_from_bare },
    { "extremely_long_file_name", &test_checkout_tree__extremely_long_file_name },
    { "fails_when_conflicts_exist_in_index", &test_checkout_tree__fails_when_conflicts_exist_in_index },
    { "filemode_preserved_in_index", &test_checkout_tree__filemode_preserved_in_index },
    { "filemode_preserved_in_workdir", &test_checkout_tree__filemode_preserved_in_workdir },
    { "removes_conflicts", &test_checkout_tree__removes_conflicts },
    { "removes_conflicts_only_by_pathscope", &test_checkout_tree__removes_conflicts_only_by_pathscope },
    { "case_changing_rename", &test_checkout_tree__case_changing_rename },
    { "can_collect_perfdata", &test_checkout_tree__can_collect_perfdata },
    { "caches_attributes_during_checkout", &test_checkout_tree__caches_attributes_during_checkout },
    { "can_not_update_index", &test_checkout_tree__can_not_update_index },
    { "can_update_but_not_write_index", &test_checkout_tree__can_update_but_not_write_index },
    { "safe_proceeds_if_no_index", &test_checkout_tree__safe_proceeds_if_no_index },
    { "baseline_is_empty_when_no_index", &test_checkout_tree__baseline_is_empty_when_no_index },
    { "mode_change_is_force_updated", &test_checkout_tree__mode_change_is_force_updated },
    { "nullopts", &test_checkout_tree__nullopts },
    { "retains_external_index_changes", &test_checkout_tree__retains_external_index_changes },
    { "no_index_refresh", &test_checkout_tree__no_index_refresh },
    { "dry_run", &test_checkout_tree__dry_run }
};
static const struct clar_func _clar_cb_checkout_typechange[] = {
    { "checkout_typechanges_safe", &test_checkout_typechange__checkout_typechanges_safe },
    { "checkout_with_conflicts", &test_checkout_typechange__checkout_with_conflicts },
    { "status_char", &test_checkout_typechange__status_char }
};
static const struct clar_func _clar_cb_cherrypick_bare[] = {
    { "automerge", &test_cherrypick_bare__automerge },
    { "conflicts", &test_cherrypick_bare__conflicts },
    { "orphan", &test_cherrypick_bare__orphan }
};
static const struct clar_func _clar_cb_cherrypick_workdir[] = {
    { "automerge", &test_cherrypick_workdir__automerge },
    { "empty_result", &test_cherrypick_workdir__empty_result },
    { "conflicts", &test_cherrypick_workdir__conflicts },
    { "conflict_use_ours", &test_cherrypick_workdir__conflict_use_ours },
    { "rename", &test_cherrypick_workdir__rename },
    { "both_renamed", &test_cherrypick_workdir__both_renamed },
    { "nonmerge_fails_mainline_specified", &test_cherrypick_workdir__nonmerge_fails_mainline_specified },
    { "merge_fails_without_mainline_specified", &test_cherrypick_workdir__merge_fails_without_mainline_specified },
    { "merge_first_parent", &test_cherrypick_workdir__merge_first_parent },
    { "merge_second_parent", &test_cherrypick_workdir__merge_second_parent }
};
static const struct clar_func _clar_cb_clone_empty[] = {
    { "can_clone_an_empty_local_repo_barely", &test_clone_empty__can_clone_an_empty_local_repo_barely },
    { "respects_initialbranch_config", &test_clone_empty__respects_initialbranch_config },
    { "can_clone_an_empty_local_repo", &test_clone_empty__can_clone_an_empty_local_repo },
    { "can_clone_an_empty_standard_repo", &test_clone_empty__can_clone_an_empty_standard_repo }
};
static const struct clar_func _clar_cb_clone_local[] = {
    { "should_clone_local", &test_clone_local__should_clone_local },
    { "hardlinks", &test_clone_local__hardlinks },
    { "standard_unc_paths_are_written_git_style", &test_clone_local__standard_unc_paths_are_written_git_style },
    { "git_style_unc_paths", &test_clone_local__git_style_unc_paths },
    { "shallow_fails", &test_clone_local__shallow_fails }
};
static const struct clar_func _clar_cb_clone_nonetwork[] = {
    { "bad_urls", &test_clone_nonetwork__bad_urls },
    { "do_not_clean_existing_directory", &test_clone_nonetwork__do_not_clean_existing_directory },
    { "local", &test_clone_nonetwork__local },
    { "local_absolute_path", &test_clone_nonetwork__local_absolute_path },
    { "local_bare", &test_clone_nonetwork__local_bare },
    { "fail_when_the_target_is_a_file", &test_clone_nonetwork__fail_when_the_target_is_a_file },
    { "fail_with_already_existing_but_non_empty_directory", &test_clone_nonetwork__fail_with_already_existing_but_non_empty_directory },
    { "custom_origin_name", &test_clone_nonetwork__custom_origin_name },
    { "defaults", &test_clone_nonetwork__defaults },
    { "cope_with_already_existing_directory", &test_clone_nonetwork__cope_with_already_existing_directory },
    { "can_prevent_the_checkout_of_a_standard_repo", &test_clone_nonetwork__can_prevent_the_checkout_of_a_standard_repo },
    { "can_checkout_given_branch", &test_clone_nonetwork__can_checkout_given_branch },
    { "can_cancel_clone_in_fetch", &test_clone_nonetwork__can_cancel_clone_in_fetch },
    { "can_cancel_clone_in_checkout", &test_clone_nonetwork__can_cancel_clone_in_checkout },
    { "can_detached_head", &test_clone_nonetwork__can_detached_head },
    { "clone_tag_to_tree", &test_clone_nonetwork__clone_tag_to_tree },
    { "clone_updates_reflog_properly", &test_clone_nonetwork__clone_updates_reflog_properly },
    { "clone_from_empty_sets_upstream", &test_clone_nonetwork__clone_from_empty_sets_upstream }
};
static const struct clar_func _clar_cb_clone_transport[] = {
    { "custom_transport", &test_clone_transport__custom_transport }
};
static const struct clar_func _clar_cb_commit_commit[] = {
    { "create_unexisting_update_ref", &test_commit_commit__create_unexisting_update_ref },
    { "create_initial_commit", &test_commit_commit__create_initial_commit },
    { "create_initial_commit_parent_not_current", &test_commit_commit__create_initial_commit_parent_not_current },
    { "summary", &test_commit_commit__summary },
    { "body", &test_commit_commit__body }
};
static const struct clar_func _clar_cb_commit_create[] = {
    { "from_stage_simple", &test_commit_create__from_stage_simple },
    { "from_stage_nochanges", &test_commit_create__from_stage_nochanges },
    { "from_stage_newrepo", &test_commit_create__from_stage_newrepo }
};
static const struct clar_func _clar_cb_commit_parent[] = {
    { "can_retrieve_nth_generation_parent", &test_commit_parent__can_retrieve_nth_generation_parent }
};
static const struct clar_func _clar_cb_commit_parse[] = {
    { "header", &test_commit_parse__header },
    { "signature", &test_commit_parse__signature },
    { "entire_commit", &test_commit_parse__entire_commit },
    { "details0", &test_commit_parse__details0 },
    { "leading_lf", &test_commit_parse__leading_lf },
    { "only_lf", &test_commit_parse__only_lf },
    { "arbitrary_field", &test_commit_parse__arbitrary_field },
    { "extract_signature", &test_commit_parse__extract_signature }
};
static const struct clar_func _clar_cb_commit_signature[] = {
    { "leading_and_trailing_spaces_are_trimmed", &test_commit_signature__leading_and_trailing_spaces_are_trimmed },
    { "leading_and_trailing_dots_are_supported", &test_commit_signature__leading_and_trailing_dots_are_supported },
    { "leading_and_trailing_crud_is_trimmed", &test_commit_signature__leading_and_trailing_crud_is_trimmed },
    { "timezone_does_not_read_oob", &test_commit_signature__timezone_does_not_read_oob },
    { "angle_brackets_in_names_are_not_supported", &test_commit_signature__angle_brackets_in_names_are_not_supported },
    { "angle_brackets_in_email_are_not_supported", &test_commit_signature__angle_brackets_in_email_are_not_supported },
    { "create_empties", &test_commit_signature__create_empties },
    { "create_one_char", &test_commit_signature__create_one_char },
    { "create_two_char", &test_commit_signature__create_two_char },
    { "create_zero_char", &test_commit_signature__create_zero_char },
    { "from_buf", &test_commit_signature__from_buf },
    { "from_buf_with_neg_zero_offset", &test_commit_signature__from_buf_with_neg_zero_offset },
    { "pos_and_neg_zero_offsets_dont_match", &test_commit_signature__pos_and_neg_zero_offsets_dont_match },
    { "from_env", &test_commit_signature__from_env }
};
static const struct clar_func _clar_cb_commit_write[] = {
    { "from_memory", &test_commit_write__from_memory },
    { "into_buf", &test_commit_write__into_buf },
    { "root", &test_commit_write__root },
    { "can_write_invalid_objects", &test_commit_write__can_write_invalid_objects },
    { "can_validate_objects", &test_commit_write__can_validate_objects },
    { "attach_signature_checks_objects", &test_commit_write__attach_signature_checks_objects },
    { "attach_singleline_signature", &test_commit_write__attach_singleline_signature },
    { "attach_multiline_signature", &test_commit_write__attach_multiline_signature }
};
static const struct clar_func _clar_cb_config_add[] = {
    { "to_existing_section", &test_config_add__to_existing_section },
    { "to_new_section", &test_config_add__to_new_section }
};
static const struct clar_func _clar_cb_config_backend[] = {
    { "checks_version", &test_config_backend__checks_version }
};
static const struct clar_func _clar_cb_config_conditionals[] = {
    { "gitdir", &test_config_conditionals__gitdir },
    { "gitdir_i", &test_config_conditionals__gitdir_i },
    { "invalid_conditional_fails", &test_config_conditionals__invalid_conditional_fails },
    { "onbranch", &test_config_conditionals__onbranch },
    { "empty", &test_config_conditionals__empty }
};
static const struct clar_func _clar_cb_config_configlevel[] = {
    { "adding_the_same_level_twice_returns_EEXISTS", &test_config_configlevel__adding_the_same_level_twice_returns_EEXISTS },
    { "can_replace_a_config_file_at_an_existing_level", &test_config_configlevel__can_replace_a_config_file_at_an_existing_level },
    { "can_read_from_a_single_level_focused_file_after_parent_config_has_been_freed", &test_config_configlevel__can_read_from_a_single_level_focused_file_after_parent_config_has_been_freed },
    { "fetching_a_level_from_an_empty_compound_config_returns_ENOTFOUND", &test_config_configlevel__fetching_a_level_from_an_empty_compound_config_returns_ENOTFOUND },
    { "can_fetch_highest_level", &test_config_configlevel__can_fetch_highest_level },
    { "can_override_local_with_worktree", &test_config_configlevel__can_override_local_with_worktree }
};
static const struct clar_func _clar_cb_config_find[] = {
    { "one", &test_config_find__one }
};
static const struct clar_func _clar_cb_config_global[] = {
    { "open_global", &test_config_global__open_global },
    { "open_symlinked_global", &test_config_global__open_symlinked_global },
    { "lock_missing_global_config", &test_config_global__lock_missing_global_config },
    { "open_xdg", &test_config_global__open_xdg },
    { "open_programdata", &test_config_global__open_programdata }
};
static const struct clar_func _clar_cb_config_include[] = {
    { "relative", &test_config_include__relative },
    { "absolute", &test_config_include__absolute },
    { "homedir", &test_config_include__homedir },
    { "ordering", &test_config_include__ordering },
    { "depth", &test_config_include__depth },
    { "empty_path_sanely_handled", &test_config_include__empty_path_sanely_handled },
    { "missing", &test_config_include__missing },
    { "missing_homedir", &test_config_include__missing_homedir },
    { "depth2", &test_config_include__depth2 },
    { "removing_include_removes_values", &test_config_include__removing_include_removes_values },
    { "rewriting_include_refreshes_values", &test_config_include__rewriting_include_refreshes_values },
    { "rewriting_include_twice_refreshes_values", &test_config_include__rewriting_include_twice_refreshes_values },
    { "included_variables_cannot_be_deleted", &test_config_include__included_variables_cannot_be_deleted },
    { "included_variables_cannot_be_modified", &test_config_include__included_variables_cannot_be_modified },
    { "variables_in_included_override_including", &test_config_include__variables_in_included_override_including },
    { "variables_in_including_override_included", &test_config_include__variables_in_including_override_included }
};
static const struct clar_func _clar_cb_config_memory[] = {
    { "write_operations_fail", &test_config_memory__write_operations_fail },
    { "simple", &test_config_memory__simple },
    { "malformed_fails_to_open", &test_config_memory__malformed_fails_to_open },
    { "multiple_vars", &test_config_memory__multiple_vars },
    { "multiple_sections", &test_config_memory__multiple_sections },
    { "multivar_gets_correct_string", &test_config_memory__multivar_gets_correct_string },
    { "foreach_sees_multivar", &test_config_memory__foreach_sees_multivar },
    { "values", &test_config_memory__values },
    { "valid_values", &test_config_memory__valid_values }
};
static const struct clar_func _clar_cb_config_multivar[] = {
    { "foreach", &test_config_multivar__foreach },
    { "get", &test_config_multivar__get },
    { "add", &test_config_multivar__add },
    { "add_new", &test_config_multivar__add_new },
    { "replace", &test_config_multivar__replace },
    { "replace_multiple", &test_config_multivar__replace_multiple },
    { "delete", &test_config_multivar__delete },
    { "delete_multiple", &test_config_multivar__delete_multiple },
    { "delete_notfound", &test_config_multivar__delete_notfound },
    { "rename_section", &test_config_multivar__rename_section }
};
static const struct clar_func _clar_cb_config_new[] = {
    { "write_new_config", &test_config_new__write_new_config }
};
static const struct clar_func _clar_cb_config_read[] = {
    { "simple_read", &test_config_read__simple_read },
    { "case_sensitive", &test_config_read__case_sensitive },
    { "multiline_value", &test_config_read__multiline_value },
    { "multiline_value_and_eof", &test_config_read__multiline_value_and_eof },
    { "multiline_eof", &test_config_read__multiline_eof },
    { "subsection_header", &test_config_read__subsection_header },
    { "lone_variable", &test_config_read__lone_variable },
    { "number_suffixes", &test_config_read__number_suffixes },
    { "blank_lines", &test_config_read__blank_lines },
    { "invalid_ext_headers", &test_config_read__invalid_ext_headers },
    { "empty_files", &test_config_read__empty_files },
    { "symbol_headers", &test_config_read__symbol_headers },
    { "multiline_multiple_quoted_comment_chars", &test_config_read__multiline_multiple_quoted_comment_chars },
    { "multiline_multiple_quoted_quote_at_beginning_of_line", &test_config_read__multiline_multiple_quoted_quote_at_beginning_of_line },
    { "header_in_last_line", &test_config_read__header_in_last_line },
    { "prefixes", &test_config_read__prefixes },
    { "escaping_quotes", &test_config_read__escaping_quotes },
    { "invalid_escape_sequence", &test_config_read__invalid_escape_sequence },
    { "foreach", &test_config_read__foreach },
    { "iterator", &test_config_read__iterator },
    { "foreach_match", &test_config_read__foreach_match },
    { "iterator_invalid_glob", &test_config_read__iterator_invalid_glob },
    { "iterator_glob", &test_config_read__iterator_glob },
    { "whitespace_not_required_around_assignment", &test_config_read__whitespace_not_required_around_assignment },
    { "read_git_config_entry", &test_config_read__read_git_config_entry },
    { "local_config_overrides_global_config_overrides_system_config", &test_config_read__local_config_overrides_global_config_overrides_system_config },
    { "fallback_from_local_to_global_and_from_global_to_system", &test_config_read__fallback_from_local_to_global_and_from_global_to_system },
    { "parent_dir_is_file", &test_config_read__parent_dir_is_file },
    { "simple_read_from_specific_level", &test_config_read__simple_read_from_specific_level },
    { "can_load_and_parse_an_empty_config_file", &test_config_read__can_load_and_parse_an_empty_config_file },
    { "corrupt_header", &test_config_read__corrupt_header },
    { "corrupt_header2", &test_config_read__corrupt_header2 },
    { "corrupt_header3", &test_config_read__corrupt_header3 },
    { "invalid_key_chars", &test_config_read__invalid_key_chars },
    { "lone_variable_with_trailing_whitespace", &test_config_read__lone_variable_with_trailing_whitespace },
    { "override_variable", &test_config_read__override_variable },
    { "path", &test_config_read__path },
    { "crlf_style_line_endings", &test_config_read__crlf_style_line_endings },
    { "trailing_crlf", &test_config_read__trailing_crlf },
    { "bom", &test_config_read__bom },
    { "arbitrary_whitespace_before_subsection", &test_config_read__arbitrary_whitespace_before_subsection },
    { "no_whitespace_after_subsection", &test_config_read__no_whitespace_after_subsection },
    { "invalid_space_section", &test_config_read__invalid_space_section },
    { "invalid_quoted_first_section", &test_config_read__invalid_quoted_first_section },
    { "invalid_unquoted_subsection", &test_config_read__invalid_unquoted_subsection },
    { "invalid_quoted_third_section", &test_config_read__invalid_quoted_third_section },
    { "unreadable_file_ignored", &test_config_read__unreadable_file_ignored },
    { "single_line", &test_config_read__single_line },
    { "nosection", &test_config_read__nosection },
    { "get_mapped", &test_config_read__get_mapped }
};
static const struct clar_func _clar_cb_config_readonly[] = {
    { "writing_to_readonly_fails", &test_config_readonly__writing_to_readonly_fails },
    { "writing_to_cfg_with_rw_precedence_succeeds", &test_config_readonly__writing_to_cfg_with_rw_precedence_succeeds },
    { "writing_to_cfg_with_ro_precedence_succeeds", &test_config_readonly__writing_to_cfg_with_ro_precedence_succeeds }
};
static const struct clar_func _clar_cb_config_rename[] = {
    { "can_rename", &test_config_rename__can_rename },
    { "prevent_overwrite", &test_config_rename__prevent_overwrite },
    { "require_a_valid_new_name", &test_config_rename__require_a_valid_new_name }
};
static const struct clar_func _clar_cb_config_snapshot[] = {
    { "create_snapshot", &test_config_snapshot__create_snapshot },
    { "multivar", &test_config_snapshot__multivar },
    { "includes", &test_config_snapshot__includes },
    { "snapshot", &test_config_snapshot__snapshot },
    { "snapshot_from_in_memory", &test_config_snapshot__snapshot_from_in_memory }
};
static const struct clar_func _clar_cb_config_stress[] = {
    { "dont_break_on_invalid_input", &test_config_stress__dont_break_on_invalid_input },
    { "comments", &test_config_stress__comments },
    { "escape_subsection_names", &test_config_stress__escape_subsection_names },
    { "trailing_backslash", &test_config_stress__trailing_backslash },
    { "complex", &test_config_stress__complex },
    { "quick_write", &test_config_stress__quick_write },
    { "foreach_refreshes", &test_config_stress__foreach_refreshes },
    { "foreach_refreshes_snapshot", &test_config_stress__foreach_refreshes_snapshot },
    { "huge_section_with_many_values", &test_config_stress__huge_section_with_many_values }
};
static const struct clar_func _clar_cb_config_validkeyname[] = {
    { "accessing_requires_a_valid_name", &test_config_validkeyname__accessing_requires_a_valid_name }
};
static const struct clar_func _clar_cb_config_write[] = {
    { "replace_value", &test_config_write__replace_value },
    { "delete_value", &test_config_write__delete_value },
    { "delete_value_at_specific_level", &test_config_write__delete_value_at_specific_level },
    { "delete_value_with_duplicate_header", &test_config_write__delete_value_with_duplicate_header },
    { "add_value_with_duplicate_header", &test_config_write__add_value_with_duplicate_header },
    { "overwrite_value_with_duplicate_header", &test_config_write__overwrite_value_with_duplicate_header },
    { "overwrite_multivar_within_duplicate_header", &test_config_write__overwrite_multivar_within_duplicate_header },
    { "write_subsection", &test_config_write__write_subsection },
    { "delete_inexistent", &test_config_write__delete_inexistent },
    { "value_containing_quotes", &test_config_write__value_containing_quotes },
    { "escape_value", &test_config_write__escape_value },
    { "add_value_at_specific_level", &test_config_write__add_value_at_specific_level },
    { "add_value_at_file_with_no_clrf_at_the_end", &test_config_write__add_value_at_file_with_no_clrf_at_the_end },
    { "add_section_at_file_with_no_clrf_at_the_end", &test_config_write__add_section_at_file_with_no_clrf_at_the_end },
    { "add_value_which_needs_quotes", &test_config_write__add_value_which_needs_quotes },
    { "can_set_a_value_to_NULL", &test_config_write__can_set_a_value_to_NULL },
    { "can_set_an_empty_value", &test_config_write__can_set_an_empty_value },
    { "updating_a_locked_config_file_returns_ELOCKED", &test_config_write__updating_a_locked_config_file_returns_ELOCKED },
    { "outside_change", &test_config_write__outside_change },
    { "preserves_whitespace_and_comments", &test_config_write__preserves_whitespace_and_comments },
    { "preserves_entry_with_name_only", &test_config_write__preserves_entry_with_name_only },
    { "to_empty_file", &test_config_write__to_empty_file },
    { "to_file_with_only_comment", &test_config_write__to_file_with_only_comment },
    { "locking", &test_config_write__locking },
    { "abort_lock", &test_config_write__abort_lock },
    { "repeated", &test_config_write__repeated },
    { "preserve_case", &test_config_write__preserve_case },
    { "write_config_file_with_multi_line_value", &test_config_write__write_config_file_with_multi_line_value }
};
static const struct clar_func _clar_cb_core_buf[] = {
    { "sanitize", &test_core_buf__sanitize },
    { "tostr", &test_core_buf__tostr },
    { "fromstr", &test_core_buf__fromstr }
};
static const struct clar_func _clar_cb_core_env[] = {
    { "0", &test_core_env__0 },
    { "1", &test_core_env__1 },
    { "2", &test_core_env__2 },
    { "substitution", &test_core_env__substitution }
};
static const struct clar_func _clar_cb_core_features[] = {
    { "0", &test_core_features__0 }
};
static const struct clar_func _clar_cb_core_hashsig[] = {
    { "similarity_metric", &test_core_hashsig__similarity_metric },
    { "similarity_metric_whitespace", &test_core_hashsig__similarity_metric_whitespace }
};
static const struct clar_func _clar_cb_core_oid[] = {
    { "streq_sha1", &test_core_oid__streq_sha1 },
    { "streq_sha256", &test_core_oid__streq_sha256 },
    { "strcmp_sha1", &test_core_oid__strcmp_sha1 },
    { "strcmp_sha256", &test_core_oid__strcmp_sha256 },
    { "ncmp_sha1", &test_core_oid__ncmp_sha1 },
    { "ncmp_sha256", &test_core_oid__ncmp_sha256 },
    { "is_hexstr", &test_core_oid__is_hexstr },
    { "fmt_substr_sha1", &test_core_oid__fmt_substr_sha1 },
    { "type_lookup", &test_core_oid__type_lookup }
};
static const struct clar_func _clar_cb_core_oidarray[] = {
    { "add_and_remove_oid_from_shallowarray", &test_core_oidarray__add_and_remove_oid_from_shallowarray }
};
static const struct clar_func _clar_cb_core_oidmap[] = {
    { "basic", &test_core_oidmap__basic },
    { "hash_collision", &test_core_oidmap__hash_collision },
    { "get_succeeds_with_existing_keys", &test_core_oidmap__get_succeeds_with_existing_keys },
    { "get_fails_with_nonexisting_key", &test_core_oidmap__get_fails_with_nonexisting_key },
    { "setting_oid_persists", &test_core_oidmap__setting_oid_persists },
    { "setting_existing_key_updates", &test_core_oidmap__setting_existing_key_updates }
};
static const struct clar_func _clar_cb_core_opts[] = {
    { "readwrite", &test_core_opts__readwrite },
    { "invalid_option", &test_core_opts__invalid_option },
    { "extensions_query", &test_core_opts__extensions_query },
    { "extensions_add", &test_core_opts__extensions_add },
    { "extensions_remove", &test_core_opts__extensions_remove },
    { "extensions_uniq", &test_core_opts__extensions_uniq }
};
static const struct clar_func _clar_cb_core_pool[] = {
    { "oid", &test_core_pool__oid }
};
static const struct clar_func _clar_cb_core_structinit[] = {
    { "compare", &test_core_structinit__compare }
};
static const struct clar_func _clar_cb_core_useragent[] = {
    { "get_default", &test_core_useragent__get_default },
    { "set", &test_core_useragent__set }
};
static const struct clar_func _clar_cb_date_date[] = {
    { "overflow", &test_date_date__overflow },
    { "invalid_date", &test_date_date__invalid_date },
    { "offset", &test_date_date__offset }
};
static const struct clar_func _clar_cb_date_rfc2822[] = {
    { "format_rfc2822_no_offset", &test_date_rfc2822__format_rfc2822_no_offset },
    { "format_rfc2822_positive_offset", &test_date_rfc2822__format_rfc2822_positive_offset },
    { "format_rfc2822_negative_offset", &test_date_rfc2822__format_rfc2822_negative_offset }
};
static const struct clar_func _clar_cb_delta_apply[] = {
    { "read_at_off", &test_delta_apply__read_at_off },
    { "read_after_limit", &test_delta_apply__read_after_limit }
};
static const struct clar_func _clar_cb_describe_describe[] = {
    { "can_describe_against_a_bare_repo", &test_describe_describe__can_describe_against_a_bare_repo },
    { "describe_a_repo_with_no_refs", &test_describe_describe__describe_a_repo_with_no_refs }
};
static const struct clar_func _clar_cb_describe_t6120[] = {
    { "default", &test_describe_t6120__default },
    { "tags", &test_describe_t6120__tags },
    { "all", &test_describe_t6120__all },
    { "longformat", &test_describe_t6120__longformat },
    { "firstparent", &test_describe_t6120__firstparent },
    { "workdir", &test_describe_t6120__workdir },
    { "pattern", &test_describe_t6120__pattern }
};
static const struct clar_func _clar_cb_diff_binary[] = {
    { "add_normal", &test_diff_binary__add_normal },
    { "add", &test_diff_binary__add },
    { "modify_normal", &test_diff_binary__modify_normal },
    { "modify", &test_diff_binary__modify },
    { "delete_normal", &test_diff_binary__delete_normal },
    { "delete", &test_diff_binary__delete },
    { "delta", &test_diff_binary__delta },
    { "delta_append", &test_diff_binary__delta_append },
    { "empty_for_no_diff", &test_diff_binary__empty_for_no_diff },
    { "index_to_workdir", &test_diff_binary__index_to_workdir },
    { "print_patch_from_diff", &test_diff_binary__print_patch_from_diff },
    { "blob_to_blob", &test_diff_binary__blob_to_blob }
};
static const struct clar_func _clar_cb_diff_blob[] = {
    { "patch_with_freed_blobs", &test_diff_blob__patch_with_freed_blobs },
    { "can_compare_text_blobs", &test_diff_blob__can_compare_text_blobs },
    { "can_compare_text_blobs_with_patch", &test_diff_blob__can_compare_text_blobs_with_patch },
    { "can_compare_against_null_blobs", &test_diff_blob__can_compare_against_null_blobs },
    { "can_compare_against_null_blobs_with_patch", &test_diff_blob__can_compare_against_null_blobs_with_patch },
    { "can_compare_identical_blobs", &test_diff_blob__can_compare_identical_blobs },
    { "can_compare_identical_blobs_with_patch", &test_diff_blob__can_compare_identical_blobs_with_patch },
    { "can_compare_two_binary_blobs", &test_diff_blob__can_compare_two_binary_blobs },
    { "can_compare_a_binary_blob_and_a_text_blob", &test_diff_blob__can_compare_a_binary_blob_and_a_text_blob },
    { "comparing_two_text_blobs_honors_interhunkcontext", &test_diff_blob__comparing_two_text_blobs_honors_interhunkcontext },
    { "checks_options_version_too_low", &test_diff_blob__checks_options_version_too_low },
    { "checks_options_version_too_high", &test_diff_blob__checks_options_version_too_high },
    { "can_correctly_detect_a_binary_blob_as_binary", &test_diff_blob__can_correctly_detect_a_binary_blob_as_binary },
    { "can_correctly_detect_binary_blob_data_as_binary", &test_diff_blob__can_correctly_detect_binary_blob_data_as_binary },
    { "can_correctly_detect_a_textual_blob_as_non_binary", &test_diff_blob__can_correctly_detect_a_textual_blob_as_non_binary },
    { "can_correctly_detect_textual_blob_data_as_non_binary", &test_diff_blob__can_correctly_detect_textual_blob_data_as_non_binary },
    { "can_compare_blob_to_buffer", &test_diff_blob__can_compare_blob_to_buffer },
    { "can_compare_blob_to_buffer_with_patch", &test_diff_blob__can_compare_blob_to_buffer_with_patch },
    { "binary_data_comparisons", &test_diff_blob__binary_data_comparisons },
    { "using_path_and_attributes", &test_diff_blob__using_path_and_attributes },
    { "can_compare_buffer_to_buffer", &test_diff_blob__can_compare_buffer_to_buffer }
};
static const struct clar_func _clar_cb_diff_diffiter[] = {
    { "create", &test_diff_diffiter__create },
    { "iterate_files_1", &test_diff_diffiter__iterate_files_1 },
    { "iterate_files_2", &test_diff_diffiter__iterate_files_2 },
    { "iterate_files_and_hunks", &test_diff_diffiter__iterate_files_and_hunks },
    { "max_size_threshold", &test_diff_diffiter__max_size_threshold },
    { "iterate_all", &test_diff_diffiter__iterate_all },
    { "iterate_randomly_while_saving_state", &test_diff_diffiter__iterate_randomly_while_saving_state },
    { "iterate_and_generate_patch_text", &test_diff_diffiter__iterate_and_generate_patch_text },
    { "checks_options_version", &test_diff_diffiter__checks_options_version }
};
static const struct clar_func _clar_cb_diff_drivers[] = {
    { "patterns", &test_diff_drivers__patterns },
    { "long_lines", &test_diff_drivers__long_lines },
    { "builtins", &test_diff_drivers__builtins },
    { "invalid_pattern", &test_diff_drivers__invalid_pattern }
};
static const struct clar_func _clar_cb_diff_externalmodifications[] = {
    { "file_becomes_smaller", &test_diff_externalmodifications__file_becomes_smaller },
    { "file_becomes_empty", &test_diff_externalmodifications__file_becomes_empty },
    { "file_deleted", &test_diff_externalmodifications__file_deleted },
    { "empty_file_becomes_non_empty", &test_diff_externalmodifications__empty_file_becomes_non_empty }
};
static const struct clar_func _clar_cb_diff_format_email[] = {
    { "simple", &test_diff_format_email__simple },
    { "with_message", &test_diff_format_email__with_message },
    { "multiple", &test_diff_format_email__multiple },
    { "exclude_marker", &test_diff_format_email__exclude_marker },
    { "invalid_no", &test_diff_format_email__invalid_no },
    { "mode_change", &test_diff_format_email__mode_change },
    { "rename_add_remove", &test_diff_format_email__rename_add_remove },
    { "multiline_summary", &test_diff_format_email__multiline_summary },
    { "binary", &test_diff_format_email__binary }
};
static const struct clar_func _clar_cb_diff_index[] = {
    { "0", &test_diff_index__0 },
    { "1", &test_diff_index__1 },
    { "checks_options_version", &test_diff_index__checks_options_version },
    { "reports_conflicts", &test_diff_index__reports_conflicts },
    { "reports_conflicts_when_reversed", &test_diff_index__reports_conflicts_when_reversed },
    { "not_in_head_conflicted", &test_diff_index__not_in_head_conflicted },
    { "to_index", &test_diff_index__to_index }
};
static const struct clar_func _clar_cb_diff_notify[] = {
    { "notify_single_pathspec", &test_diff_notify__notify_single_pathspec },
    { "notify_multiple_pathspec", &test_diff_notify__notify_multiple_pathspec },
    { "notify_catchall_with_empty_pathspecs", &test_diff_notify__notify_catchall_with_empty_pathspecs },
    { "notify_catchall", &test_diff_notify__notify_catchall },
    { "notify_cb_can_abort_diff", &test_diff_notify__notify_cb_can_abort_diff },
    { "notify_cb_can_be_used_as_filtering_function", &test_diff_notify__notify_cb_can_be_used_as_filtering_function },
    { "progress_cb_can_abort_diff", &test_diff_notify__progress_cb_can_abort_diff }
};
static const struct clar_func _clar_cb_diff_parse[] = {
    { "nonpatches_fail_with_notfound", &test_diff_parse__nonpatches_fail_with_notfound },
    { "exact_rename", &test_diff_parse__exact_rename },
    { "empty_file", &test_diff_parse__empty_file },
    { "no_extended_headers", &test_diff_parse__no_extended_headers },
    { "add_delete_no_index", &test_diff_parse__add_delete_no_index },
    { "invalid_patches_fails", &test_diff_parse__invalid_patches_fails },
    { "can_parse_generated_diff", &test_diff_parse__can_parse_generated_diff },
    { "get_patch_from_diff", &test_diff_parse__get_patch_from_diff },
    { "eof_nl_missing", &test_diff_parse__eof_nl_missing },
    { "foreach_works_with_parsed_patch", &test_diff_parse__foreach_works_with_parsed_patch },
    { "parsing_minimal_patch_succeeds", &test_diff_parse__parsing_minimal_patch_succeeds },
    { "patch_roundtrip_succeeds", &test_diff_parse__patch_roundtrip_succeeds },
    { "issue4672", &test_diff_parse__issue4672 },
    { "lineinfo", &test_diff_parse__lineinfo },
    { "new_file_with_space", &test_diff_parse__new_file_with_space },
    { "new_file_with_space_and_regenerate_patch", &test_diff_parse__new_file_with_space_and_regenerate_patch },
    { "delete_file_with_space_and_regenerate_patch", &test_diff_parse__delete_file_with_space_and_regenerate_patch },
    { "crlf", &test_diff_parse__crlf }
};
static const struct clar_func _clar_cb_diff_patch[] = {
    { "can_properly_display_the_removal_of_a_file", &test_diff_patch__can_properly_display_the_removal_of_a_file },
    { "can_cancel_diff_print", &test_diff_patch__can_cancel_diff_print },
    { "to_string", &test_diff_patch__to_string },
    { "config_options", &test_diff_patch__config_options },
    { "hunks_have_correct_line_numbers", &test_diff_patch__hunks_have_correct_line_numbers },
    { "line_counts_with_eofnl", &test_diff_patch__line_counts_with_eofnl },
    { "can_strip_bad_utf8", &test_diff_patch__can_strip_bad_utf8 }
};
static const struct clar_func _clar_cb_diff_patchid[] = {
    { "simple_commit", &test_diff_patchid__simple_commit },
    { "deleted_file", &test_diff_patchid__deleted_file },
    { "created_file", &test_diff_patchid__created_file },
    { "binary_file", &test_diff_patchid__binary_file },
    { "renamed_file", &test_diff_patchid__renamed_file },
    { "modechange", &test_diff_patchid__modechange },
    { "shuffle_hunks", &test_diff_patchid__shuffle_hunks },
    { "filename_with_spaces", &test_diff_patchid__filename_with_spaces },
    { "multiple_hunks", &test_diff_patchid__multiple_hunks },
    { "multiple_files", &test_diff_patchid__multiple_files },
    { "same_diff_with_differing_whitespace_has_same_id", &test_diff_patchid__same_diff_with_differing_whitespace_has_same_id }
};
static const struct clar_func _clar_cb_diff_pathspec[] = {
    { "0", &test_diff_pathspec__0 }
};
static const struct clar_func _clar_cb_diff_racediffiter[] = {
    { "basic", &test_diff_racediffiter__basic },
    { "racy", &test_diff_racediffiter__racy }
};
static const struct clar_func _clar_cb_diff_rename[] = {
    { "match_oid", &test_diff_rename__match_oid },
    { "checks_options_version", &test_diff_rename__checks_options_version },
    { "not_exact_match", &test_diff_rename__not_exact_match },
    { "test_small_files", &test_diff_rename__test_small_files },
    { "working_directory_changes", &test_diff_rename__working_directory_changes },
    { "patch", &test_diff_rename__patch },
    { "file_exchange", &test_diff_rename__file_exchange },
    { "file_exchange_three", &test_diff_rename__file_exchange_three },
    { "file_partial_exchange", &test_diff_rename__file_partial_exchange },
    { "rename_and_copy_from_same_source", &test_diff_rename__rename_and_copy_from_same_source },
    { "from_deleted_to_split", &test_diff_rename__from_deleted_to_split },
    { "rejected_match_can_match_others", &test_diff_rename__rejected_match_can_match_others },
    { "rejected_match_can_match_others_two", &test_diff_rename__rejected_match_can_match_others_two },
    { "rejected_match_can_match_others_three", &test_diff_rename__rejected_match_can_match_others_three },
    { "can_rename_from_rewrite", &test_diff_rename__can_rename_from_rewrite },
    { "case_changes_are_split", &test_diff_rename__case_changes_are_split },
    { "unmodified_can_be_renamed", &test_diff_rename__unmodified_can_be_renamed },
    { "rewrite_on_single_file", &test_diff_rename__rewrite_on_single_file },
    { "can_find_copy_to_split", &test_diff_rename__can_find_copy_to_split },
    { "can_delete_unmodified_deltas", &test_diff_rename__can_delete_unmodified_deltas },
    { "can_delete_unmodified_deltas_including_submodule", &test_diff_rename__can_delete_unmodified_deltas_including_submodule },
    { "matches_config_behavior", &test_diff_rename__matches_config_behavior },
    { "can_override_thresholds_when_obeying_config", &test_diff_rename__can_override_thresholds_when_obeying_config },
    { "by_config_doesnt_mess_with_whitespace_settings", &test_diff_rename__by_config_doesnt_mess_with_whitespace_settings },
    { "empty_files_renamed", &test_diff_rename__empty_files_renamed },
    { "blank_files_renamed_when_ignoring_whitespace", &test_diff_rename__blank_files_renamed_when_ignoring_whitespace },
    { "blank_files_not_renamed_when_not_ignoring_whitespace", &test_diff_rename__blank_files_not_renamed_when_not_ignoring_whitespace },
    { "identical", &test_diff_rename__identical },
    { "rewrite_and_delete", &test_diff_rename__rewrite_and_delete },
    { "delete_and_rename", &test_diff_rename__delete_and_rename },
    { "break_rewrite", &test_diff_rename__break_rewrite }
};
static const struct clar_func _clar_cb_diff_stats[] = {
    { "stat", &test_diff_stats__stat },
    { "multiple_hunks", &test_diff_stats__multiple_hunks },
    { "numstat", &test_diff_stats__numstat },
    { "shortstat", &test_diff_stats__shortstat },
    { "shortstat_noinsertions", &test_diff_stats__shortstat_noinsertions },
    { "shortstat_nodeletions", &test_diff_stats__shortstat_nodeletions },
    { "rename", &test_diff_stats__rename },
    { "rename_nochanges", &test_diff_stats__rename_nochanges },
    { "rename_and_modifiy", &test_diff_stats__rename_and_modifiy },
    { "rename_in_subdirectory", &test_diff_stats__rename_in_subdirectory },
    { "rename_no_find", &test_diff_stats__rename_no_find },
    { "rename_nochanges_no_find", &test_diff_stats__rename_nochanges_no_find },
    { "rename_and_modify_no_find", &test_diff_stats__rename_and_modify_no_find },
    { "binary", &test_diff_stats__binary },
    { "binary_numstat", &test_diff_stats__binary_numstat },
    { "mode_change", &test_diff_stats__mode_change },
    { "new_file", &test_diff_stats__new_file }
};
static const struct clar_func _clar_cb_diff_submodules[] = {
    { "unmodified_submodule", &test_diff_submodules__unmodified_submodule },
    { "dirty_submodule", &test_diff_submodules__dirty_submodule },
    { "dirty_submodule_2", &test_diff_submodules__dirty_submodule_2 },
    { "submod2_index_to_wd", &test_diff_submodules__submod2_index_to_wd },
    { "submod2_head_to_index", &test_diff_submodules__submod2_head_to_index },
    { "invalid_cache", &test_diff_submodules__invalid_cache },
    { "diff_ignore_options", &test_diff_submodules__diff_ignore_options },
    { "skips_empty_includes_used", &test_diff_submodules__skips_empty_includes_used },
    { "can_be_identified_by_trailing_slash_in_pathspec", &test_diff_submodules__can_be_identified_by_trailing_slash_in_pathspec }
};
static const struct clar_func _clar_cb_diff_tree[] = {
    { "0", &test_diff_tree__0 },
    { "options", &test_diff_tree__options },
    { "bare", &test_diff_tree__bare },
    { "merge", &test_diff_tree__merge },
    { "larger_hunks", &test_diff_tree__larger_hunks },
    { "checks_options_version", &test_diff_tree__checks_options_version },
    { "symlink_blob_mode_changed_to_regular_file", &test_diff_tree__symlink_blob_mode_changed_to_regular_file },
    { "symlink_blob_mode_changed_to_regular_file_as_typechange", &test_diff_tree__symlink_blob_mode_changed_to_regular_file_as_typechange },
    { "regular_blob_mode_changed_to_executable_file", &test_diff_tree__regular_blob_mode_changed_to_executable_file },
    { "issue_1397", &test_diff_tree__issue_1397 },
    { "diff_configs", &test_diff_tree__diff_configs },
    { "diff_tree_with_empty_dir_entry_succeeds", &test_diff_tree__diff_tree_with_empty_dir_entry_succeeds }
};
static const struct clar_func _clar_cb_diff_userdiff[] = {
    { "compile_userdiff_regexps", &test_diff_userdiff__compile_userdiff_regexps }
};
static const struct clar_func _clar_cb_diff_workdir[] = {
    { "to_index", &test_diff_workdir__to_index },
    { "to_index_with_conflicts", &test_diff_workdir__to_index_with_conflicts },
    { "to_index_with_assume_unchanged", &test_diff_workdir__to_index_with_assume_unchanged },
    { "to_tree", &test_diff_workdir__to_tree },
    { "to_index_with_pathspec", &test_diff_workdir__to_index_with_pathspec },
    { "to_index_with_pathlist_disabling_fnmatch", &test_diff_workdir__to_index_with_pathlist_disabling_fnmatch },
    { "filemode_changes", &test_diff_workdir__filemode_changes },
    { "filemode_changes_with_filemode_false", &test_diff_workdir__filemode_changes_with_filemode_false },
    { "head_index_and_workdir_all_differ", &test_diff_workdir__head_index_and_workdir_all_differ },
    { "eof_newline_changes", &test_diff_workdir__eof_newline_changes },
    { "larger_hunks", &test_diff_workdir__larger_hunks },
    { "submodules", &test_diff_workdir__submodules },
    { "cannot_diff_against_a_bare_repository", &test_diff_workdir__cannot_diff_against_a_bare_repository },
    { "to_null_tree", &test_diff_workdir__to_null_tree },
    { "checks_options_version", &test_diff_workdir__checks_options_version },
    { "can_diff_empty_untracked_file", &test_diff_workdir__can_diff_empty_untracked_file },
    { "can_diff_empty_file", &test_diff_workdir__can_diff_empty_file },
    { "to_index_issue_1397", &test_diff_workdir__to_index_issue_1397 },
    { "to_tree_issue_1397", &test_diff_workdir__to_tree_issue_1397 },
    { "untracked_directory_scenarios", &test_diff_workdir__untracked_directory_scenarios },
    { "untracked_directory_comes_last", &test_diff_workdir__untracked_directory_comes_last },
    { "untracked_with_bom", &test_diff_workdir__untracked_with_bom },
    { "patience_diff", &test_diff_workdir__patience_diff },
    { "with_stale_index", &test_diff_workdir__with_stale_index },
    { "can_update_index", &test_diff_workdir__can_update_index },
    { "binary_detection", &test_diff_workdir__binary_detection },
    { "to_index_conflicted", &test_diff_workdir__to_index_conflicted },
    { "only_writes_index_when_necessary", &test_diff_workdir__only_writes_index_when_necessary },
    { "to_index_pathlist", &test_diff_workdir__to_index_pathlist },
    { "symlink_changed_on_non_symlink_platform", &test_diff_workdir__symlink_changed_on_non_symlink_platform },
    { "order", &test_diff_workdir__order },
    { "ignore_blank_lines", &test_diff_workdir__ignore_blank_lines },
    { "to_index_reversed_content_loads", &test_diff_workdir__to_index_reversed_content_loads },
    { "completely_ignored_shows_empty_diff", &test_diff_workdir__completely_ignored_shows_empty_diff }
};
static const struct clar_func _clar_cb_email_create[] = {
    { "commit", &test_email_create__commit },
    { "rename", &test_email_create__rename },
    { "rename_as_add_delete", &test_email_create__rename_as_add_delete },
    { "binary", &test_email_create__binary },
    { "binary_not_included", &test_email_create__binary_not_included },
    { "custom_summary_and_body", &test_email_create__custom_summary_and_body },
    { "commit_subjects", &test_email_create__commit_subjects }
};
static const struct clar_func _clar_cb_fetch_local[] = {
    { "defaults", &test_fetch_local__defaults },
    { "reachable_commit", &test_fetch_local__reachable_commit }
};
static const struct clar_func _clar_cb_fetchhead_nonetwork[] = {
    { "write", &test_fetchhead_nonetwork__write },
    { "read", &test_fetchhead_nonetwork__read },
    { "read_old_style", &test_fetchhead_nonetwork__read_old_style },
    { "type_missing", &test_fetchhead_nonetwork__type_missing },
    { "name_missing", &test_fetchhead_nonetwork__name_missing },
    { "nonexistent", &test_fetchhead_nonetwork__nonexistent },
    { "invalid_unterminated_last_line", &test_fetchhead_nonetwork__invalid_unterminated_last_line },
    { "invalid_oid", &test_fetchhead_nonetwork__invalid_oid },
    { "invalid_for_merge", &test_fetchhead_nonetwork__invalid_for_merge },
    { "invalid_description", &test_fetchhead_nonetwork__invalid_description },
    { "unborn_with_upstream", &test_fetchhead_nonetwork__unborn_with_upstream },
    { "fetch_into_repo_with_symrefs", &test_fetchhead_nonetwork__fetch_into_repo_with_symrefs },
    { "fetch_into_repo_with_invalid_head", &test_fetchhead_nonetwork__fetch_into_repo_with_invalid_head },
    { "quote_in_branch_name", &test_fetchhead_nonetwork__quote_in_branch_name },
    { "create_when_refpecs_given", &test_fetchhead_nonetwork__create_when_refpecs_given },
    { "create_with_multiple_refspecs", &test_fetchhead_nonetwork__create_with_multiple_refspecs },
    { "credentials_are_stripped", &test_fetchhead_nonetwork__credentials_are_stripped }
};
static const struct clar_func _clar_cb_filter_bare[] = {
    { "all_crlf", &test_filter_bare__all_crlf },
    { "from_lf", &test_filter_bare__from_lf },
    { "nested_attributes", &test_filter_bare__nested_attributes },
    { "sanitizes", &test_filter_bare__sanitizes },
    { "from_specific_commit_one", &test_filter_bare__from_specific_commit_one },
    { "from_specific_commit_with_no_attributes_file", &test_filter_bare__from_specific_commit_with_no_attributes_file }
};
static const struct clar_func _clar_cb_filter_blob[] = {
    { "all_crlf", &test_filter_blob__all_crlf },
    { "from_lf", &test_filter_blob__from_lf },
    { "sanitizes", &test_filter_blob__sanitizes },
    { "ident", &test_filter_blob__ident }
};
static const struct clar_func _clar_cb_filter_crlf[] = {
    { "to_worktree", &test_filter_crlf__to_worktree },
    { "to_odb", &test_filter_crlf__to_odb },
    { "with_safecrlf", &test_filter_crlf__with_safecrlf },
    { "with_safecrlf_and_unsafe_allowed", &test_filter_crlf__with_safecrlf_and_unsafe_allowed },
    { "no_safecrlf", &test_filter_crlf__no_safecrlf },
    { "safecrlf_warn", &test_filter_crlf__safecrlf_warn }
};
static const struct clar_func _clar_cb_filter_custom[] = {
    { "to_odb", &test_filter_custom__to_odb },
    { "to_workdir", &test_filter_custom__to_workdir },
    { "can_register_a_custom_filter_in_the_repository", &test_filter_custom__can_register_a_custom_filter_in_the_repository },
    { "order_dependency", &test_filter_custom__order_dependency },
    { "filter_registry_failure_cases", &test_filter_custom__filter_registry_failure_cases },
    { "erroneous_filter_fails", &test_filter_custom__erroneous_filter_fails }
};
static const struct clar_func _clar_cb_filter_file[] = {
    { "apply", &test_filter_file__apply },
    { "apply_stream", &test_filter_file__apply_stream }
};
static const struct clar_func _clar_cb_filter_ident[] = {
    { "to_worktree", &test_filter_ident__to_worktree },
    { "to_odb", &test_filter_ident__to_odb }
};
static const struct clar_func _clar_cb_filter_query[] = {
    { "filters", &test_filter_query__filters },
    { "autocrlf_true_implies_crlf", &test_filter_query__autocrlf_true_implies_crlf },
    { "unknown", &test_filter_query__unknown },
    { "custom", &test_filter_query__custom }
};
static const struct clar_func _clar_cb_filter_stream[] = {
    { "smallfile", &test_filter_stream__smallfile },
    { "bigfile", &test_filter_stream__bigfile }
};
static const struct clar_func _clar_cb_filter_systemattrs[] = {
    { "reads_system_attributes", &test_filter_systemattrs__reads_system_attributes },
    { "disables_system_attributes", &test_filter_systemattrs__disables_system_attributes }
};
static const struct clar_func _clar_cb_filter_wildcard[] = {
    { "reverse", &test_filter_wildcard__reverse },
    { "flip", &test_filter_wildcard__flip },
    { "none", &test_filter_wildcard__none }
};
static const struct clar_func _clar_cb_grafts_basic[] = {
    { "graft_add", &test_grafts_basic__graft_add },
    { "grafted_revwalk", &test_grafts_basic__grafted_revwalk },
    { "grafted_objects", &test_grafts_basic__grafted_objects },
    { "grafted_merge_revwalk", &test_grafts_basic__grafted_merge_revwalk }
};
static const struct clar_func _clar_cb_grafts_parse[] = {
    { "single_oid", &test_grafts_parse__single_oid },
    { "single_oid_with_newline", &test_grafts_parse__single_oid_with_newline },
    { "multiple_oids", &test_grafts_parse__multiple_oids },
    { "same_oid", &test_grafts_parse__same_oid },
    { "oid_with_parent", &test_grafts_parse__oid_with_parent },
    { "oid_with_parent_and_newline", &test_grafts_parse__oid_with_parent_and_newline },
    { "oid_with_multiple_parents", &test_grafts_parse__oid_with_multiple_parents },
    { "multiple_oids_with_multiple_parents", &test_grafts_parse__multiple_oids_with_multiple_parents },
    { "multiple_spaces_fails", &test_grafts_parse__multiple_spaces_fails },
    { "trailing_space_fails", &test_grafts_parse__trailing_space_fails },
    { "invalid_character_inbetween_fails", &test_grafts_parse__invalid_character_inbetween_fails },
    { "truncated_oid_fails", &test_grafts_parse__truncated_oid_fails },
    { "truncated_parent_fails", &test_grafts_parse__truncated_parent_fails },
    { "invalid_oid_fails", &test_grafts_parse__invalid_oid_fails },
    { "invalid_parent_fails", &test_grafts_parse__invalid_parent_fails }
};
static const struct clar_func _clar_cb_grafts_shallow[] = {
    { "no_shallow_file", &test_grafts_shallow__no_shallow_file },
    { "empty_shallow_file", &test_grafts_shallow__empty_shallow_file },
    { "shallow_repo", &test_grafts_shallow__shallow_repo },
    { "clears_errors", &test_grafts_shallow__clears_errors },
    { "shallow_oids", &test_grafts_shallow__shallow_oids },
    { "cache_clearing", &test_grafts_shallow__cache_clearing },
    { "errors_on_borked", &test_grafts_shallow__errors_on_borked },
    { "revwalk_behavior", &test_grafts_shallow__revwalk_behavior },
    { "grafted_object", &test_grafts_shallow__grafted_object }
};
static const struct clar_func _clar_cb_graph_ahead_behind[] = {
    { "returns_correct_result", &test_graph_ahead_behind__returns_correct_result }
};
static const struct clar_func _clar_cb_graph_commitgraph[] = {
    { "parse", &test_graph_commitgraph__parse },
    { "parse_octopus_merge", &test_graph_commitgraph__parse_octopus_merge },
    { "writer", &test_graph_commitgraph__writer },
    { "validate", &test_graph_commitgraph__validate },
    { "validate_corrupt", &test_graph_commitgraph__validate_corrupt }
};
static const struct clar_func _clar_cb_graph_descendant_of[] = {
    { "returns_correct_result", &test_graph_descendant_of__returns_correct_result },
    { "nopath", &test_graph_descendant_of__nopath }
};
static const struct clar_func _clar_cb_graph_reachable_from_any[] = {
    { "returns_correct_result", &test_graph_reachable_from_any__returns_correct_result },
    { "exhaustive", &test_graph_reachable_from_any__exhaustive }
};
static const struct clar_func _clar_cb_ignore_path[] = {
    { "honor_temporary_rules", &test_ignore_path__honor_temporary_rules },
    { "allow_root", &test_ignore_path__allow_root },
    { "ignore_space", &test_ignore_path__ignore_space },
    { "intermittent_space", &test_ignore_path__intermittent_space },
    { "trailing_space", &test_ignore_path__trailing_space },
    { "escaped_trailing_spaces", &test_ignore_path__escaped_trailing_spaces },
    { "ignore_dir", &test_ignore_path__ignore_dir },
    { "ignore_dir_with_trailing_space", &test_ignore_path__ignore_dir_with_trailing_space },
    { "ignore_root", &test_ignore_path__ignore_root },
    { "full_paths", &test_ignore_path__full_paths },
    { "more_starstar_cases", &test_ignore_path__more_starstar_cases },
    { "leading_stars", &test_ignore_path__leading_stars },
    { "globs_and_path_delimiters", &test_ignore_path__globs_and_path_delimiters },
    { "globs_without_star", &test_ignore_path__globs_without_star },
    { "skip_gitignore_directory", &test_ignore_path__skip_gitignore_directory },
    { "subdirectory_gitignore", &test_ignore_path__subdirectory_gitignore },
    { "expand_tilde_to_homedir", &test_ignore_path__expand_tilde_to_homedir },
    { "gitignore_in_subdir", &test_ignore_path__gitignore_in_subdir },
    { "dont_ignore_files_for_folder", &test_ignore_path__dont_ignore_files_for_folder },
    { "symlink_to_outside", &test_ignore_path__symlink_to_outside },
    { "test", &test_ignore_path__test },
    { "unignore_dir_succeeds", &test_ignore_path__unignore_dir_succeeds },
    { "case_insensitive_unignores_previous_rule", &test_ignore_path__case_insensitive_unignores_previous_rule },
    { "case_sensitive_unignore_does_nothing", &test_ignore_path__case_sensitive_unignore_does_nothing },
    { "ignored_subdirfiles_with_subdir_rule", &test_ignore_path__ignored_subdirfiles_with_subdir_rule },
    { "ignored_subdirfiles_with_negations", &test_ignore_path__ignored_subdirfiles_with_negations },
    { "negative_directory_rules_only_match_directories", &test_ignore_path__negative_directory_rules_only_match_directories },
    { "escaped_character", &test_ignore_path__escaped_character },
    { "escaped_newline", &test_ignore_path__escaped_newline },
    { "escaped_glob", &test_ignore_path__escaped_glob },
    { "escaped_comments", &test_ignore_path__escaped_comments },
    { "escaped_slash", &test_ignore_path__escaped_slash },
    { "escaped_space", &test_ignore_path__escaped_space },
    { "invalid_pattern", &test_ignore_path__invalid_pattern },
    { "negative_prefix_rule", &test_ignore_path__negative_prefix_rule },
    { "negative_more_specific", &test_ignore_path__negative_more_specific }
};
static const struct clar_func _clar_cb_ignore_status[] = {
    { "0", &test_ignore_status__0 },
    { "1", &test_ignore_status__1 },
    { "empty_repo_with_gitignore_rewrite", &test_ignore_status__empty_repo_with_gitignore_rewrite },
    { "ignore_pattern_contains_space", &test_ignore_status__ignore_pattern_contains_space },
    { "ignore_pattern_ignorecase", &test_ignore_status__ignore_pattern_ignorecase },
    { "subdirectories", &test_ignore_status__subdirectories },
    { "subdirectories_recursion", &test_ignore_status__subdirectories_recursion },
    { "subdirectories_not_at_root", &test_ignore_status__subdirectories_not_at_root },
    { "leading_slash_ignores", &test_ignore_status__leading_slash_ignores },
    { "multiple_leading_slash", &test_ignore_status__multiple_leading_slash },
    { "contained_dir_with_matching_name", &test_ignore_status__contained_dir_with_matching_name },
    { "trailing_slash_star", &test_ignore_status__trailing_slash_star },
    { "adding_internal_ignores", &test_ignore_status__adding_internal_ignores },
    { "add_internal_as_first_thing", &test_ignore_status__add_internal_as_first_thing },
    { "internal_ignores_inside_deep_paths", &test_ignore_status__internal_ignores_inside_deep_paths },
    { "automatically_ignore_bad_files", &test_ignore_status__automatically_ignore_bad_files },
    { "filenames_with_special_prefixes_do_not_interfere_with_status_retrieval", &test_ignore_status__filenames_with_special_prefixes_do_not_interfere_with_status_retrieval },
    { "issue_1766_negated_ignores", &test_ignore_status__issue_1766_negated_ignores },
    { "more_breakage", &test_ignore_status__more_breakage },
    { "negative_ignores_inside_ignores", &test_ignore_status__negative_ignores_inside_ignores },
    { "negative_ignores_in_slash_star", &test_ignore_status__negative_ignores_in_slash_star },
    { "negative_ignores_without_trailing_slash_inside_ignores", &test_ignore_status__negative_ignores_without_trailing_slash_inside_ignores },
    { "negative_directory_ignores", &test_ignore_status__negative_directory_ignores },
    { "unignore_entry_in_ignored_dir", &test_ignore_status__unignore_entry_in_ignored_dir },
    { "do_not_unignore_basename_prefix", &test_ignore_status__do_not_unignore_basename_prefix },
    { "filename_with_cr", &test_ignore_status__filename_with_cr },
    { "subdir_doesnt_match_above", &test_ignore_status__subdir_doesnt_match_above },
    { "negate_exact_previous", &test_ignore_status__negate_exact_previous },
    { "negate_starstar", &test_ignore_status__negate_starstar },
    { "ignore_all_toplevel_dirs_include_files", &test_ignore_status__ignore_all_toplevel_dirs_include_files },
    { "subdir_ignore_all_toplevel_dirs_include_files", &test_ignore_status__subdir_ignore_all_toplevel_dirs_include_files },
    { "subdir_ignore_everything_except_certain_files", &test_ignore_status__subdir_ignore_everything_except_certain_files },
    { "deeper", &test_ignore_status__deeper },
    { "unignored_dir_with_ignored_contents", &test_ignore_status__unignored_dir_with_ignored_contents },
    { "unignored_subdirs", &test_ignore_status__unignored_subdirs },
    { "skips_bom", &test_ignore_status__skips_bom },
    { "leading_spaces_are_significant", &test_ignore_status__leading_spaces_are_significant },
    { "override_nested_wildcard_unignore", &test_ignore_status__override_nested_wildcard_unignore }
};
static const struct clar_func _clar_cb_index_add[] = {
    { "invalid_entries_succeeds_by_default", &test_index_add__invalid_entries_succeeds_by_default },
    { "two_slash_prefixed", &test_index_add__two_slash_prefixed }
};
static const struct clar_func _clar_cb_index_addall[] = {
    { "repo_lifecycle", &test_index_addall__repo_lifecycle },
    { "files_in_folders", &test_index_addall__files_in_folders },
    { "hidden_files", &test_index_addall__hidden_files },
    { "callback_filtering", &test_index_addall__callback_filtering },
    { "handles_ignored_files_in_directory", &test_index_addall__handles_ignored_files_in_directory },
    { "force_adds_ignored_directories", &test_index_addall__force_adds_ignored_directories },
    { "adds_conflicts", &test_index_addall__adds_conflicts },
    { "removes_deleted_conflicted_files", &test_index_addall__removes_deleted_conflicted_files }
};
static const struct clar_func _clar_cb_index_bypath[] = {
    { "add_directory", &test_index_bypath__add_directory },
    { "add_submodule", &test_index_bypath__add_submodule },
    { "add_submodule_unregistered", &test_index_bypath__add_submodule_unregistered },
    { "add_hidden", &test_index_bypath__add_hidden },
    { "add_keeps_existing_case", &test_index_bypath__add_keeps_existing_case },
    { "add_honors_existing_case", &test_index_bypath__add_honors_existing_case },
    { "add_honors_existing_case_2", &test_index_bypath__add_honors_existing_case_2 },
    { "add_honors_existing_case_3", &test_index_bypath__add_honors_existing_case_3 },
    { "add_honors_existing_case_4", &test_index_bypath__add_honors_existing_case_4 },
    { "add_honors_mode", &test_index_bypath__add_honors_mode },
    { "add_honors_conflict_mode", &test_index_bypath__add_honors_conflict_mode },
    { "add_honors_conflict_case", &test_index_bypath__add_honors_conflict_case },
    { "add_honors_symlink", &test_index_bypath__add_honors_symlink }
};
static const struct clar_func _clar_cb_index_cache[] = {
    { "write_extension_at_root", &test_index_cache__write_extension_at_root },
    { "write_extension_invalidated_root", &test_index_cache__write_extension_invalidated_root },
    { "read_tree_no_children", &test_index_cache__read_tree_no_children },
    { "two_levels", &test_index_cache__two_levels },
    { "read_tree_children", &test_index_cache__read_tree_children }
};
static const struct clar_func _clar_cb_index_collision[] = {
    { "add_blob_with_conflicting_file", &test_index_collision__add_blob_with_conflicting_file },
    { "add_blob_with_conflicting_dir", &test_index_collision__add_blob_with_conflicting_dir },
    { "add_with_highstage_1", &test_index_collision__add_with_highstage_1 },
    { "add_with_highstage_2", &test_index_collision__add_with_highstage_2 }
};
static const struct clar_func _clar_cb_index_conflicts[] = {
    { "add", &test_index_conflicts__add },
    { "add_fixes_incorrect_stage", &test_index_conflicts__add_fixes_incorrect_stage },
    { "add_detects_invalid_filemode", &test_index_conflicts__add_detects_invalid_filemode },
    { "add_removes_stage_zero", &test_index_conflicts__add_removes_stage_zero },
    { "get", &test_index_conflicts__get },
    { "iterate", &test_index_conflicts__iterate },
    { "remove", &test_index_conflicts__remove },
    { "moved_to_reuc_on_add", &test_index_conflicts__moved_to_reuc_on_add },
    { "moved_to_reuc_on_remove", &test_index_conflicts__moved_to_reuc_on_remove },
    { "remove_all_conflicts", &test_index_conflicts__remove_all_conflicts },
    { "partial", &test_index_conflicts__partial },
    { "case_matters", &test_index_conflicts__case_matters }
};
static const struct clar_func _clar_cb_index_crlf[] = {
    { "matches_core_git", &test_index_crlf__matches_core_git },
    { "autocrlf_false_no_attrs", &test_index_crlf__autocrlf_false_no_attrs },
    { "autocrlf_true_no_attrs", &test_index_crlf__autocrlf_true_no_attrs },
    { "autocrlf_input_no_attrs", &test_index_crlf__autocrlf_input_no_attrs },
    { "autocrlf_false_text_auto_attr", &test_index_crlf__autocrlf_false_text_auto_attr },
    { "autocrlf_true_text_auto_attr", &test_index_crlf__autocrlf_true_text_auto_attr },
    { "autocrlf_input_text_auto_attr", &test_index_crlf__autocrlf_input_text_auto_attr },
    { "safecrlf_true_autocrlf_input_text_auto_attr", &test_index_crlf__safecrlf_true_autocrlf_input_text_auto_attr },
    { "safecrlf_true_autocrlf_input_text__no_attr", &test_index_crlf__safecrlf_true_autocrlf_input_text__no_attr },
    { "safecrlf_true_no_attrs", &test_index_crlf__safecrlf_true_no_attrs }
};
static const struct clar_func _clar_cb_index_filemodes[] = {
    { "read", &test_index_filemodes__read },
    { "untrusted", &test_index_filemodes__untrusted },
    { "trusted", &test_index_filemodes__trusted },
    { "explicit", &test_index_filemodes__explicit },
    { "invalid", &test_index_filemodes__invalid },
    { "frombuffer_requires_files", &test_index_filemodes__frombuffer_requires_files }
};
static const struct clar_func _clar_cb_index_inmemory[] = {
    { "can_create_an_inmemory_index", &test_index_inmemory__can_create_an_inmemory_index },
    { "cannot_add_bypath_to_an_inmemory_index", &test_index_inmemory__cannot_add_bypath_to_an_inmemory_index }
};
static const struct clar_func _clar_cb_index_names[] = {
    { "add", &test_index_names__add },
    { "roundtrip", &test_index_names__roundtrip },
    { "cleaned_on_reset_hard", &test_index_names__cleaned_on_reset_hard },
    { "cleaned_on_reset_mixed", &test_index_names__cleaned_on_reset_mixed },
    { "cleaned_on_checkout_tree", &test_index_names__cleaned_on_checkout_tree },
    { "cleaned_on_checkout_head", &test_index_names__cleaned_on_checkout_head },
    { "retained_on_checkout_index", &test_index_names__retained_on_checkout_index }
};
static const struct clar_func _clar_cb_index_nsec[] = {
    { "has_nanos", &test_index_nsec__has_nanos },
    { "staging_maintains_other_nanos", &test_index_nsec__staging_maintains_other_nanos },
    { "status_doesnt_clear_nsecs", &test_index_nsec__status_doesnt_clear_nsecs }
};
static const struct clar_func _clar_cb_index_racy[] = {
    { "diff", &test_index_racy__diff },
    { "write_index_just_after_file", &test_index_racy__write_index_just_after_file },
    { "smudges_index_entry_on_save", &test_index_racy__smudges_index_entry_on_save },
    { "detects_diff_of_change_in_identical_timestamp", &test_index_racy__detects_diff_of_change_in_identical_timestamp },
    { "adding_to_index_is_uptodate", &test_index_racy__adding_to_index_is_uptodate },
    { "reading_clears_uptodate_bit", &test_index_racy__reading_clears_uptodate_bit },
    { "read_tree_clears_uptodate_bit", &test_index_racy__read_tree_clears_uptodate_bit },
    { "read_index_smudges", &test_index_racy__read_index_smudges },
    { "read_index_clears_uptodate_bit", &test_index_racy__read_index_clears_uptodate_bit }
};
static const struct clar_func _clar_cb_index_read_index[] = {
    { "maintains_stat_cache", &test_index_read_index__maintains_stat_cache },
    { "produces_treesame_indexes", &test_index_read_index__produces_treesame_indexes },
    { "read_and_writes", &test_index_read_index__read_and_writes },
    { "handles_conflicts", &test_index_read_index__handles_conflicts }
};
static const struct clar_func _clar_cb_index_read_tree[] = {
    { "read_write_involution", &test_index_read_tree__read_write_involution }
};
static const struct clar_func _clar_cb_index_rename[] = {
    { "single_file", &test_index_rename__single_file },
    { "casechanging", &test_index_rename__casechanging }
};
static const struct clar_func _clar_cb_index_reuc[] = {
    { "add", &test_index_reuc__add },
    { "add_no_ancestor", &test_index_reuc__add_no_ancestor },
    { "read_bypath", &test_index_reuc__read_bypath },
    { "ignore_case", &test_index_reuc__ignore_case },
    { "read_byindex", &test_index_reuc__read_byindex },
    { "updates_existing", &test_index_reuc__updates_existing },
    { "remove", &test_index_reuc__remove },
    { "write", &test_index_reuc__write },
    { "cleaned_on_reset_hard", &test_index_reuc__cleaned_on_reset_hard },
    { "cleaned_on_reset_mixed", &test_index_reuc__cleaned_on_reset_mixed },
    { "retained_on_reset_soft", &test_index_reuc__retained_on_reset_soft },
    { "cleaned_on_checkout_tree", &test_index_reuc__cleaned_on_checkout_tree },
    { "cleaned_on_checkout_head", &test_index_reuc__cleaned_on_checkout_head },
    { "retained_on_checkout_index", &test_index_reuc__retained_on_checkout_index }
};
static const struct clar_func _clar_cb_index_splitindex[] = {
    { "fail_on_open", &test_index_splitindex__fail_on_open }
};
static const struct clar_func _clar_cb_index_stage[] = {
    { "add_always_adds_stage_0", &test_index_stage__add_always_adds_stage_0 },
    { "find_gets_first_stage", &test_index_stage__find_gets_first_stage }
};
static const struct clar_func _clar_cb_index_tests[] = {
    { "empty_index", &test_index_tests__empty_index },
    { "default_test_index", &test_index_tests__default_test_index },
    { "gitgit_index", &test_index_tests__gitgit_index },
    { "find_in_existing", &test_index_tests__find_in_existing },
    { "find_in_empty", &test_index_tests__find_in_empty },
    { "find_prefix", &test_index_tests__find_prefix },
    { "write", &test_index_tests__write },
    { "sort0", &test_index_tests__sort0 },
    { "sort1", &test_index_tests__sort1 },
    { "add", &test_index_tests__add },
    { "add_frombuffer", &test_index_tests__add_frombuffer },
    { "dirty_and_clean", &test_index_tests__dirty_and_clean },
    { "dirty_fails_optionally", &test_index_tests__dirty_fails_optionally },
    { "add_frombuffer_reset_entry", &test_index_tests__add_frombuffer_reset_entry },
    { "add_issue_1397", &test_index_tests__add_issue_1397 },
    { "add_bypath_to_a_bare_repository_returns_EBAREPO", &test_index_tests__add_bypath_to_a_bare_repository_returns_EBAREPO },
    { "cannot_add_invalid_filename", &test_index_tests__cannot_add_invalid_filename },
    { "cannot_add_protected_invalid_filename", &test_index_tests__cannot_add_protected_invalid_filename },
    { "write_tree_invalid_unowned_index", &test_index_tests__write_tree_invalid_unowned_index },
    { "write_invalid_filename", &test_index_tests__write_invalid_filename },
    { "honors_protect_filesystems", &test_index_tests__honors_protect_filesystems },
    { "protectntfs_on_by_default", &test_index_tests__protectntfs_on_by_default },
    { "can_disable_protectntfs", &test_index_tests__can_disable_protectntfs },
    { "remove_entry", &test_index_tests__remove_entry },
    { "remove_directory", &test_index_tests__remove_directory },
    { "preserves_case", &test_index_tests__preserves_case },
    { "elocked", &test_index_tests__elocked },
    { "reload_from_disk", &test_index_tests__reload_from_disk },
    { "corrupted_extension", &test_index_tests__corrupted_extension },
    { "reload_while_ignoring_case", &test_index_tests__reload_while_ignoring_case },
    { "change_icase_on_instance", &test_index_tests__change_icase_on_instance },
    { "can_lock_index", &test_index_tests__can_lock_index },
    { "can_iterate", &test_index_tests__can_iterate },
    { "can_modify_while_iterating", &test_index_tests__can_modify_while_iterating }
};
static const struct clar_func _clar_cb_index_tests256[] = {
    { "empty_index", &test_index_tests256__empty_index },
    { "default_test_index", &test_index_tests256__default_test_index },
    { "find_in_existing", &test_index_tests256__find_in_existing },
    { "find_in_empty", &test_index_tests256__find_in_empty },
    { "find_prefix", &test_index_tests256__find_prefix },
    { "write", &test_index_tests256__write },
    { "sort1", &test_index_tests256__sort1 },
    { "add", &test_index_tests256__add },
    { "add_frombuffer", &test_index_tests256__add_frombuffer },
    { "dirty_and_clean", &test_index_tests256__dirty_and_clean },
    { "dirty_fails_optionally", &test_index_tests256__dirty_fails_optionally },
    { "add_frombuffer_reset_entry", &test_index_tests256__add_frombuffer_reset_entry },
    { "add_bypath_to_a_bare_repository_returns_EBAREPO", &test_index_tests256__add_bypath_to_a_bare_repository_returns_EBAREPO },
    { "cannot_add_invalid_filename", &test_index_tests256__cannot_add_invalid_filename },
    { "cannot_add_protected_invalid_filename", &test_index_tests256__cannot_add_protected_invalid_filename },
    { "write_tree_invalid_unowned_index", &test_index_tests256__write_tree_invalid_unowned_index },
    { "write_invalid_filename", &test_index_tests256__write_invalid_filename },
    { "honors_protect_filesystems", &test_index_tests256__honors_protect_filesystems },
    { "protectntfs_on_by_default", &test_index_tests256__protectntfs_on_by_default },
    { "can_disable_protectntfs", &test_index_tests256__can_disable_protectntfs },
    { "remove_entry", &test_index_tests256__remove_entry },
    { "remove_directory", &test_index_tests256__remove_directory },
    { "preserves_case", &test_index_tests256__preserves_case },
    { "elocked", &test_index_tests256__elocked },
    { "reload_from_disk", &test_index_tests256__reload_from_disk },
    { "reload_while_ignoring_case", &test_index_tests256__reload_while_ignoring_case },
    { "change_icase_on_instance", &test_index_tests256__change_icase_on_instance },
    { "can_lock_index", &test_index_tests256__can_lock_index },
    { "can_iterate", &test_index_tests256__can_iterate },
    { "can_modify_while_iterating", &test_index_tests256__can_modify_while_iterating }
};
static const struct clar_func _clar_cb_index_version[] = {
    { "can_read_v4", &test_index_version__can_read_v4 },
    { "can_write_v4", &test_index_version__can_write_v4 },
    { "v4_uses_path_compression", &test_index_version__v4_uses_path_compression }
};
static const struct clar_func _clar_cb_iterator_index[] = {
    { "0", &test_iterator_index__0 },
    { "1", &test_iterator_index__1 },
    { "range", &test_iterator_index__range },
    { "range_empty_0", &test_iterator_index__range_empty_0 },
    { "range_empty_1", &test_iterator_index__range_empty_1 },
    { "range_empty_2", &test_iterator_index__range_empty_2 },
    { "range_icase", &test_iterator_index__range_icase },
    { "case_folding", &test_iterator_index__case_folding },
    { "icase_0", &test_iterator_index__icase_0 },
    { "icase_1", &test_iterator_index__icase_1 },
    { "pathlist", &test_iterator_index__pathlist },
    { "pathlist_with_dirs", &test_iterator_index__pathlist_with_dirs },
    { "pathlist_with_dirs_include_trees", &test_iterator_index__pathlist_with_dirs_include_trees },
    { "pathlist_1", &test_iterator_index__pathlist_1 },
    { "pathlist_2", &test_iterator_index__pathlist_2 },
    { "pathlist_four", &test_iterator_index__pathlist_four },
    { "pathlist_icase", &test_iterator_index__pathlist_icase },
    { "pathlist_with_directory", &test_iterator_index__pathlist_with_directory },
    { "pathlist_for_deeply_nested_item", &test_iterator_index__pathlist_for_deeply_nested_item },
    { "advance_over", &test_iterator_index__advance_over },
    { "advance_into", &test_iterator_index__advance_into },
    { "advance_into_and_over", &test_iterator_index__advance_into_and_over },
    { "include_conflicts", &test_iterator_index__include_conflicts }
};
static const struct clar_func _clar_cb_iterator_tree[] = {
    { "0", &test_iterator_tree__0 },
    { "1", &test_iterator_tree__1 },
    { "2", &test_iterator_tree__2 },
    { "3", &test_iterator_tree__3 },
    { "4", &test_iterator_tree__4 },
    { "4_ranged", &test_iterator_tree__4_ranged },
    { "ranged_0", &test_iterator_tree__ranged_0 },
    { "ranged_1", &test_iterator_tree__ranged_1 },
    { "range_empty_0", &test_iterator_tree__range_empty_0 },
    { "range_empty_1", &test_iterator_tree__range_empty_1 },
    { "range_empty_2", &test_iterator_tree__range_empty_2 },
    { "special_functions", &test_iterator_tree__special_functions },
    { "range_icase", &test_iterator_tree__range_icase },
    { "icase_0", &test_iterator_tree__icase_0 },
    { "icase_1", &test_iterator_tree__icase_1 },
    { "icase_2", &test_iterator_tree__icase_2 },
    { "case_conflicts_0", &test_iterator_tree__case_conflicts_0 },
    { "case_conflicts_1", &test_iterator_tree__case_conflicts_1 },
    { "case_conflicts_2", &test_iterator_tree__case_conflicts_2 },
    { "pathlist", &test_iterator_tree__pathlist },
    { "pathlist_icase", &test_iterator_tree__pathlist_icase },
    { "pathlist_with_directory", &test_iterator_tree__pathlist_with_directory },
    { "pathlist_with_directory_include_tree_nodes", &test_iterator_tree__pathlist_with_directory_include_tree_nodes },
    { "pathlist_no_match", &test_iterator_tree__pathlist_no_match }
};
static const struct clar_func _clar_cb_iterator_workdir[] = {
    { "0", &test_iterator_workdir__0 },
    { "1", &test_iterator_workdir__1 },
    { "1_ranged_0", &test_iterator_workdir__1_ranged_0 },
    { "1_ranged_1", &test_iterator_workdir__1_ranged_1 },
    { "1_ranged_3", &test_iterator_workdir__1_ranged_3 },
    { "1_ranged_4", &test_iterator_workdir__1_ranged_4 },
    { "1_ranged_5", &test_iterator_workdir__1_ranged_5 },
    { "1_ranged_5_1_ranged_empty_0", &test_iterator_workdir__1_ranged_5_1_ranged_empty_0 },
    { "1_ranged_empty_1", &test_iterator_workdir__1_ranged_empty_1 },
    { "1_ranged_empty_2", &test_iterator_workdir__1_ranged_empty_2 },
    { "builtin_ignores", &test_iterator_workdir__builtin_ignores },
    { "handles_icase_range", &test_iterator_workdir__handles_icase_range },
    { "icase", &test_iterator_workdir__icase },
    { "icase_starts_and_ends", &test_iterator_workdir__icase_starts_and_ends },
    { "depth", &test_iterator_workdir__depth },
    { "filesystem", &test_iterator_workdir__filesystem },
    { "filesystem2", &test_iterator_workdir__filesystem2 },
    { "filesystem_gunk", &test_iterator_workdir__filesystem_gunk },
    { "skips_unreadable_dirs", &test_iterator_workdir__skips_unreadable_dirs },
    { "skips_fifos_and_special_files", &test_iterator_workdir__skips_fifos_and_special_files },
    { "pathlist", &test_iterator_workdir__pathlist },
    { "pathlist_with_dirs", &test_iterator_workdir__pathlist_with_dirs },
    { "pathlist_for_deeply_nested_item", &test_iterator_workdir__pathlist_for_deeply_nested_item },
    { "bounded_submodules", &test_iterator_workdir__bounded_submodules },
    { "advance_over", &test_iterator_workdir__advance_over },
    { "advance_over_with_pathlist", &test_iterator_workdir__advance_over_with_pathlist },
    { "advance_into", &test_iterator_workdir__advance_into },
    { "pathlist_with_directory", &test_iterator_workdir__pathlist_with_directory },
    { "pathlist_with_directory_include_trees", &test_iterator_workdir__pathlist_with_directory_include_trees },
    { "hash_when_requested", &test_iterator_workdir__hash_when_requested }
};
static const struct clar_func _clar_cb_mailmap_basic[] = {
    { "entry", &test_mailmap_basic__entry },
    { "lookup_not_found", &test_mailmap_basic__lookup_not_found },
    { "lookup", &test_mailmap_basic__lookup },
    { "empty_email_query", &test_mailmap_basic__empty_email_query },
    { "name_matching", &test_mailmap_basic__name_matching }
};
static const struct clar_func _clar_cb_mailmap_blame[] = {
    { "hunks", &test_mailmap_blame__hunks },
    { "hunks_no_mailmap", &test_mailmap_blame__hunks_no_mailmap }
};
static const struct clar_func _clar_cb_mailmap_parsing[] = {
    { "string", &test_mailmap_parsing__string },
    { "windows_string", &test_mailmap_parsing__windows_string },
    { "fromrepo", &test_mailmap_parsing__fromrepo },
    { "frombare", &test_mailmap_parsing__frombare },
    { "file_config", &test_mailmap_parsing__file_config },
    { "blob_config", &test_mailmap_parsing__blob_config },
    { "bare_blob_config", &test_mailmap_parsing__bare_blob_config }
};
static const struct clar_func _clar_cb_merge_analysis[] = {
    { "fastforward", &test_merge_analysis__fastforward },
    { "no_fastforward", &test_merge_analysis__no_fastforward },
    { "uptodate", &test_merge_analysis__uptodate },
    { "uptodate_merging_prev_commit", &test_merge_analysis__uptodate_merging_prev_commit },
    { "unborn", &test_merge_analysis__unborn },
    { "fastforward_with_config_noff", &test_merge_analysis__fastforward_with_config_noff },
    { "no_fastforward_with_config_ffonly", &test_merge_analysis__no_fastforward_with_config_ffonly },
    { "between_uptodate_refs", &test_merge_analysis__between_uptodate_refs },
    { "between_noff_refs", &test_merge_analysis__between_noff_refs }
};
static const struct clar_func _clar_cb_merge_annotated_commit[] = {
    { "lookup_annotated_tag", &test_merge_annotated_commit__lookup_annotated_tag }
};
static const struct clar_func _clar_cb_merge_driver[] = {
    { "custom", &test_merge_driver__custom },
    { "wildcard", &test_merge_driver__wildcard },
    { "shutdown_is_called", &test_merge_driver__shutdown_is_called },
    { "apply_can_defer", &test_merge_driver__apply_can_defer },
    { "apply_can_conflict", &test_merge_driver__apply_can_conflict },
    { "default_can_be_specified", &test_merge_driver__default_can_be_specified },
    { "honors_builtin_mergedefault", &test_merge_driver__honors_builtin_mergedefault },
    { "honors_custom_mergedefault", &test_merge_driver__honors_custom_mergedefault },
    { "mergedefault_deferring_falls_back_to_text", &test_merge_driver__mergedefault_deferring_falls_back_to_text },
    { "set_forces_text", &test_merge_driver__set_forces_text },
    { "unset_forces_binary", &test_merge_driver__unset_forces_binary },
    { "not_configured_driver_falls_back", &test_merge_driver__not_configured_driver_falls_back }
};
static const struct clar_func _clar_cb_merge_files[] = {
    { "automerge_from_bufs", &test_merge_files__automerge_from_bufs },
    { "automerge_use_best_path_and_mode", &test_merge_files__automerge_use_best_path_and_mode },
    { "conflict_from_bufs", &test_merge_files__conflict_from_bufs },
    { "automerge_from_index", &test_merge_files__automerge_from_index },
    { "automerge_whitespace_eol", &test_merge_files__automerge_whitespace_eol },
    { "automerge_whitespace_change", &test_merge_files__automerge_whitespace_change },
    { "doesnt_add_newline", &test_merge_files__doesnt_add_newline },
    { "skips_large_files", &test_merge_files__skips_large_files },
    { "skips_binaries", &test_merge_files__skips_binaries },
    { "handles_binaries_when_favored", &test_merge_files__handles_binaries_when_favored },
    { "crlf_conflict_markers_for_crlf_files", &test_merge_files__crlf_conflict_markers_for_crlf_files },
    { "conflicts_in_zdiff3", &test_merge_files__conflicts_in_zdiff3 }
};
static const struct clar_func _clar_cb_merge_trees_automerge[] = {
    { "automerge", &test_merge_trees_automerge__automerge },
    { "favor_ours", &test_merge_trees_automerge__favor_ours },
    { "favor_theirs", &test_merge_trees_automerge__favor_theirs },
    { "unrelated", &test_merge_trees_automerge__unrelated }
};
static const struct clar_func _clar_cb_merge_trees_commits[] = {
    { "automerge", &test_merge_trees_commits__automerge },
    { "no_ancestor", &test_merge_trees_commits__no_ancestor },
    { "df_conflict", &test_merge_trees_commits__df_conflict },
    { "fail_on_conflict", &test_merge_trees_commits__fail_on_conflict }
};
static const struct clar_func _clar_cb_merge_trees_modeconflict[] = {
    { "df_conflict", &test_merge_trees_modeconflict__df_conflict }
};
static const struct clar_func _clar_cb_merge_trees_recursive[] = {
    { "one_base_commit", &test_merge_trees_recursive__one_base_commit },
    { "one_base_commit_norecursive", &test_merge_trees_recursive__one_base_commit_norecursive },
    { "two_base_commits", &test_merge_trees_recursive__two_base_commits },
    { "two_base_commits_norecursive", &test_merge_trees_recursive__two_base_commits_norecursive },
    { "two_levels_of_multiple_bases", &test_merge_trees_recursive__two_levels_of_multiple_bases },
    { "two_levels_of_multiple_bases_norecursive", &test_merge_trees_recursive__two_levels_of_multiple_bases_norecursive },
    { "three_levels_of_multiple_bases", &test_merge_trees_recursive__three_levels_of_multiple_bases },
    { "three_levels_of_multiple_bases_norecursive", &test_merge_trees_recursive__three_levels_of_multiple_bases_norecursive },
    { "three_base_commits", &test_merge_trees_recursive__three_base_commits },
    { "three_base_commits_norecursive", &test_merge_trees_recursive__three_base_commits_norecursive },
    { "conflict", &test_merge_trees_recursive__conflict },
    { "oh_so_many_levels_of_recursion", &test_merge_trees_recursive__oh_so_many_levels_of_recursion },
    { "conflicting_merge_base", &test_merge_trees_recursive__conflicting_merge_base },
    { "conflicting_merge_base_with_diff3", &test_merge_trees_recursive__conflicting_merge_base_with_diff3 },
    { "conflicting_merge_base_since_resolved", &test_merge_trees_recursive__conflicting_merge_base_since_resolved },
    { "recursionlimit", &test_merge_trees_recursive__recursionlimit },
    { "merge_base_for_virtual_commit", &test_merge_trees_recursive__merge_base_for_virtual_commit },
    { "merge_base_for_virtual_commit_2", &test_merge_trees_recursive__merge_base_for_virtual_commit_2 }
};
static const struct clar_func _clar_cb_merge_trees_renames[] = {
    { "index", &test_merge_trees_renames__index },
    { "no_rename_index", &test_merge_trees_renames__no_rename_index },
    { "submodules", &test_merge_trees_renames__submodules },
    { "cache_recomputation", &test_merge_trees_renames__cache_recomputation },
    { "emptyfile_renames", &test_merge_trees_renames__emptyfile_renames }
};
static const struct clar_func _clar_cb_merge_trees_treediff[] = {
    { "simple", &test_merge_trees_treediff__simple },
    { "df_conflicts", &test_merge_trees_treediff__df_conflicts },
    { "strict_renames", &test_merge_trees_treediff__strict_renames },
    { "rename_conflicts", &test_merge_trees_treediff__rename_conflicts },
    { "best_renames", &test_merge_trees_treediff__best_renames }
};
static const struct clar_func _clar_cb_merge_trees_trivial[] = {
    { "2alt", &test_merge_trees_trivial__2alt },
    { "3alt", &test_merge_trees_trivial__3alt },
    { "4", &test_merge_trees_trivial__4 },
    { "5alt_1", &test_merge_trees_trivial__5alt_1 },
    { "5alt_2", &test_merge_trees_trivial__5alt_2 },
    { "6", &test_merge_trees_trivial__6 },
    { "8", &test_merge_trees_trivial__8 },
    { "7", &test_merge_trees_trivial__7 },
    { "10", &test_merge_trees_trivial__10 },
    { "9", &test_merge_trees_trivial__9 },
    { "13", &test_merge_trees_trivial__13 },
    { "14", &test_merge_trees_trivial__14 },
    { "11", &test_merge_trees_trivial__11 }
};
static const struct clar_func _clar_cb_merge_trees_whitespace[] = {
    { "conflict", &test_merge_trees_whitespace__conflict },
    { "eol", &test_merge_trees_whitespace__eol },
    { "change", &test_merge_trees_whitespace__change }
};
static const struct clar_func _clar_cb_merge_workdir_dirty[] = {
    { "unaffected_dirty_files_allowed", &test_merge_workdir_dirty__unaffected_dirty_files_allowed },
    { "unstaged_deletes_maintained", &test_merge_workdir_dirty__unstaged_deletes_maintained },
    { "affected_dirty_files_disallowed", &test_merge_workdir_dirty__affected_dirty_files_disallowed },
    { "staged_files_in_index_disallowed", &test_merge_workdir_dirty__staged_files_in_index_disallowed },
    { "identical_staged_files_allowed", &test_merge_workdir_dirty__identical_staged_files_allowed },
    { "honors_cache", &test_merge_workdir_dirty__honors_cache }
};
static const struct clar_func _clar_cb_merge_workdir_recursive[] = {
    { "writes_conflict_with_virtual_base", &test_merge_workdir_recursive__writes_conflict_with_virtual_base },
    { "conflicting_merge_base_with_diff3", &test_merge_workdir_recursive__conflicting_merge_base_with_diff3 }
};
static const struct clar_func _clar_cb_merge_workdir_renames[] = {
    { "renames", &test_merge_workdir_renames__renames },
    { "ours", &test_merge_workdir_renames__ours },
    { "similar", &test_merge_workdir_renames__similar }
};
static const struct clar_func _clar_cb_merge_workdir_setup[] = {
    { "one_branch", &test_merge_workdir_setup__one_branch },
    { "one_oid", &test_merge_workdir_setup__one_oid },
    { "two_branches", &test_merge_workdir_setup__two_branches },
    { "three_branches", &test_merge_workdir_setup__three_branches },
    { "three_oids", &test_merge_workdir_setup__three_oids },
    { "branches_and_oids_1", &test_merge_workdir_setup__branches_and_oids_1 },
    { "branches_and_oids_2", &test_merge_workdir_setup__branches_and_oids_2 },
    { "branches_and_oids_3", &test_merge_workdir_setup__branches_and_oids_3 },
    { "branches_and_oids_4", &test_merge_workdir_setup__branches_and_oids_4 },
    { "three_same_branches", &test_merge_workdir_setup__three_same_branches },
    { "three_same_oids", &test_merge_workdir_setup__three_same_oids },
    { "remote_tracking_one_branch", &test_merge_workdir_setup__remote_tracking_one_branch },
    { "remote_tracking_two_branches", &test_merge_workdir_setup__remote_tracking_two_branches },
    { "remote_tracking_three_branches", &test_merge_workdir_setup__remote_tracking_three_branches },
    { "normal_branch_and_remote_tracking_branch", &test_merge_workdir_setup__normal_branch_and_remote_tracking_branch },
    { "remote_tracking_branch_and_normal_branch", &test_merge_workdir_setup__remote_tracking_branch_and_normal_branch },
    { "two_remote_tracking_branch_and_two_normal_branches", &test_merge_workdir_setup__two_remote_tracking_branch_and_two_normal_branches },
    { "pull_one", &test_merge_workdir_setup__pull_one },
    { "pull_two", &test_merge_workdir_setup__pull_two },
    { "pull_three", &test_merge_workdir_setup__pull_three },
    { "three_remotes", &test_merge_workdir_setup__three_remotes },
    { "two_remotes", &test_merge_workdir_setup__two_remotes },
    { "id_from_head", &test_merge_workdir_setup__id_from_head },
    { "head_notfound", &test_merge_workdir_setup__head_notfound },
    { "head_invalid_oid", &test_merge_workdir_setup__head_invalid_oid },
    { "head_foreach_nonewline", &test_merge_workdir_setup__head_foreach_nonewline },
    { "head_foreach_one", &test_merge_workdir_setup__head_foreach_one },
    { "head_foreach_octopus", &test_merge_workdir_setup__head_foreach_octopus },
    { "retained_after_success", &test_merge_workdir_setup__retained_after_success },
    { "removed_after_failure", &test_merge_workdir_setup__removed_after_failure },
    { "unlocked_after_success", &test_merge_workdir_setup__unlocked_after_success },
    { "unlocked_after_conflict", &test_merge_workdir_setup__unlocked_after_conflict }
};
static const struct clar_func _clar_cb_merge_workdir_simple[] = {
    { "automerge", &test_merge_workdir_simple__automerge },
    { "index_reload", &test_merge_workdir_simple__index_reload },
    { "automerge_crlf", &test_merge_workdir_simple__automerge_crlf },
    { "mergefile", &test_merge_workdir_simple__mergefile },
    { "diff3", &test_merge_workdir_simple__diff3 },
    { "zdiff3", &test_merge_workdir_simple__zdiff3 },
    { "union", &test_merge_workdir_simple__union },
    { "gitattributes_union", &test_merge_workdir_simple__gitattributes_union },
    { "diff3_from_config", &test_merge_workdir_simple__diff3_from_config },
    { "zdiff3_from_config", &test_merge_workdir_simple__zdiff3_from_config },
    { "merge_overrides_config", &test_merge_workdir_simple__merge_overrides_config },
    { "checkout_ours", &test_merge_workdir_simple__checkout_ours },
    { "favor_ours", &test_merge_workdir_simple__favor_ours },
    { "favor_theirs", &test_merge_workdir_simple__favor_theirs },
    { "directory_file", &test_merge_workdir_simple__directory_file },
    { "unrelated", &test_merge_workdir_simple__unrelated },
    { "unrelated_with_conflicts", &test_merge_workdir_simple__unrelated_with_conflicts },
    { "binary", &test_merge_workdir_simple__binary }
};
static const struct clar_func _clar_cb_merge_workdir_submodules[] = {
    { "automerge", &test_merge_workdir_submodules__automerge },
    { "take_changed", &test_merge_workdir_submodules__take_changed },
    { "update_delete_conflict", &test_merge_workdir_submodules__update_delete_conflict }
};
static const struct clar_func _clar_cb_merge_workdir_trivial[] = {
    { "2alt", &test_merge_workdir_trivial__2alt },
    { "3alt", &test_merge_workdir_trivial__3alt },
    { "4", &test_merge_workdir_trivial__4 },
    { "5alt_1", &test_merge_workdir_trivial__5alt_1 },
    { "5alt_2", &test_merge_workdir_trivial__5alt_2 },
    { "6", &test_merge_workdir_trivial__6 },
    { "8", &test_merge_workdir_trivial__8 },
    { "7", &test_merge_workdir_trivial__7 },
    { "10", &test_merge_workdir_trivial__10 },
    { "9", &test_merge_workdir_trivial__9 },
    { "13", &test_merge_workdir_trivial__13 },
    { "14", &test_merge_workdir_trivial__14 },
    { "11", &test_merge_workdir_trivial__11 }
};
static const struct clar_func _clar_cb_message_trailer[] = {
    { "simple", &test_message_trailer__simple },
    { "no_whitespace", &test_message_trailer__no_whitespace },
    { "extra_whitespace", &test_message_trailer__extra_whitespace },
    { "no_newline", &test_message_trailer__no_newline },
    { "not_last_paragraph", &test_message_trailer__not_last_paragraph },
    { "conflicts", &test_message_trailer__conflicts },
    { "patch", &test_message_trailer__patch },
    { "continuation", &test_message_trailer__continuation },
    { "invalid", &test_message_trailer__invalid },
    { "ignores_dashes", &test_message_trailer__ignores_dashes }
};
static const struct clar_func _clar_cb_network_cred[] = {
    { "stock_userpass_validates_args", &test_network_cred__stock_userpass_validates_args },
    { "stock_userpass_validates_that_method_is_allowed", &test_network_cred__stock_userpass_validates_that_method_is_allowed },
    { "stock_userpass_properly_handles_username_in_url", &test_network_cred__stock_userpass_properly_handles_username_in_url }
};
static const struct clar_func _clar_cb_network_fetchlocal[] = {
    { "complete", &test_network_fetchlocal__complete },
    { "prune", &test_network_fetchlocal__prune },
    { "prune_overlapping", &test_network_fetchlocal__prune_overlapping },
    { "fetchprune", &test_network_fetchlocal__fetchprune },
    { "prune_tag", &test_network_fetchlocal__prune_tag },
    { "partial", &test_network_fetchlocal__partial },
    { "clone_into_mirror", &test_network_fetchlocal__clone_into_mirror },
    { "all_refs", &test_network_fetchlocal__all_refs },
    { "multi_remotes", &test_network_fetchlocal__multi_remotes },
    { "call_progress", &test_network_fetchlocal__call_progress },
    { "prune_load_remote_prune_config", &test_network_fetchlocal__prune_load_remote_prune_config },
    { "prune_load_fetch_prune_config", &test_network_fetchlocal__prune_load_fetch_prune_config },
    { "update_tips_error_is_propagated", &test_network_fetchlocal__update_tips_error_is_propagated }
};
static const struct clar_func _clar_cb_network_refspecs[] = {
    { "parsing", &test_network_refspecs__parsing },
    { "transform_mid_star", &test_network_refspecs__transform_mid_star },
    { "transform_loosened_star", &test_network_refspecs__transform_loosened_star },
    { "transform_nested_star", &test_network_refspecs__transform_nested_star },
    { "no_dst", &test_network_refspecs__no_dst },
    { "invalid", &test_network_refspecs__invalid },
    { "invalid_reverse", &test_network_refspecs__invalid_reverse },
    { "matching", &test_network_refspecs__matching },
    { "parse_free", &test_network_refspecs__parse_free }
};
static const struct clar_func _clar_cb_network_remote_defaultbranch[] = {
    { "master", &test_network_remote_defaultbranch__master },
    { "master_does_not_win", &test_network_remote_defaultbranch__master_does_not_win },
    { "master_on_detached", &test_network_remote_defaultbranch__master_on_detached },
    { "no_default_branch", &test_network_remote_defaultbranch__no_default_branch },
    { "detached_sharing_nonbranch_id", &test_network_remote_defaultbranch__detached_sharing_nonbranch_id },
    { "unborn_HEAD_with_branches", &test_network_remote_defaultbranch__unborn_HEAD_with_branches }
};
static const struct clar_func _clar_cb_network_remote_delete[] = {
    { "remove_remote_tracking_branches", &test_network_remote_delete__remove_remote_tracking_branches },
    { "remove_remote_configuration_settings", &test_network_remote_delete__remove_remote_configuration_settings },
    { "remove_branch_upstream_configuration_settings", &test_network_remote_delete__remove_branch_upstream_configuration_settings }
};
static const struct clar_func _clar_cb_network_remote_isvalidname[] = {
    { "can_detect_invalid_formats", &test_network_remote_isvalidname__can_detect_invalid_formats },
    { "wont_hopefully_choke_on_valid_formats", &test_network_remote_isvalidname__wont_hopefully_choke_on_valid_formats }
};
static const struct clar_func _clar_cb_network_remote_local[] = {
    { "connected", &test_network_remote_local__connected },
    { "retrieve_advertised_references", &test_network_remote_local__retrieve_advertised_references },
    { "retrieve_advertised_before_connect", &test_network_remote_local__retrieve_advertised_before_connect },
    { "retrieve_advertised_references_after_disconnect", &test_network_remote_local__retrieve_advertised_references_after_disconnect },
    { "retrieve_advertised_references_from_spaced_repository", &test_network_remote_local__retrieve_advertised_references_from_spaced_repository },
    { "nested_tags_are_completely_peeled", &test_network_remote_local__nested_tags_are_completely_peeled },
    { "shorthand_fetch_refspec0", &test_network_remote_local__shorthand_fetch_refspec0 },
    { "shorthand_fetch_refspec1", &test_network_remote_local__shorthand_fetch_refspec1 },
    { "tagopt", &test_network_remote_local__tagopt },
    { "push_to_bare_remote", &test_network_remote_local__push_to_bare_remote },
    { "push_to_bare_remote_with_file_url", &test_network_remote_local__push_to_bare_remote_with_file_url },
    { "push_to_non_bare_remote", &test_network_remote_local__push_to_non_bare_remote },
    { "fetch", &test_network_remote_local__fetch },
    { "reflog", &test_network_remote_local__reflog },
    { "fetch_default_reflog_message", &test_network_remote_local__fetch_default_reflog_message },
    { "opportunistic_update", &test_network_remote_local__opportunistic_update },
    { "update_tips_for_new_remote", &test_network_remote_local__update_tips_for_new_remote },
    { "push_delete", &test_network_remote_local__push_delete },
    { "anonymous_remote_inmemory_repo", &test_network_remote_local__anonymous_remote_inmemory_repo }
};
static const struct clar_func _clar_cb_network_remote_push[] = {
    { "delete_notification", &test_network_remote_push__delete_notification },
    { "create_notification", &test_network_remote_push__create_notification }
};
static const struct clar_func _clar_cb_network_remote_remotes[] = {
    { "parsing", &test_network_remote_remotes__parsing },
    { "remote_ready", &test_network_remote_remotes__remote_ready },
    { "urlresolve", &test_network_remote_remotes__urlresolve },
    { "urlresolve_passthrough", &test_network_remote_remotes__urlresolve_passthrough },
    { "instance_url", &test_network_remote_remotes__instance_url },
    { "pushurl", &test_network_remote_remotes__pushurl },
    { "error_when_not_found", &test_network_remote_remotes__error_when_not_found },
    { "error_when_no_push_available", &test_network_remote_remotes__error_when_no_push_available },
    { "refspec_parsing", &test_network_remote_remotes__refspec_parsing },
    { "add_fetchspec", &test_network_remote_remotes__add_fetchspec },
    { "dup", &test_network_remote_remotes__dup },
    { "add_pushspec", &test_network_remote_remotes__add_pushspec },
    { "fnmatch", &test_network_remote_remotes__fnmatch },
    { "transform", &test_network_remote_remotes__transform },
    { "transform_destination_to_source", &test_network_remote_remotes__transform_destination_to_source },
    { "missing_refspecs", &test_network_remote_remotes__missing_refspecs },
    { "nonmatch_upstream_refspec", &test_network_remote_remotes__nonmatch_upstream_refspec },
    { "list", &test_network_remote_remotes__list },
    { "loading_a_missing_remote_returns_ENOTFOUND", &test_network_remote_remotes__loading_a_missing_remote_returns_ENOTFOUND },
    { "loading_with_an_invalid_name_returns_EINVALIDSPEC", &test_network_remote_remotes__loading_with_an_invalid_name_returns_EINVALIDSPEC },
    { "add", &test_network_remote_remotes__add },
    { "tagopt", &test_network_remote_remotes__tagopt },
    { "can_load_with_an_empty_url", &test_network_remote_remotes__can_load_with_an_empty_url },
    { "can_load_with_only_an_empty_pushurl", &test_network_remote_remotes__can_load_with_only_an_empty_pushurl },
    { "returns_ENOTFOUND_when_neither_url_nor_pushurl", &test_network_remote_remotes__returns_ENOTFOUND_when_neither_url_nor_pushurl },
    { "query_refspecs", &test_network_remote_remotes__query_refspecs }
};
static const struct clar_func _clar_cb_network_remote_rename[] = {
    { "renaming_a_remote_moves_related_configuration_section", &test_network_remote_rename__renaming_a_remote_moves_related_configuration_section },
    { "renaming_a_remote_updates_branch_related_configuration_entries", &test_network_remote_rename__renaming_a_remote_updates_branch_related_configuration_entries },
    { "renaming_a_remote_updates_default_fetchrefspec", &test_network_remote_rename__renaming_a_remote_updates_default_fetchrefspec },
    { "renaming_a_remote_without_a_fetchrefspec_doesnt_create_one", &test_network_remote_rename__renaming_a_remote_without_a_fetchrefspec_doesnt_create_one },
    { "renaming_a_remote_notifies_of_non_default_fetchrefspec", &test_network_remote_rename__renaming_a_remote_notifies_of_non_default_fetchrefspec },
    { "new_name_can_contain_dots", &test_network_remote_rename__new_name_can_contain_dots },
    { "new_name_must_conform_to_reference_naming_conventions", &test_network_remote_rename__new_name_must_conform_to_reference_naming_conventions },
    { "renamed_name_is_persisted", &test_network_remote_rename__renamed_name_is_persisted },
    { "cannot_overwrite_an_existing_remote", &test_network_remote_rename__cannot_overwrite_an_existing_remote },
    { "renaming_a_remote_moves_the_underlying_reference", &test_network_remote_rename__renaming_a_remote_moves_the_underlying_reference },
    { "overwrite_ref_in_target", &test_network_remote_rename__overwrite_ref_in_target },
    { "nonexistent_returns_enotfound", &test_network_remote_rename__nonexistent_returns_enotfound },
    { "symref_head", &test_network_remote_rename__symref_head }
};
static const struct clar_func _clar_cb_notes_notes[] = {
    { "can_create_a_note", &test_notes_notes__can_create_a_note },
    { "can_create_a_note_from_commit", &test_notes_notes__can_create_a_note_from_commit },
    { "can_create_a_note_from_commit_given_an_existing_commit", &test_notes_notes__can_create_a_note_from_commit_given_an_existing_commit },
    { "can_retrieve_a_list_of_notes_for_a_given_namespace", &test_notes_notes__can_retrieve_a_list_of_notes_for_a_given_namespace },
    { "can_cancel_foreach", &test_notes_notes__can_cancel_foreach },
    { "retrieving_a_list_of_notes_for_an_unknown_namespace_returns_ENOTFOUND", &test_notes_notes__retrieving_a_list_of_notes_for_an_unknown_namespace_returns_ENOTFOUND },
    { "inserting_a_note_without_passing_a_namespace_uses_the_default_namespace", &test_notes_notes__inserting_a_note_without_passing_a_namespace_uses_the_default_namespace },
    { "can_insert_a_note_with_a_custom_namespace", &test_notes_notes__can_insert_a_note_with_a_custom_namespace },
    { "creating_a_note_on_a_target_which_already_has_one_returns_EEXISTS", &test_notes_notes__creating_a_note_on_a_target_which_already_has_one_returns_EEXISTS },
    { "creating_a_note_on_a_target_can_overwrite_existing_note", &test_notes_notes__creating_a_note_on_a_target_can_overwrite_existing_note },
    { "can_read_a_note", &test_notes_notes__can_read_a_note },
    { "can_read_a_note_from_a_commit", &test_notes_notes__can_read_a_note_from_a_commit },
    { "attempt_to_read_a_note_from_a_commit_with_no_note_fails", &test_notes_notes__attempt_to_read_a_note_from_a_commit_with_no_note_fails },
    { "can_insert_a_note_in_an_existing_fanout", &test_notes_notes__can_insert_a_note_in_an_existing_fanout },
    { "can_read_a_note_in_an_existing_fanout", &test_notes_notes__can_read_a_note_in_an_existing_fanout },
    { "can_remove_a_note", &test_notes_notes__can_remove_a_note },
    { "can_remove_a_note_from_commit", &test_notes_notes__can_remove_a_note_from_commit },
    { "can_remove_a_note_in_an_existing_fanout", &test_notes_notes__can_remove_a_note_in_an_existing_fanout },
    { "removing_a_note_which_doesnt_exists_returns_ENOTFOUND", &test_notes_notes__removing_a_note_which_doesnt_exists_returns_ENOTFOUND },
    { "can_iterate_default_namespace", &test_notes_notes__can_iterate_default_namespace },
    { "can_iterate_custom_namespace", &test_notes_notes__can_iterate_custom_namespace },
    { "empty_iterate", &test_notes_notes__empty_iterate },
    { "iterate_from_commit", &test_notes_notes__iterate_from_commit }
};
static const struct clar_func _clar_cb_notes_notesref[] = {
    { "config_corenotesref", &test_notes_notesref__config_corenotesref }
};
static const struct clar_func _clar_cb_object_blob_filter[] = {
    { "unfiltered", &test_object_blob_filter__unfiltered },
    { "stats", &test_object_blob_filter__stats },
    { "to_odb", &test_object_blob_filter__to_odb }
};
static const struct clar_func _clar_cb_object_blob_fromstream[] = {
    { "multiple_write", &test_object_blob_fromstream__multiple_write },
    { "creating_a_blob_from_chunks_honors_the_attributes_directives", &test_object_blob_fromstream__creating_a_blob_from_chunks_honors_the_attributes_directives }
};
static const struct clar_func _clar_cb_object_blob_write[] = {
    { "can_create_a_blob_in_a_standard_repo_from_a_file_located_in_the_working_directory", &test_object_blob_write__can_create_a_blob_in_a_standard_repo_from_a_file_located_in_the_working_directory },
    { "can_create_a_blob_in_a_standard_repo_from_a_absolute_filepath_pointing_outside_of_the_working_directory", &test_object_blob_write__can_create_a_blob_in_a_standard_repo_from_a_absolute_filepath_pointing_outside_of_the_working_directory },
    { "can_create_a_blob_in_a_bare_repo_from_a_absolute_filepath", &test_object_blob_write__can_create_a_blob_in_a_bare_repo_from_a_absolute_filepath }
};
static const struct clar_func _clar_cb_object_cache[] = {
    { "cache_counts", &test_object_cache__cache_counts },
    { "threadmania", &test_object_cache__threadmania },
    { "fast_thread_rush", &test_object_cache__fast_thread_rush }
};
static const struct clar_func _clar_cb_object_commit_commitstagedfile[] = {
    { "generate_predictable_object_ids", &test_object_commit_commitstagedfile__generate_predictable_object_ids },
    { "amend_commit", &test_object_commit_commitstagedfile__amend_commit }
};
static const struct clar_func _clar_cb_object_commit_parse[] = {
    { "sha1_parsing_commit_succeeds", &test_object_commit_parse__sha1_parsing_commit_succeeds },
    { "sha1_parsing_commit_without_encoding_succeeds", &test_object_commit_parse__sha1_parsing_commit_without_encoding_succeeds },
    { "sha1_parsing_commit_with_multiple_authors_succeeds", &test_object_commit_parse__sha1_parsing_commit_with_multiple_authors_succeeds },
    { "sha1_parsing_commit_with_multiple_committers_succeeds", &test_object_commit_parse__sha1_parsing_commit_with_multiple_committers_succeeds },
    { "sha1_parsing_commit_without_message_succeeds", &test_object_commit_parse__sha1_parsing_commit_without_message_succeeds },
    { "sha1_parsing_commit_with_unknown_fields_succeeds", &test_object_commit_parse__sha1_parsing_commit_with_unknown_fields_succeeds },
    { "sha1_parsing_commit_with_invalid_tree_fails", &test_object_commit_parse__sha1_parsing_commit_with_invalid_tree_fails },
    { "sha1_parsing_commit_with_sha256_tree_fails", &test_object_commit_parse__sha1_parsing_commit_with_sha256_tree_fails },
    { "sha1_parsing_commit_without_tree_fails", &test_object_commit_parse__sha1_parsing_commit_without_tree_fails },
    { "sha1_parsing_commit_without_author_fails", &test_object_commit_parse__sha1_parsing_commit_without_author_fails },
    { "sha1_parsing_commit_without_committer_fails", &test_object_commit_parse__sha1_parsing_commit_without_committer_fails },
    { "sha1_parsing_encoding_will_not_cause_oob_read", &test_object_commit_parse__sha1_parsing_encoding_will_not_cause_oob_read },
    { "sha256_parsing_commit_succeeds", &test_object_commit_parse__sha256_parsing_commit_succeeds },
    { "sha256_parsing_commit_without_encoding_succeeds", &test_object_commit_parse__sha256_parsing_commit_without_encoding_succeeds },
    { "sha256_parsing_commit_with_multiple_authors_succeeds", &test_object_commit_parse__sha256_parsing_commit_with_multiple_authors_succeeds },
    { "sha256_parsing_commit_with_multiple_committers_succeeds", &test_object_commit_parse__sha256_parsing_commit_with_multiple_committers_succeeds },
    { "sha256_parsing_commit_without_message_succeeds", &test_object_commit_parse__sha256_parsing_commit_without_message_succeeds },
    { "sha256_parsing_commit_with_unknown_fields_succeeds", &test_object_commit_parse__sha256_parsing_commit_with_unknown_fields_succeeds },
    { "sha256_parsing_commit_with_invalid_tree_fails", &test_object_commit_parse__sha256_parsing_commit_with_invalid_tree_fails },
    { "sha256_parsing_commit_with_sha1_tree_fails", &test_object_commit_parse__sha256_parsing_commit_with_sha1_tree_fails },
    { "sha256_parsing_commit_without_tree_fails", &test_object_commit_parse__sha256_parsing_commit_without_tree_fails },
    { "sha256_parsing_commit_without_author_fails", &test_object_commit_parse__sha256_parsing_commit_without_author_fails },
    { "sha256_parsing_commit_without_committer_fails", &test_object_commit_parse__sha256_parsing_commit_without_committer_fails },
    { "sha256_parsing_encoding_will_not_cause_oob_read", &test_object_commit_parse__sha256_parsing_encoding_will_not_cause_oob_read }
};
static const struct clar_func _clar_cb_object_lookup[] = {
    { "lookup_wrong_type_returns_enotfound", &test_object_lookup__lookup_wrong_type_returns_enotfound },
    { "lookup_nonexisting_returns_enotfound", &test_object_lookup__lookup_nonexisting_returns_enotfound },
    { "lookup_wrong_type_by_abbreviated_id_returns_enotfound", &test_object_lookup__lookup_wrong_type_by_abbreviated_id_returns_enotfound },
    { "lookup_wrong_type_eventually_returns_enotfound", &test_object_lookup__lookup_wrong_type_eventually_returns_enotfound },
    { "lookup_corrupt_object_returns_error", &test_object_lookup__lookup_corrupt_object_returns_error },
    { "lookup_object_with_wrong_hash_returns_error", &test_object_lookup__lookup_object_with_wrong_hash_returns_error }
};
static const struct clar_func _clar_cb_object_lookup256[] = {
    { "lookup_wrong_type_returns_enotfound", &test_object_lookup256__lookup_wrong_type_returns_enotfound },
    { "lookup_nonexisting_returns_enotfound", &test_object_lookup256__lookup_nonexisting_returns_enotfound },
    { "lookup_wrong_type_by_abbreviated_id_returns_enotfound", &test_object_lookup256__lookup_wrong_type_by_abbreviated_id_returns_enotfound },
    { "lookup_wrong_type_eventually_returns_enotfound", &test_object_lookup256__lookup_wrong_type_eventually_returns_enotfound },
    { "lookup_corrupt_object_returns_error", &test_object_lookup256__lookup_corrupt_object_returns_error },
    { "lookup_object_with_wrong_hash_returns_error", &test_object_lookup256__lookup_object_with_wrong_hash_returns_error }
};
static const struct clar_func _clar_cb_object_lookupbypath[] = {
    { "errors", &test_object_lookupbypath__errors },
    { "from_root_tree", &test_object_lookupbypath__from_root_tree },
    { "from_head_commit", &test_object_lookupbypath__from_head_commit },
    { "from_subdir_tree", &test_object_lookupbypath__from_subdir_tree }
};
static const struct clar_func _clar_cb_object_message[] = {
    { "long_lines_without_spaces_should_be_unchanged", &test_object_message__long_lines_without_spaces_should_be_unchanged },
    { "lines_with_spaces_at_the_beginning_should_be_unchanged", &test_object_message__lines_with_spaces_at_the_beginning_should_be_unchanged },
    { "lines_with_intermediate_spaces_should_be_unchanged", &test_object_message__lines_with_intermediate_spaces_should_be_unchanged },
    { "consecutive_blank_lines_should_be_unified", &test_object_message__consecutive_blank_lines_should_be_unified },
    { "only_consecutive_blank_lines_should_be_completely_removed", &test_object_message__only_consecutive_blank_lines_should_be_completely_removed },
    { "consecutive_blank_lines_at_the_beginning_should_be_removed", &test_object_message__consecutive_blank_lines_at_the_beginning_should_be_removed },
    { "consecutive_blank_lines_at_the_end_should_be_removed", &test_object_message__consecutive_blank_lines_at_the_end_should_be_removed },
    { "text_without_newline_at_end_should_end_with_newline", &test_object_message__text_without_newline_at_end_should_end_with_newline },
    { "text_plus_spaces_without_newline_should_not_show_spaces_and_end_with_newline", &test_object_message__text_plus_spaces_without_newline_should_not_show_spaces_and_end_with_newline },
    { "text_plus_spaces_ending_with_newline_should_be_cleaned_and_newline_must_remain", &test_object_message__text_plus_spaces_ending_with_newline_should_be_cleaned_and_newline_must_remain },
    { "spaces_with_newline_at_end_should_be_replaced_with_empty_string", &test_object_message__spaces_with_newline_at_end_should_be_replaced_with_empty_string },
    { "spaces_without_newline_at_end_should_be_replaced_with_empty_string", &test_object_message__spaces_without_newline_at_end_should_be_replaced_with_empty_string },
    { "consecutive_text_lines_should_be_unchanged", &test_object_message__consecutive_text_lines_should_be_unchanged },
    { "strip_comments", &test_object_message__strip_comments },
    { "keep_comments", &test_object_message__keep_comments },
    { "message_prettify", &test_object_message__message_prettify }
};
static const struct clar_func _clar_cb_object_peel[] = {
    { "peeling_an_object_into_its_own_type_returns_another_instance_of_it", &test_object_peel__peeling_an_object_into_its_own_type_returns_another_instance_of_it },
    { "tag", &test_object_peel__tag },
    { "commit", &test_object_peel__commit },
    { "tree", &test_object_peel__tree },
    { "blob", &test_object_peel__blob },
    { "target_any_object_for_type_change", &test_object_peel__target_any_object_for_type_change }
};
static const struct clar_func _clar_cb_object_raw_chars[] = {
    { "find_invalid_chars_in_oid", &test_object_raw_chars__find_invalid_chars_in_oid },
    { "build_valid_oid_from_raw_bytes", &test_object_raw_chars__build_valid_oid_from_raw_bytes }
};
static const struct clar_func _clar_cb_object_raw_compare[] = {
    { "succeed_on_copy_oid", &test_object_raw_compare__succeed_on_copy_oid },
    { "succeed_on_oid_comparison_lesser", &test_object_raw_compare__succeed_on_oid_comparison_lesser },
    { "succeed_on_oid_comparison_equal", &test_object_raw_compare__succeed_on_oid_comparison_equal },
    { "succeed_on_oid_comparison_greater", &test_object_raw_compare__succeed_on_oid_comparison_greater },
    { "compare_fmt_oids", &test_object_raw_compare__compare_fmt_oids },
    { "compare_static_oids", &test_object_raw_compare__compare_static_oids },
    { "compare_pathfmt_oids", &test_object_raw_compare__compare_pathfmt_oids }
};
static const struct clar_func _clar_cb_object_raw_convert[] = {
    { "succeed_on_oid_to_string_conversion", &test_object_raw_convert__succeed_on_oid_to_string_conversion },
    { "succeed_on_oid_to_string_conversion_big", &test_object_raw_convert__succeed_on_oid_to_string_conversion_big },
    { "convert_oid_partially", &test_object_raw_convert__convert_oid_partially }
};
static const struct clar_func _clar_cb_object_raw_fromstr[] = {
    { "fail_on_invalid_oid_string", &test_object_raw_fromstr__fail_on_invalid_oid_string },
    { "succeed_on_valid_oid_string", &test_object_raw_fromstr__succeed_on_valid_oid_string }
};
static const struct clar_func _clar_cb_object_raw_hash[] = {
    { "hash_by_blocks", &test_object_raw_hash__hash_by_blocks },
    { "hash_buffer_in_single_call", &test_object_raw_hash__hash_buffer_in_single_call },
    { "hash_vector", &test_object_raw_hash__hash_vector },
    { "hash_junk_data", &test_object_raw_hash__hash_junk_data },
    { "hash_commit_object", &test_object_raw_hash__hash_commit_object },
    { "hash_tree_object", &test_object_raw_hash__hash_tree_object },
    { "hash_tag_object", &test_object_raw_hash__hash_tag_object },
    { "hash_zero_length_object", &test_object_raw_hash__hash_zero_length_object },
    { "hash_one_byte_object", &test_object_raw_hash__hash_one_byte_object },
    { "hash_two_byte_object", &test_object_raw_hash__hash_two_byte_object },
    { "hash_multi_byte_object", &test_object_raw_hash__hash_multi_byte_object }
};
static const struct clar_func _clar_cb_object_raw_short[] = {
    { "oid_shortener_no_duplicates", &test_object_raw_short__oid_shortener_no_duplicates },
    { "oid_shortener_stresstest_git_oid_shorten", &test_object_raw_short__oid_shortener_stresstest_git_oid_shorten },
    { "oid_shortener_too_much_oids", &test_object_raw_short__oid_shortener_too_much_oids }
};
static const struct clar_func _clar_cb_object_raw_size[] = {
    { "validate_oid_size", &test_object_raw_size__validate_oid_size }
};
static const struct clar_func _clar_cb_object_raw_type2string[] = {
    { "convert_type_to_string", &test_object_raw_type2string__convert_type_to_string },
    { "convert_string_to_type", &test_object_raw_type2string__convert_string_to_type },
    { "check_type_is_loose", &test_object_raw_type2string__check_type_is_loose }
};
static const struct clar_func _clar_cb_object_raw_write[] = {
    { "loose_object", &test_object_raw_write__loose_object },
    { "loose_tree", &test_object_raw_write__loose_tree },
    { "loose_tag", &test_object_raw_write__loose_tag },
    { "zero_length", &test_object_raw_write__zero_length },
    { "one_byte", &test_object_raw_write__one_byte },
    { "two_byte", &test_object_raw_write__two_byte },
    { "several_bytes", &test_object_raw_write__several_bytes }
};
static const struct clar_func _clar_cb_object_shortid[] = {
    { "select", &test_object_shortid__select }
};
static const struct clar_func _clar_cb_object_tag_list[] = {
    { "list_all", &test_object_tag_list__list_all },
    { "list_by_pattern", &test_object_tag_list__list_by_pattern }
};
static const struct clar_func _clar_cb_object_tag_parse[] = {
    { "valid_tag_parses", &test_object_tag_parse__valid_tag_parses },
    { "missing_tagger_parses", &test_object_tag_parse__missing_tagger_parses },
    { "missing_message_parses", &test_object_tag_parse__missing_message_parses },
    { "unknown_field_parses", &test_object_tag_parse__unknown_field_parses },
    { "missing_object_fails", &test_object_tag_parse__missing_object_fails },
    { "malformatted_object_fails", &test_object_tag_parse__malformatted_object_fails },
    { "missing_type_fails", &test_object_tag_parse__missing_type_fails },
    { "invalid_type_fails", &test_object_tag_parse__invalid_type_fails },
    { "missing_tagname_fails", &test_object_tag_parse__missing_tagname_fails },
    { "misformatted_tagger_fails", &test_object_tag_parse__misformatted_tagger_fails },
    { "missing_message_fails", &test_object_tag_parse__missing_message_fails },
    { "no_oob_read_when_searching_message", &test_object_tag_parse__no_oob_read_when_searching_message }
};
static const struct clar_func _clar_cb_object_tag_peel[] = {
    { "can_peel_to_a_commit", &test_object_tag_peel__can_peel_to_a_commit },
    { "can_peel_several_nested_tags_to_a_commit", &test_object_tag_peel__can_peel_several_nested_tags_to_a_commit },
    { "can_peel_to_a_non_commit", &test_object_tag_peel__can_peel_to_a_non_commit }
};
static const struct clar_func _clar_cb_object_tag_read[] = {
    { "parse", &test_object_tag_read__parse },
    { "parse_without_tagger", &test_object_tag_read__parse_without_tagger },
    { "parse_without_message", &test_object_tag_read__parse_without_message },
    { "without_tagger_nor_message", &test_object_tag_read__without_tagger_nor_message },
    { "extra_header_fields", &test_object_tag_read__extra_header_fields }
};
static const struct clar_func _clar_cb_object_tag_write[] = {
    { "basic", &test_object_tag_write__basic },
    { "overwrite", &test_object_tag_write__overwrite },
    { "replace", &test_object_tag_write__replace },
    { "lightweight", &test_object_tag_write__lightweight },
    { "lightweight_over_existing", &test_object_tag_write__lightweight_over_existing },
    { "delete", &test_object_tag_write__delete },
    { "creating_with_an_invalid_name_returns_EINVALIDSPEC", &test_object_tag_write__creating_with_an_invalid_name_returns_EINVALIDSPEC },
    { "deleting_with_an_invalid_name_returns_EINVALIDSPEC", &test_object_tag_write__deleting_with_an_invalid_name_returns_EINVALIDSPEC },
    { "creating_an_annotation_stores_the_new_object_in_the_odb", &test_object_tag_write__creating_an_annotation_stores_the_new_object_in_the_odb },
    { "creating_an_annotation_does_not_create_a_reference", &test_object_tag_write__creating_an_annotation_does_not_create_a_reference },
    { "error_when_create_tag_with_invalid_name", &test_object_tag_write__error_when_create_tag_with_invalid_name }
};
static const struct clar_func _clar_cb_object_tree_attributes[] = {
    { "ensure_correctness_of_attributes_on_insertion", &test_object_tree_attributes__ensure_correctness_of_attributes_on_insertion },
    { "group_writable_tree_entries_created_with_an_antique_git_version_can_still_be_accessed", &test_object_tree_attributes__group_writable_tree_entries_created_with_an_antique_git_version_can_still_be_accessed },
    { "treebuilder_reject_invalid_filemode", &test_object_tree_attributes__treebuilder_reject_invalid_filemode },
    { "normalize_attributes_when_creating_a_tree_from_an_existing_one", &test_object_tree_attributes__normalize_attributes_when_creating_a_tree_from_an_existing_one },
    { "normalize_600", &test_object_tree_attributes__normalize_600 }
};
static const struct clar_func _clar_cb_object_tree_duplicateentries[] = {
    { "cannot_create_a_duplicate_entry_through_the_treebuilder", &test_object_tree_duplicateentries__cannot_create_a_duplicate_entry_through_the_treebuilder },
    { "cannot_create_a_duplicate_entry_building_a_tree_from_a_index_with_conflicts", &test_object_tree_duplicateentries__cannot_create_a_duplicate_entry_building_a_tree_from_a_index_with_conflicts }
};
static const struct clar_func _clar_cb_object_tree_frompath[] = {
    { "retrieve_tree_from_path_to_treeentry", &test_object_tree_frompath__retrieve_tree_from_path_to_treeentry },
    { "fail_when_processing_an_invalid_path", &test_object_tree_frompath__fail_when_processing_an_invalid_path }
};
static const struct clar_func _clar_cb_object_tree_parse[] = {
    { "single_blob_parses", &test_object_tree_parse__single_blob_parses },
    { "single_tree_parses", &test_object_tree_parse__single_tree_parses },
    { "leading_filename_spaces_parse", &test_object_tree_parse__leading_filename_spaces_parse },
    { "multiple_entries_parse", &test_object_tree_parse__multiple_entries_parse },
    { "invalid_mode_fails", &test_object_tree_parse__invalid_mode_fails },
    { "missing_mode_fails", &test_object_tree_parse__missing_mode_fails },
    { "mode_doesnt_cause_oob_read", &test_object_tree_parse__mode_doesnt_cause_oob_read },
    { "unreasonably_large_mode_fails", &test_object_tree_parse__unreasonably_large_mode_fails },
    { "missing_filename_separator_fails", &test_object_tree_parse__missing_filename_separator_fails },
    { "missing_filename_terminator_fails", &test_object_tree_parse__missing_filename_terminator_fails },
    { "empty_filename_fails", &test_object_tree_parse__empty_filename_fails },
    { "trailing_garbage_fails", &test_object_tree_parse__trailing_garbage_fails },
    { "leading_space_fails", &test_object_tree_parse__leading_space_fails },
    { "truncated_oid_fails", &test_object_tree_parse__truncated_oid_fails }
};
static const struct clar_func _clar_cb_object_tree_read[] = {
    { "loaded", &test_object_tree_read__loaded },
    { "two", &test_object_tree_read__two },
    { "largefile", &test_object_tree_read__largefile }
};
static const struct clar_func _clar_cb_object_tree_update[] = {
    { "remove_blob", &test_object_tree_update__remove_blob },
    { "remove_blob_deeper", &test_object_tree_update__remove_blob_deeper },
    { "remove_all_entries", &test_object_tree_update__remove_all_entries },
    { "replace_blob", &test_object_tree_update__replace_blob },
    { "add_blobs", &test_object_tree_update__add_blobs },
    { "add_blobs_unsorted", &test_object_tree_update__add_blobs_unsorted },
    { "add_conflict", &test_object_tree_update__add_conflict },
    { "add_conflict2", &test_object_tree_update__add_conflict2 },
    { "remove_invalid_submodule", &test_object_tree_update__remove_invalid_submodule }
};
static const struct clar_func _clar_cb_object_tree_walk[] = {
    { "0", &test_object_tree_walk__0 },
    { "1", &test_object_tree_walk__1 },
    { "2", &test_object_tree_walk__2 }
};
static const struct clar_func _clar_cb_object_tree_write[] = {
    { "from_memory", &test_object_tree_write__from_memory },
    { "subtree", &test_object_tree_write__subtree },
    { "sorted_subtrees", &test_object_tree_write__sorted_subtrees },
    { "removing_and_re_adding_in_treebuilder", &test_object_tree_write__removing_and_re_adding_in_treebuilder },
    { "filtering", &test_object_tree_write__filtering },
    { "cruel_paths", &test_object_tree_write__cruel_paths },
    { "protect_filesystems", &test_object_tree_write__protect_filesystems },
    { "object_validity", &test_object_tree_write__object_validity },
    { "invalid_null_oid", &test_object_tree_write__invalid_null_oid }
};
static const struct clar_func _clar_cb_object_validate[] = {
    { "valid_sha1", &test_object_validate__valid_sha1 },
    { "cannot_parse_sha256_as_sha1", &test_object_validate__cannot_parse_sha256_as_sha1 },
    { "invalid_sha1", &test_object_validate__invalid_sha1 },
    { "valid_sha256", &test_object_validate__valid_sha256 },
    { "invalid_sha256", &test_object_validate__invalid_sha256 },
    { "cannot_parse_sha1_as_sha256", &test_object_validate__cannot_parse_sha1_as_sha256 }
};
static const struct clar_func _clar_cb_odb_alternates[] = {
    { "chained", &test_odb_alternates__chained },
    { "long_chain", &test_odb_alternates__long_chain }
};
static const struct clar_func _clar_cb_odb_backend_loose[] = {
    { "read_from_odb", &test_odb_backend_loose__read_from_odb },
    { "read_from_repo", &test_odb_backend_loose__read_from_repo }
};
static const struct clar_func _clar_cb_odb_backend_mempack[] = {
    { "write_succeeds", &test_odb_backend_mempack__write_succeeds },
    { "read_of_missing_object_fails", &test_odb_backend_mempack__read_of_missing_object_fails },
    { "exists_of_missing_object_fails", &test_odb_backend_mempack__exists_of_missing_object_fails },
    { "exists_with_existing_objects_succeeds", &test_odb_backend_mempack__exists_with_existing_objects_succeeds },
    { "blob_create_from_buffer_succeeds", &test_odb_backend_mempack__blob_create_from_buffer_succeeds }
};
static const struct clar_func _clar_cb_odb_backend_multiple[] = {
    { "read_with_empty_first_succeeds", &test_odb_backend_multiple__read_with_empty_first_succeeds },
    { "read_with_first_matching_stops", &test_odb_backend_multiple__read_with_first_matching_stops },
    { "read_prefix_with_first_empty_succeeds", &test_odb_backend_multiple__read_prefix_with_first_empty_succeeds },
    { "read_prefix_with_first_matching_reads_both", &test_odb_backend_multiple__read_prefix_with_first_matching_reads_both },
    { "read_prefix_with_first_matching_succeeds_without_hash_verification", &test_odb_backend_multiple__read_prefix_with_first_matching_succeeds_without_hash_verification }
};
static const struct clar_func _clar_cb_odb_backend_nobackend[] = {
    { "write_fails_gracefully", &test_odb_backend_nobackend__write_fails_gracefully }
};
static const struct clar_func _clar_cb_odb_backend_nonrefreshing[] = {
    { "exists_is_invoked_once_on_failure", &test_odb_backend_nonrefreshing__exists_is_invoked_once_on_failure },
    { "read_is_invoked_once_on_failure", &test_odb_backend_nonrefreshing__read_is_invoked_once_on_failure },
    { "readprefix_is_invoked_once_on_failure", &test_odb_backend_nonrefreshing__readprefix_is_invoked_once_on_failure },
    { "readheader_is_invoked_once_on_failure", &test_odb_backend_nonrefreshing__readheader_is_invoked_once_on_failure },
    { "exists_is_invoked_once_on_success", &test_odb_backend_nonrefreshing__exists_is_invoked_once_on_success },
    { "read_is_invoked_once_on_success", &test_odb_backend_nonrefreshing__read_is_invoked_once_on_success },
    { "readprefix_is_invoked_once_on_success", &test_odb_backend_nonrefreshing__readprefix_is_invoked_once_on_success },
    { "readheader_is_invoked_once_on_success", &test_odb_backend_nonrefreshing__readheader_is_invoked_once_on_success },
    { "read_is_invoked_once_when_revparsing_a_full_oid", &test_odb_backend_nonrefreshing__read_is_invoked_once_when_revparsing_a_full_oid }
};
static const struct clar_func _clar_cb_odb_backend_refreshing[] = {
    { "exists_is_invoked_twice_on_failure", &test_odb_backend_refreshing__exists_is_invoked_twice_on_failure },
    { "read_is_invoked_twice_on_failure", &test_odb_backend_refreshing__read_is_invoked_twice_on_failure },
    { "readprefix_is_invoked_twice_on_failure", &test_odb_backend_refreshing__readprefix_is_invoked_twice_on_failure },
    { "readheader_is_invoked_twice_on_failure", &test_odb_backend_refreshing__readheader_is_invoked_twice_on_failure },
    { "exists_is_invoked_once_on_success", &test_odb_backend_refreshing__exists_is_invoked_once_on_success },
    { "read_is_invoked_once_on_success", &test_odb_backend_refreshing__read_is_invoked_once_on_success },
    { "readprefix_is_invoked_once_on_success", &test_odb_backend_refreshing__readprefix_is_invoked_once_on_success },
    { "readheader_is_invoked_once_on_success", &test_odb_backend_refreshing__readheader_is_invoked_once_on_success },
    { "read_is_invoked_twice_when_revparsing_a_full_oid", &test_odb_backend_refreshing__read_is_invoked_twice_when_revparsing_a_full_oid },
    { "refresh_is_invoked", &test_odb_backend_refreshing__refresh_is_invoked },
    { "refresh_suppressed_with_no_refresh", &test_odb_backend_refreshing__refresh_suppressed_with_no_refresh }
};
static const struct clar_func _clar_cb_odb_backend_simple[] = {
    { "read_of_object_succeeds", &test_odb_backend_simple__read_of_object_succeeds },
    { "read_of_nonexisting_object_fails", &test_odb_backend_simple__read_of_nonexisting_object_fails },
    { "read_with_hash_mismatch_fails", &test_odb_backend_simple__read_with_hash_mismatch_fails },
    { "read_with_hash_mismatch_succeeds_without_verification", &test_odb_backend_simple__read_with_hash_mismatch_succeeds_without_verification },
    { "read_prefix_succeeds", &test_odb_backend_simple__read_prefix_succeeds },
    { "read_prefix_of_nonexisting_object_fails", &test_odb_backend_simple__read_prefix_of_nonexisting_object_fails },
    { "read_with_ambiguous_prefix_fails", &test_odb_backend_simple__read_with_ambiguous_prefix_fails },
    { "read_with_highly_ambiguous_prefix", &test_odb_backend_simple__read_with_highly_ambiguous_prefix },
    { "exists_succeeds", &test_odb_backend_simple__exists_succeeds },
    { "exists_fails_for_nonexisting_object", &test_odb_backend_simple__exists_fails_for_nonexisting_object },
    { "exists_prefix_succeeds", &test_odb_backend_simple__exists_prefix_succeeds },
    { "exists_with_ambiguous_prefix_fails", &test_odb_backend_simple__exists_with_ambiguous_prefix_fails },
    { "exists_with_highly_ambiguous_prefix", &test_odb_backend_simple__exists_with_highly_ambiguous_prefix },
    { "null_oid_is_ignored", &test_odb_backend_simple__null_oid_is_ignored }
};
static const struct clar_func _clar_cb_odb_emptyobjects[] = {
    { "blob_notfound", &test_odb_emptyobjects__blob_notfound },
    { "read_tree", &test_odb_emptyobjects__read_tree },
    { "read_tree_odb", &test_odb_emptyobjects__read_tree_odb }
};
static const struct clar_func _clar_cb_odb_foreach[] = {
    { "foreach", &test_odb_foreach__foreach },
    { "one_pack", &test_odb_foreach__one_pack },
    { "interrupt_foreach", &test_odb_foreach__interrupt_foreach },
    { "files_in_objects_dir", &test_odb_foreach__files_in_objects_dir }
};
static const struct clar_func _clar_cb_odb_freshen[] = {
    { "loose_blob", &test_odb_freshen__loose_blob },
    { "readonly_object", &test_odb_freshen__readonly_object },
    { "loose_tree", &test_odb_freshen__loose_tree },
    { "tree_during_commit", &test_odb_freshen__tree_during_commit },
    { "packed_object", &test_odb_freshen__packed_object }
};
static const struct clar_func _clar_cb_odb_largefiles[] = {
    { "write_from_memory", &test_odb_largefiles__write_from_memory },
    { "streamwrite", &test_odb_largefiles__streamwrite },
    { "streamread", &test_odb_largefiles__streamread },
    { "read_into_memory", &test_odb_largefiles__read_into_memory },
    { "read_into_memory_rejected_on_32bit", &test_odb_largefiles__read_into_memory_rejected_on_32bit },
    { "read_header", &test_odb_largefiles__read_header }
};
static const struct clar_func _clar_cb_odb_loose[] = {
    { "exists_sha1", &test_odb_loose__exists_sha1 },
    { "exists_sha256", &test_odb_loose__exists_sha256 },
    { "simple_reads_sha1", &test_odb_loose__simple_reads_sha1 },
    { "simple_reads_sha256", &test_odb_loose__simple_reads_sha256 },
    { "streaming_reads_sha1", &test_odb_loose__streaming_reads_sha1 },
    { "streaming_reads_sha256", &test_odb_loose__streaming_reads_sha256 },
    { "read_header_sha1", &test_odb_loose__read_header_sha1 },
    { "read_header_sha256", &test_odb_loose__read_header_sha256 },
    { "permissions_standard", &test_odb_loose__permissions_standard },
    { "permissions_readonly", &test_odb_loose__permissions_readonly },
    { "permissions_readwrite", &test_odb_loose__permissions_readwrite },
    { "does_not_fsync_by_default", &test_odb_loose__does_not_fsync_by_default },
    { "fsync_obeys_odb_option", &test_odb_loose__fsync_obeys_odb_option },
    { "fsync_obeys_global_setting", &test_odb_loose__fsync_obeys_global_setting },
    { "fsync_obeys_repo_setting", &test_odb_loose__fsync_obeys_repo_setting }
};
static const struct clar_func _clar_cb_odb_mixed[] = {
    { "dup_oid", &test_odb_mixed__dup_oid },
    { "dup_oid_prefix_0", &test_odb_mixed__dup_oid_prefix_0 },
    { "expand_ids", &test_odb_mixed__expand_ids },
    { "expand_ids_cached", &test_odb_mixed__expand_ids_cached }
};
static const struct clar_func _clar_cb_odb_open[] = {
    { "exists", &test_odb_open__exists }
};
static const struct clar_func _clar_cb_odb_packed[] = {
    { "mass_read", &test_odb_packed__mass_read },
    { "read_header_0", &test_odb_packed__read_header_0 },
    { "read_header_1", &test_odb_packed__read_header_1 }
};
static const struct clar_func _clar_cb_odb_packed256[] = {
    { "mass_read", &test_odb_packed256__mass_read },
    { "read_header_0", &test_odb_packed256__read_header_0 },
    { "read_header_1", &test_odb_packed256__read_header_1 }
};
static const struct clar_func _clar_cb_odb_packedone[] = {
    { "mass_read", &test_odb_packedone__mass_read },
    { "read_header_0", &test_odb_packedone__read_header_0 }
};
static const struct clar_func _clar_cb_odb_packedone256[] = {
    { "mass_read", &test_odb_packedone256__mass_read },
    { "read_header_0", &test_odb_packedone256__read_header_0 }
};
static const struct clar_func _clar_cb_odb_sorting[] = {
    { "basic_backends_sorting", &test_odb_sorting__basic_backends_sorting },
    { "alternate_backends_sorting", &test_odb_sorting__alternate_backends_sorting },
    { "override_default_backend_priority", &test_odb_sorting__override_default_backend_priority }
};
static const struct clar_func _clar_cb_odb_streamwrite[] = {
    { "can_accept_chunks", &test_odb_streamwrite__can_accept_chunks },
    { "can_detect_missing_bytes", &test_odb_streamwrite__can_detect_missing_bytes },
    { "can_detect_additional_bytes", &test_odb_streamwrite__can_detect_additional_bytes }
};
static const struct clar_func _clar_cb_online_badssl[] = {
    { "expired", &test_online_badssl__expired },
    { "wrong_host", &test_online_badssl__wrong_host },
    { "self_signed", &test_online_badssl__self_signed },
    { "old_cipher", &test_online_badssl__old_cipher }
};
static const struct clar_func _clar_cb_online_clone[] = {
    { "network_full", &test_online_clone__network_full },
    { "network_bare", &test_online_clone__network_bare },
    { "empty_repository", &test_online_clone__empty_repository },
    { "can_checkout_a_cloned_repo", &test_online_clone__can_checkout_a_cloned_repo },
    { "clone_mirror", &test_online_clone__clone_mirror },
    { "custom_remote_callbacks", &test_online_clone__custom_remote_callbacks },
    { "custom_headers", &test_online_clone__custom_headers },
    { "long_custom_header", &test_online_clone__long_custom_header },
    { "cred_callback_failure_return_code_is_tunnelled", &test_online_clone__cred_callback_failure_return_code_is_tunnelled },
    { "cred_callback_called_again_on_auth_failure", &test_online_clone__cred_callback_called_again_on_auth_failure },
    { "credentials", &test_online_clone__credentials },
    { "credentials_via_custom_headers", &test_online_clone__credentials_via_custom_headers },
    { "bitbucket_style", &test_online_clone__bitbucket_style },
    { "bitbucket_uses_creds_in_url", &test_online_clone__bitbucket_uses_creds_in_url },
    { "bitbucket_falls_back_to_specified_creds", &test_online_clone__bitbucket_falls_back_to_specified_creds },
    { "googlesource", &test_online_clone__googlesource },
    { "can_cancel", &test_online_clone__can_cancel },
    { "ssh_github", &test_online_clone__ssh_github },
    { "ssh_auth_methods", &test_online_clone__ssh_auth_methods },
    { "ssh_certcheck_accepts_unknown", &test_online_clone__ssh_certcheck_accepts_unknown },
    { "ssh_certcheck_override_knownhosts", &test_online_clone__ssh_certcheck_override_knownhosts },
    { "ssh_with_paths", &test_online_clone__ssh_with_paths },
    { "ssh_cannot_change_username", &test_online_clone__ssh_cannot_change_username },
    { "ssh_cert", &test_online_clone__ssh_cert },
    { "ssh_memory_auth", &test_online_clone__ssh_memory_auth },
    { "certificate_invalid", &test_online_clone__certificate_invalid },
    { "certificate_valid", &test_online_clone__certificate_valid },
    { "start_with_http", &test_online_clone__start_with_http },
    { "proxy_http_host_port_in_opts", &test_online_clone__proxy_http_host_port_in_opts },
    { "proxy_http_host_port_in_env", &test_online_clone__proxy_http_host_port_in_env },
    { "proxy_http_host_port_in_config", &test_online_clone__proxy_http_host_port_in_config },
    { "proxy_invalid_url", &test_online_clone__proxy_invalid_url },
    { "proxy_credentials_request", &test_online_clone__proxy_credentials_request },
    { "proxy_credentials_in_well_formed_url", &test_online_clone__proxy_credentials_in_well_formed_url },
    { "proxy_credentials_in_host_port_format", &test_online_clone__proxy_credentials_in_host_port_format },
    { "proxy_credentials_in_environment", &test_online_clone__proxy_credentials_in_environment },
    { "proxy_credentials_in_url_https", &test_online_clone__proxy_credentials_in_url_https },
    { "proxy_auto_not_detected", &test_online_clone__proxy_auto_not_detected },
    { "proxy_cred_callback_after_failed_url_creds", &test_online_clone__proxy_cred_callback_after_failed_url_creds },
    { "azurerepos", &test_online_clone__azurerepos },
    { "path_whitespace", &test_online_clone__path_whitespace },
    { "redirect_default_succeeds_for_initial", &test_online_clone__redirect_default_succeeds_for_initial },
    { "redirect_default_fails_for_subsequent", &test_online_clone__redirect_default_fails_for_subsequent },
    { "redirect_none", &test_online_clone__redirect_none },
    { "redirect_initial_succeeds_for_initial", &test_online_clone__redirect_initial_succeeds_for_initial },
    { "redirect_initial_fails_for_subsequent", &test_online_clone__redirect_initial_fails_for_subsequent },
    { "namespace_bare", &test_online_clone__namespace_bare },
    { "namespace_with_specified_branch", &test_online_clone__namespace_with_specified_branch },
    { "sha256", &test_online_clone__sha256 },
    { "connect_timeout_configurable", &test_online_clone__connect_timeout_configurable },
    { "connect_timeout_default", &test_online_clone__connect_timeout_default },
    { "timeout_configurable_times_out", &test_online_clone__timeout_configurable_times_out },
    { "timeout_configurable_succeeds_slowly", &test_online_clone__timeout_configurable_succeeds_slowly }
};
static const struct clar_func _clar_cb_online_customcert[] = {
    { "file", &test_online_customcert__file },
    { "path", &test_online_customcert__path }
};
static const struct clar_func _clar_cb_online_fetch[] = {
    { "default_http", &test_online_fetch__default_http },
    { "default_https", &test_online_fetch__default_https },
    { "no_tags_git", &test_online_fetch__no_tags_git },
    { "no_tags_http", &test_online_fetch__no_tags_http },
    { "fetch_twice", &test_online_fetch__fetch_twice },
    { "fetch_with_empty_http_proxy", &test_online_fetch__fetch_with_empty_http_proxy },
    { "doesnt_retrieve_a_pack_when_the_repository_is_up_to_date", &test_online_fetch__doesnt_retrieve_a_pack_when_the_repository_is_up_to_date },
    { "report_unchanged_tips", &test_online_fetch__report_unchanged_tips },
    { "can_cancel", &test_online_fetch__can_cancel },
    { "ls_disconnected", &test_online_fetch__ls_disconnected },
    { "remote_symrefs", &test_online_fetch__remote_symrefs },
    { "twice", &test_online_fetch__twice },
    { "proxy", &test_online_fetch__proxy },
    { "redirect_config", &test_online_fetch__redirect_config },
    { "reachable_commit", &test_online_fetch__reachable_commit },
    { "reachable_commit_without_destination", &test_online_fetch__reachable_commit_without_destination }
};
static const struct clar_func _clar_cb_online_fetchhead[] = {
    { "wildcard_spec", &test_online_fetchhead__wildcard_spec },
    { "explicit_spec", &test_online_fetchhead__explicit_spec },
    { "no_merges", &test_online_fetchhead__no_merges },
    { "explicit_dst_refspec_creates_branch", &test_online_fetchhead__explicit_dst_refspec_creates_branch },
    { "empty_dst_refspec_creates_no_branch", &test_online_fetchhead__empty_dst_refspec_creates_no_branch },
    { "colon_only_dst_refspec_creates_no_branch", &test_online_fetchhead__colon_only_dst_refspec_creates_no_branch },
    { "creds_get_stripped", &test_online_fetchhead__creds_get_stripped }
};
static const struct clar_func _clar_cb_online_push[] = {
    { "noop", &test_online_push__noop },
    { "b1", &test_online_push__b1 },
    { "b2", &test_online_push__b2 },
    { "b3", &test_online_push__b3 },
    { "b4", &test_online_push__b4 },
    { "b5", &test_online_push__b5 },
    { "b5_cancel", &test_online_push__b5_cancel },
    { "multi", &test_online_push__multi },
    { "implicit_tgt", &test_online_push__implicit_tgt },
    { "fast_fwd", &test_online_push__fast_fwd },
    { "tag_commit", &test_online_push__tag_commit },
    { "tag_tree", &test_online_push__tag_tree },
    { "tag_blob", &test_online_push__tag_blob },
    { "tag_lightweight", &test_online_push__tag_lightweight },
    { "tag_to_tag", &test_online_push__tag_to_tag },
    { "force", &test_online_push__force },
    { "options", &test_online_push__options },
    { "delete", &test_online_push__delete },
    { "bad_refspecs", &test_online_push__bad_refspecs },
    { "expressions", &test_online_push__expressions },
    { "notes", &test_online_push__notes },
    { "configured", &test_online_push__configured }
};
static const struct clar_func _clar_cb_online_remotes[] = {
    { "single_branch", &test_online_remotes__single_branch },
    { "restricted_refspecs", &test_online_remotes__restricted_refspecs },
    { "detached_remote_fails_downloading", &test_online_remotes__detached_remote_fails_downloading },
    { "detached_remote_fails_uploading", &test_online_remotes__detached_remote_fails_uploading },
    { "detached_remote_fails_pushing", &test_online_remotes__detached_remote_fails_pushing },
    { "detached_remote_succeeds_ls", &test_online_remotes__detached_remote_succeeds_ls }
};
static const struct clar_func _clar_cb_online_shallow[] = {
    { "clone_depth_zero", &test_online_shallow__clone_depth_zero },
    { "clone_depth_one", &test_online_shallow__clone_depth_one },
    { "clone_depth_five", &test_online_shallow__clone_depth_five },
    { "unshallow", &test_online_shallow__unshallow },
    { "deepen_six", &test_online_shallow__deepen_six },
    { "shorten_four", &test_online_shallow__shorten_four },
    { "preserve_unrelated_roots", &test_online_shallow__preserve_unrelated_roots }
};
static const struct clar_func _clar_cb_pack_filelimit[] = {
    { "open_repo_with_multiple_packfiles", &test_pack_filelimit__open_repo_with_multiple_packfiles }
};
static const struct clar_func _clar_cb_pack_indexer[] = {
    { "out_of_order", &test_pack_indexer__out_of_order },
    { "missing_trailer", &test_pack_indexer__missing_trailer },
    { "leaky", &test_pack_indexer__leaky },
    { "fix_thin", &test_pack_indexer__fix_thin },
    { "corrupt_length", &test_pack_indexer__corrupt_length },
    { "incomplete_pack_fails_with_strict", &test_pack_indexer__incomplete_pack_fails_with_strict },
    { "out_of_order_with_connectivity_checks", &test_pack_indexer__out_of_order_with_connectivity_checks },
    { "no_tmp_files", &test_pack_indexer__no_tmp_files }
};
static const struct clar_func _clar_cb_pack_midx[] = {
    { "parse", &test_pack_midx__parse },
    { "lookup", &test_pack_midx__lookup },
    { "writer", &test_pack_midx__writer },
    { "odb_create", &test_pack_midx__odb_create }
};
static const struct clar_func _clar_cb_pack_packbuilder[] = {
    { "create_pack", &test_pack_packbuilder__create_pack },
    { "get_name", &test_pack_packbuilder__get_name },
    { "write_default_path", &test_pack_packbuilder__write_default_path },
    { "permissions_standard", &test_pack_packbuilder__permissions_standard },
    { "permissions_readonly", &test_pack_packbuilder__permissions_readonly },
    { "permissions_readwrite", &test_pack_packbuilder__permissions_readwrite },
    { "does_not_fsync_by_default", &test_pack_packbuilder__does_not_fsync_by_default },
    { "fsync_global_setting", &test_pack_packbuilder__fsync_global_setting },
    { "fsync_repo_setting", &test_pack_packbuilder__fsync_repo_setting },
    { "foreach", &test_pack_packbuilder__foreach },
    { "foreach_with_cancel", &test_pack_packbuilder__foreach_with_cancel },
    { "keep_file_check", &test_pack_packbuilder__keep_file_check }
};
static const struct clar_func _clar_cb_pack_sharing[] = {
    { "open_two_repos", &test_pack_sharing__open_two_repos }
};
static const struct clar_func _clar_cb_pack_threadsafety[] = {
    { "open_repo_in_multiple_threads", &test_pack_threadsafety__open_repo_in_multiple_threads }
};
static const struct clar_func _clar_cb_patch_parse[] = {
    { "original_to_change_middle", &test_patch_parse__original_to_change_middle },
    { "leading_and_trailing_garbage", &test_patch_parse__leading_and_trailing_garbage },
    { "nonpatches_fail_with_notfound", &test_patch_parse__nonpatches_fail_with_notfound },
    { "invalid_patches_fails", &test_patch_parse__invalid_patches_fails },
    { "no_newline_at_end_of_new_file", &test_patch_parse__no_newline_at_end_of_new_file },
    { "no_newline_at_end_of_old_file", &test_patch_parse__no_newline_at_end_of_old_file },
    { "files_with_whitespaces_succeeds", &test_patch_parse__files_with_whitespaces_succeeds },
    { "lifetime_of_patch_does_not_depend_on_buffer", &test_patch_parse__lifetime_of_patch_does_not_depend_on_buffer },
    { "binary_file_with_missing_paths", &test_patch_parse__binary_file_with_missing_paths },
    { "binary_file_with_whitespace_paths", &test_patch_parse__binary_file_with_whitespace_paths },
    { "binary_file_with_empty_quoted_paths", &test_patch_parse__binary_file_with_empty_quoted_paths },
    { "binary_file_path_with_spaces", &test_patch_parse__binary_file_path_with_spaces },
    { "binary_file_path_without_body_paths", &test_patch_parse__binary_file_path_without_body_paths },
    { "binary_file_with_truncated_delta", &test_patch_parse__binary_file_with_truncated_delta },
    { "memory_leak_on_multiple_paths", &test_patch_parse__memory_leak_on_multiple_paths },
    { "truncated_no_newline_at_end_of_file", &test_patch_parse__truncated_no_newline_at_end_of_file },
    { "line_number_overflow", &test_patch_parse__line_number_overflow }
};
static const struct clar_func _clar_cb_patch_print[] = {
    { "change_middle", &test_patch_print__change_middle },
    { "change_middle_nocontext", &test_patch_print__change_middle_nocontext },
    { "change_firstline", &test_patch_print__change_firstline },
    { "change_lastline", &test_patch_print__change_lastline },
    { "prepend", &test_patch_print__prepend },
    { "prepend_nocontext", &test_patch_print__prepend_nocontext },
    { "append", &test_patch_print__append },
    { "append_nocontext", &test_patch_print__append_nocontext },
    { "prepend_and_append", &test_patch_print__prepend_and_append },
    { "to_empty_file", &test_patch_print__to_empty_file },
    { "from_empty_file", &test_patch_print__from_empty_file },
    { "add", &test_patch_print__add },
    { "delete", &test_patch_print__delete },
    { "rename_exact", &test_patch_print__rename_exact },
    { "rename_exact_with_mode", &test_patch_print__rename_exact_with_mode },
    { "rename_similar", &test_patch_print__rename_similar },
    { "rename_exact_quotedname", &test_patch_print__rename_exact_quotedname },
    { "rename_similar_quotedname", &test_patch_print__rename_similar_quotedname },
    { "modechange_unchanged", &test_patch_print__modechange_unchanged },
    { "modechange_modified", &test_patch_print__modechange_modified },
    { "binary_literal", &test_patch_print__binary_literal },
    { "binary_delta", &test_patch_print__binary_delta },
    { "binary_add", &test_patch_print__binary_add },
    { "binary_delete", &test_patch_print__binary_delete },
    { "not_reversible", &test_patch_print__not_reversible },
    { "binary_not_shown", &test_patch_print__binary_not_shown },
    { "binary_add_not_shown", &test_patch_print__binary_add_not_shown }
};
static const struct clar_func _clar_cb_path_validate[] = {
    { "length", &test_path_validate__length },
    { "length_with_core_longpath", &test_path_validate__length_with_core_longpath }
};
static const struct clar_func _clar_cb_perf_merge[] = {
    { "m1", &test_perf_merge__m1 }
};
static const struct clar_func _clar_cb_rebase_abort[] = {
    { "merge", &test_rebase_abort__merge },
    { "merge_immediately_after_init", &test_rebase_abort__merge_immediately_after_init },
    { "merge_by_id", &test_rebase_abort__merge_by_id },
    { "merge_by_revspec", &test_rebase_abort__merge_by_revspec },
    { "merge_by_id_immediately_after_init", &test_rebase_abort__merge_by_id_immediately_after_init },
    { "detached_head", &test_rebase_abort__detached_head },
    { "old_style_head_file", &test_rebase_abort__old_style_head_file }
};
static const struct clar_func _clar_cb_rebase_inmemory[] = {
    { "not_in_rebase_state", &test_rebase_inmemory__not_in_rebase_state },
    { "can_resolve_conflicts", &test_rebase_inmemory__can_resolve_conflicts },
    { "no_common_ancestor", &test_rebase_inmemory__no_common_ancestor },
    { "with_directories", &test_rebase_inmemory__with_directories }
};
static const struct clar_func _clar_cb_rebase_iterator[] = {
    { "iterates", &test_rebase_iterator__iterates },
    { "iterates_inmemory", &test_rebase_iterator__iterates_inmemory }
};
static const struct clar_func _clar_cb_rebase_merge[] = {
    { "next", &test_rebase_merge__next },
    { "next_with_conflicts", &test_rebase_merge__next_with_conflicts },
    { "next_stops_with_iterover", &test_rebase_merge__next_stops_with_iterover },
    { "commit", &test_rebase_merge__commit },
    { "commit_with_id", &test_rebase_merge__commit_with_id },
    { "blocked_when_dirty", &test_rebase_merge__blocked_when_dirty },
    { "commit_updates_rewritten", &test_rebase_merge__commit_updates_rewritten },
    { "commit_drops_already_applied", &test_rebase_merge__commit_drops_already_applied },
    { "finish", &test_rebase_merge__finish },
    { "detached_finish", &test_rebase_merge__detached_finish },
    { "finish_with_ids", &test_rebase_merge__finish_with_ids },
    { "no_common_ancestor", &test_rebase_merge__no_common_ancestor },
    { "copy_notes_off_by_default", &test_rebase_merge__copy_notes_off_by_default },
    { "copy_notes_specified_in_options", &test_rebase_merge__copy_notes_specified_in_options },
    { "copy_notes_specified_in_config", &test_rebase_merge__copy_notes_specified_in_config },
    { "copy_notes_disabled_in_config", &test_rebase_merge__copy_notes_disabled_in_config },
    { "custom_checkout_options", &test_rebase_merge__custom_checkout_options },
    { "custom_merge_options", &test_rebase_merge__custom_merge_options },
    { "with_directories", &test_rebase_merge__with_directories }
};
static const struct clar_func _clar_cb_rebase_setup[] = {
    { "blocked_when_in_progress", &test_rebase_setup__blocked_when_in_progress },
    { "merge", &test_rebase_setup__merge },
    { "merge_root", &test_rebase_setup__merge_root },
    { "merge_onto_and_upstream", &test_rebase_setup__merge_onto_and_upstream },
    { "merge_onto_upstream_and_branch", &test_rebase_setup__merge_onto_upstream_and_branch },
    { "merge_onto_upstream_and_branch_by_id", &test_rebase_setup__merge_onto_upstream_and_branch_by_id },
    { "branch_with_merges", &test_rebase_setup__branch_with_merges },
    { "orphan_branch", &test_rebase_setup__orphan_branch },
    { "merge_null_branch_uses_HEAD", &test_rebase_setup__merge_null_branch_uses_HEAD },
    { "merge_from_detached", &test_rebase_setup__merge_from_detached },
    { "merge_branch_by_id", &test_rebase_setup__merge_branch_by_id },
    { "blocked_for_staged_change", &test_rebase_setup__blocked_for_staged_change },
    { "blocked_for_unstaged_change", &test_rebase_setup__blocked_for_unstaged_change },
    { "not_blocked_for_untracked_add", &test_rebase_setup__not_blocked_for_untracked_add }
};
static const struct clar_func _clar_cb_rebase_sign[] = {
    { "passthrough_create_cb", &test_rebase_sign__passthrough_create_cb },
    { "create_gpg_signed", &test_rebase_sign__create_gpg_signed },
    { "create_propagates_error", &test_rebase_sign__create_propagates_error },
    { "passthrough_signing_cb", &test_rebase_sign__passthrough_signing_cb },
    { "gpg_with_no_field", &test_rebase_sign__gpg_with_no_field },
    { "custom_signature_field", &test_rebase_sign__custom_signature_field }
};
static const struct clar_func _clar_cb_rebase_submodule[] = {
    { "init_untracked", &test_rebase_submodule__init_untracked }
};
static const struct clar_func _clar_cb_refs_basic[] = {
    { "reference_realloc", &test_refs_basic__reference_realloc },
    { "longpaths", &test_refs_basic__longpaths }
};
static const struct clar_func _clar_cb_refs_branches_checkedout[] = {
    { "simple_repo", &test_refs_branches_checkedout__simple_repo },
    { "worktree", &test_refs_branches_checkedout__worktree },
    { "head_is_not_checked_out", &test_refs_branches_checkedout__head_is_not_checked_out },
    { "master_in_bare_repo_is_not_checked_out", &test_refs_branches_checkedout__master_in_bare_repo_is_not_checked_out }
};
static const struct clar_func _clar_cb_refs_branches_create[] = {
    { "can_create_a_local_branch", &test_refs_branches_create__can_create_a_local_branch },
    { "can_not_create_a_branch_if_its_name_collide_with_an_existing_one", &test_refs_branches_create__can_not_create_a_branch_if_its_name_collide_with_an_existing_one },
    { "can_force_create_over_an_existing_branch", &test_refs_branches_create__can_force_create_over_an_existing_branch },
    { "cannot_force_create_over_current_branch_in_nonbare_repo", &test_refs_branches_create__cannot_force_create_over_current_branch_in_nonbare_repo },
    { "can_force_create_over_current_branch_in_bare_repo", &test_refs_branches_create__can_force_create_over_current_branch_in_bare_repo },
    { "creating_a_branch_with_an_invalid_name_returns_EINVALIDSPEC", &test_refs_branches_create__creating_a_branch_with_an_invalid_name_returns_EINVALIDSPEC },
    { "can_create_branch_with_unicode", &test_refs_branches_create__can_create_branch_with_unicode },
    { "name_vs_namespace", &test_refs_branches_create__name_vs_namespace },
    { "name_vs_namespace_fail", &test_refs_branches_create__name_vs_namespace_fail },
    { "error_when_create_branch_with_invalid_name", &test_refs_branches_create__error_when_create_branch_with_invalid_name }
};
static const struct clar_func _clar_cb_refs_branches_delete[] = {
    { "can_not_delete_a_branch_pointed_at_by_HEAD", &test_refs_branches_delete__can_not_delete_a_branch_pointed_at_by_HEAD },
    { "can_delete_a_branch_even_if_HEAD_is_missing", &test_refs_branches_delete__can_delete_a_branch_even_if_HEAD_is_missing },
    { "can_delete_a_branch_when_HEAD_is_unborn", &test_refs_branches_delete__can_delete_a_branch_when_HEAD_is_unborn },
    { "can_delete_a_branch_pointed_at_by_detached_HEAD", &test_refs_branches_delete__can_delete_a_branch_pointed_at_by_detached_HEAD },
    { "can_delete_a_local_branch", &test_refs_branches_delete__can_delete_a_local_branch },
    { "can_delete_a_local_branch_with_multivar", &test_refs_branches_delete__can_delete_a_local_branch_with_multivar },
    { "can_delete_a_remote_branch", &test_refs_branches_delete__can_delete_a_remote_branch },
    { "deleting_a_branch_removes_related_configuration_data", &test_refs_branches_delete__deleting_a_branch_removes_related_configuration_data },
    { "removes_reflog", &test_refs_branches_delete__removes_reflog },
    { "removes_empty_folders", &test_refs_branches_delete__removes_empty_folders }
};
static const struct clar_func _clar_cb_refs_branches_ishead[] = {
    { "can_tell_if_a_branch_is_pointed_at_by_HEAD", &test_refs_branches_ishead__can_tell_if_a_branch_is_pointed_at_by_HEAD },
    { "can_properly_handle_unborn_HEAD", &test_refs_branches_ishead__can_properly_handle_unborn_HEAD },
    { "can_properly_handle_missing_HEAD", &test_refs_branches_ishead__can_properly_handle_missing_HEAD },
    { "can_tell_if_a_branch_is_not_pointed_at_by_HEAD", &test_refs_branches_ishead__can_tell_if_a_branch_is_not_pointed_at_by_HEAD },
    { "wont_be_fooled_by_a_non_branch", &test_refs_branches_ishead__wont_be_fooled_by_a_non_branch },
    { "only_direct_references_are_considered", &test_refs_branches_ishead__only_direct_references_are_considered }
};
static const struct clar_func _clar_cb_refs_branches_iterator[] = {
    { "retrieve_all_branches", &test_refs_branches_iterator__retrieve_all_branches },
    { "retrieve_remote_branches", &test_refs_branches_iterator__retrieve_remote_branches },
    { "retrieve_local_branches", &test_refs_branches_iterator__retrieve_local_branches },
    { "retrieve_remote_symbolic_HEAD_when_present", &test_refs_branches_iterator__retrieve_remote_symbolic_HEAD_when_present },
    { "mix_of_packed_and_loose", &test_refs_branches_iterator__mix_of_packed_and_loose }
};
static const struct clar_func _clar_cb_refs_branches_lookup[] = {
    { "can_retrieve_a_local_branch_local", &test_refs_branches_lookup__can_retrieve_a_local_branch_local },
    { "can_retrieve_a_local_branch_all", &test_refs_branches_lookup__can_retrieve_a_local_branch_all },
    { "trying_to_retrieve_a_local_branch_remote", &test_refs_branches_lookup__trying_to_retrieve_a_local_branch_remote },
    { "can_retrieve_a_remote_tracking_branch_remote", &test_refs_branches_lookup__can_retrieve_a_remote_tracking_branch_remote },
    { "can_retrieve_a_remote_tracking_branch_all", &test_refs_branches_lookup__can_retrieve_a_remote_tracking_branch_all },
    { "trying_to_retrieve_a_remote_tracking_branch_local", &test_refs_branches_lookup__trying_to_retrieve_a_remote_tracking_branch_local },
    { "trying_to_retrieve_an_unknown_branch_returns_ENOTFOUND", &test_refs_branches_lookup__trying_to_retrieve_an_unknown_branch_returns_ENOTFOUND },
    { "trying_to_retrieve_a_branch_with_an_invalid_name_returns_EINVALIDSPEC", &test_refs_branches_lookup__trying_to_retrieve_a_branch_with_an_invalid_name_returns_EINVALIDSPEC }
};
static const struct clar_func _clar_cb_refs_branches_move[] = {
    { "can_move_a_local_branch", &test_refs_branches_move__can_move_a_local_branch },
    { "can_move_a_local_branch_to_a_different_namespace", &test_refs_branches_move__can_move_a_local_branch_to_a_different_namespace },
    { "can_move_a_local_branch_to_a_partially_colliding_namespace", &test_refs_branches_move__can_move_a_local_branch_to_a_partially_colliding_namespace },
    { "can_not_move_a_branch_if_its_destination_name_collide_with_an_existing_one", &test_refs_branches_move__can_not_move_a_branch_if_its_destination_name_collide_with_an_existing_one },
    { "moving_a_branch_with_an_invalid_name_returns_EINVALIDSPEC", &test_refs_branches_move__moving_a_branch_with_an_invalid_name_returns_EINVALIDSPEC },
    { "can_not_move_a_non_branch", &test_refs_branches_move__can_not_move_a_non_branch },
    { "can_force_move_over_an_existing_branch", &test_refs_branches_move__can_force_move_over_an_existing_branch },
    { "moving_a_branch_moves_related_configuration_data", &test_refs_branches_move__moving_a_branch_moves_related_configuration_data },
    { "moving_the_branch_pointed_at_by_HEAD_updates_HEAD", &test_refs_branches_move__moving_the_branch_pointed_at_by_HEAD_updates_HEAD },
    { "can_move_with_unicode", &test_refs_branches_move__can_move_with_unicode },
    { "moves_reflog_correctly", &test_refs_branches_move__moves_reflog_correctly },
    { "failed_move_restores_reflog", &test_refs_branches_move__failed_move_restores_reflog }
};
static const struct clar_func _clar_cb_refs_branches_name[] = {
    { "can_get_local_branch_name", &test_refs_branches_name__can_get_local_branch_name },
    { "can_get_remote_branch_name", &test_refs_branches_name__can_get_remote_branch_name },
    { "error_when_ref_is_no_branch", &test_refs_branches_name__error_when_ref_is_no_branch },
    { "is_name_valid", &test_refs_branches_name__is_name_valid }
};
static const struct clar_func _clar_cb_refs_branches_remote[] = {
    { "can_get_remote_for_branch", &test_refs_branches_remote__can_get_remote_for_branch },
    { "no_matching_remote_returns_error", &test_refs_branches_remote__no_matching_remote_returns_error },
    { "local_remote_returns_error", &test_refs_branches_remote__local_remote_returns_error },
    { "ambiguous_remote_returns_error", &test_refs_branches_remote__ambiguous_remote_returns_error }
};
static const struct clar_func _clar_cb_refs_branches_upstream[] = {
    { "can_retrieve_the_remote_tracking_reference_of_a_local_branch", &test_refs_branches_upstream__can_retrieve_the_remote_tracking_reference_of_a_local_branch },
    { "can_retrieve_the_local_upstream_reference_of_a_local_branch", &test_refs_branches_upstream__can_retrieve_the_local_upstream_reference_of_a_local_branch },
    { "cannot_retrieve_a_remote_upstream_reference_from_a_non_branch", &test_refs_branches_upstream__cannot_retrieve_a_remote_upstream_reference_from_a_non_branch },
    { "trying_to_retrieve_a_remote_tracking_reference_from_a_plain_local_branch_returns_GIT_ENOTFOUND", &test_refs_branches_upstream__trying_to_retrieve_a_remote_tracking_reference_from_a_plain_local_branch_returns_GIT_ENOTFOUND },
    { "trying_to_retrieve_a_remote_tracking_reference_from_a_branch_with_no_fetchspec_returns_GIT_ENOTFOUND", &test_refs_branches_upstream__trying_to_retrieve_a_remote_tracking_reference_from_a_branch_with_no_fetchspec_returns_GIT_ENOTFOUND },
    { "upstream_remote", &test_refs_branches_upstream__upstream_remote },
    { "upstream_merge", &test_refs_branches_upstream__upstream_merge },
    { "upstream_remote_empty_value", &test_refs_branches_upstream__upstream_remote_empty_value },
    { "retrieve_a_remote_tracking_reference_from_a_branch_with_no_remote_returns_GIT_ENOTFOUND", &test_refs_branches_upstream__retrieve_a_remote_tracking_reference_from_a_branch_with_no_remote_returns_GIT_ENOTFOUND },
    { "set_unset_upstream", &test_refs_branches_upstream__set_unset_upstream },
    { "no_fetch_refspec", &test_refs_branches_upstream__no_fetch_refspec }
};
static const struct clar_func _clar_cb_refs_branches_upstreamname[] = {
    { "can_retrieve_the_remote_tracking_reference_name_of_a_local_branch", &test_refs_branches_upstreamname__can_retrieve_the_remote_tracking_reference_name_of_a_local_branch },
    { "can_retrieve_the_local_upstream_reference_name_of_a_local_branch", &test_refs_branches_upstreamname__can_retrieve_the_local_upstream_reference_name_of_a_local_branch }
};
static const struct clar_func _clar_cb_refs_crashes[] = {
    { "double_free", &test_refs_crashes__double_free },
    { "empty_packedrefs", &test_refs_crashes__empty_packedrefs }
};
static const struct clar_func _clar_cb_refs_create[] = {
    { "symbolic", &test_refs_create__symbolic },
    { "symbolic_with_arbitrary_content", &test_refs_create__symbolic_with_arbitrary_content },
    { "deep_symbolic", &test_refs_create__deep_symbolic },
    { "oid", &test_refs_create__oid },
    { "oid_unknown_succeeds_without_strict", &test_refs_create__oid_unknown_succeeds_without_strict },
    { "oid_unknown_fails_by_default", &test_refs_create__oid_unknown_fails_by_default },
    { "propagate_eexists", &test_refs_create__propagate_eexists },
    { "existing_dir_propagates_edirectory", &test_refs_create__existing_dir_propagates_edirectory },
    { "creating_a_reference_with_an_invalid_name_returns_EINVALIDSPEC", &test_refs_create__creating_a_reference_with_an_invalid_name_returns_EINVALIDSPEC },
    { "creating_a_loose_ref_with_invalid_windows_name", &test_refs_create__creating_a_loose_ref_with_invalid_windows_name },
    { "does_not_fsync_by_default", &test_refs_create__does_not_fsync_by_default },
    { "fsyncs_when_global_opt_set", &test_refs_create__fsyncs_when_global_opt_set },
    { "fsyncs_when_repo_config_set", &test_refs_create__fsyncs_when_repo_config_set }
};
static const struct clar_func _clar_cb_refs_delete[] = {
    { "packed_loose", &test_refs_delete__packed_loose },
    { "packed_only", &test_refs_delete__packed_only },
    { "remove", &test_refs_delete__remove },
    { "head", &test_refs_delete__head }
};
static const struct clar_func _clar_cb_refs_dup[] = {
    { "direct", &test_refs_dup__direct },
    { "symbolic", &test_refs_dup__symbolic }
};
static const struct clar_func _clar_cb_refs_foreachglob[] = {
    { "retrieve_all_refs", &test_refs_foreachglob__retrieve_all_refs },
    { "retrieve_remote_branches", &test_refs_foreachglob__retrieve_remote_branches },
    { "retrieve_local_branches", &test_refs_foreachglob__retrieve_local_branches },
    { "retrieve_nonexistant", &test_refs_foreachglob__retrieve_nonexistant },
    { "retrieve_partially_named_references", &test_refs_foreachglob__retrieve_partially_named_references },
    { "can_cancel", &test_refs_foreachglob__can_cancel }
};
static const struct clar_func _clar_cb_refs_isvalidname[] = {
    { "can_detect_invalid_formats", &test_refs_isvalidname__can_detect_invalid_formats },
    { "wont_hopefully_choke_on_valid_formats", &test_refs_isvalidname__wont_hopefully_choke_on_valid_formats }
};
static const struct clar_func _clar_cb_refs_iterator[] = {
    { "list", &test_refs_iterator__list },
    { "empty", &test_refs_iterator__empty },
    { "foreach", &test_refs_iterator__foreach },
    { "foreach_through_symlink", &test_refs_iterator__foreach_through_symlink },
    { "foreach_can_cancel", &test_refs_iterator__foreach_can_cancel },
    { "foreach_name", &test_refs_iterator__foreach_name },
    { "foreach_name_can_cancel", &test_refs_iterator__foreach_name_can_cancel },
    { "concurrent_delete", &test_refs_iterator__concurrent_delete }
};
static const struct clar_func _clar_cb_refs_list[] = {
    { "all", &test_refs_list__all },
    { "do_not_retrieve_references_which_name_end_with_a_lock_extension", &test_refs_list__do_not_retrieve_references_which_name_end_with_a_lock_extension }
};
static const struct clar_func _clar_cb_refs_listall[] = {
    { "from_repository_opened_through_workdir_path", &test_refs_listall__from_repository_opened_through_workdir_path },
    { "from_repository_opened_through_gitdir_path", &test_refs_listall__from_repository_opened_through_gitdir_path },
    { "from_repository_with_no_trailing_newline", &test_refs_listall__from_repository_with_no_trailing_newline }
};
static const struct clar_func _clar_cb_refs_lookup[] = {
    { "with_resolve", &test_refs_lookup__with_resolve },
    { "invalid_name", &test_refs_lookup__invalid_name },
    { "oid", &test_refs_lookup__oid },
    { "namespace", &test_refs_lookup__namespace },
    { "dwim_notfound", &test_refs_lookup__dwim_notfound }
};
static const struct clar_func _clar_cb_refs_namespaces[] = {
    { "get_and_set", &test_refs_namespaces__get_and_set },
    { "namespace_doesnt_show_normal_refs", &test_refs_namespaces__namespace_doesnt_show_normal_refs }
};
static const struct clar_func _clar_cb_refs_normalize[] = {
    { "can_normalize_a_direct_reference_name", &test_refs_normalize__can_normalize_a_direct_reference_name },
    { "cannot_normalize_any_direct_reference_name", &test_refs_normalize__cannot_normalize_any_direct_reference_name },
    { "symbolic", &test_refs_normalize__symbolic },
    { "jgit_suite", &test_refs_normalize__jgit_suite },
    { "buffer_has_to_be_big_enough_to_hold_the_normalized_version", &test_refs_normalize__buffer_has_to_be_big_enough_to_hold_the_normalized_version },
    { "refspec_pattern", &test_refs_normalize__refspec_pattern }
};
static const struct clar_func _clar_cb_refs_overwrite[] = {
    { "symbolic", &test_refs_overwrite__symbolic },
    { "object_id", &test_refs_overwrite__object_id },
    { "object_id_with_symbolic", &test_refs_overwrite__object_id_with_symbolic },
    { "symbolic_with_object_id", &test_refs_overwrite__symbolic_with_object_id }
};
static const struct clar_func _clar_cb_refs_pack[] = {
    { "empty", &test_refs_pack__empty },
    { "loose", &test_refs_pack__loose },
    { "symbolic", &test_refs_pack__symbolic }
};
static const struct clar_func _clar_cb_refs_peel[] = {
    { "can_peel_a_tag", &test_refs_peel__can_peel_a_tag },
    { "can_peel_a_branch", &test_refs_peel__can_peel_a_branch },
    { "can_peel_a_symbolic_reference", &test_refs_peel__can_peel_a_symbolic_reference },
    { "cannot_peel_into_a_non_existing_target", &test_refs_peel__cannot_peel_into_a_non_existing_target },
    { "can_peel_into_any_non_tag_object", &test_refs_peel__can_peel_into_any_non_tag_object },
    { "can_peel_fully_peeled_packed_refs", &test_refs_peel__can_peel_fully_peeled_packed_refs },
    { "can_peel_fully_peeled_tag_to_tag", &test_refs_peel__can_peel_fully_peeled_tag_to_tag }
};
static const struct clar_func _clar_cb_refs_races[] = {
    { "create_matching_zero_old", &test_refs_races__create_matching_zero_old },
    { "create_matching", &test_refs_races__create_matching },
    { "symbolic_create_matching", &test_refs_races__symbolic_create_matching },
    { "delete", &test_refs_races__delete },
    { "switch_oid_to_symbolic", &test_refs_races__switch_oid_to_symbolic },
    { "switch_symbolic_to_oid", &test_refs_races__switch_symbolic_to_oid }
};
static const struct clar_func _clar_cb_refs_read[] = {
    { "loose_tag", &test_refs_read__loose_tag },
    { "nonexisting_tag", &test_refs_read__nonexisting_tag },
    { "symbolic", &test_refs_read__symbolic },
    { "nested_symbolic", &test_refs_read__nested_symbolic },
    { "head_then_master", &test_refs_read__head_then_master },
    { "master_then_head", &test_refs_read__master_then_head },
    { "packed", &test_refs_read__packed },
    { "loose_first", &test_refs_read__loose_first },
    { "chomped", &test_refs_read__chomped },
    { "trailing", &test_refs_read__trailing },
    { "unfound_return_ENOTFOUND", &test_refs_read__unfound_return_ENOTFOUND },
    { "can_determine_if_a_reference_is_a_local_branch", &test_refs_read__can_determine_if_a_reference_is_a_local_branch },
    { "can_determine_if_a_reference_is_a_tag", &test_refs_read__can_determine_if_a_reference_is_a_tag },
    { "can_determine_if_a_reference_is_a_note", &test_refs_read__can_determine_if_a_reference_is_a_note },
    { "invalid_name_returns_EINVALIDSPEC", &test_refs_read__invalid_name_returns_EINVALIDSPEC }
};
static const struct clar_func _clar_cb_refs_reflog_drop[] = {
    { "dropping_a_non_exisiting_entry_from_the_log_returns_ENOTFOUND", &test_refs_reflog_drop__dropping_a_non_exisiting_entry_from_the_log_returns_ENOTFOUND },
    { "can_drop_an_entry", &test_refs_reflog_drop__can_drop_an_entry },
    { "can_drop_an_entry_and_rewrite_the_log_history", &test_refs_reflog_drop__can_drop_an_entry_and_rewrite_the_log_history },
    { "can_drop_the_oldest_entry", &test_refs_reflog_drop__can_drop_the_oldest_entry },
    { "can_drop_the_oldest_entry_and_rewrite_the_log_history", &test_refs_reflog_drop__can_drop_the_oldest_entry_and_rewrite_the_log_history },
    { "can_drop_all_the_entries", &test_refs_reflog_drop__can_drop_all_the_entries },
    { "can_persist_deletion_on_disk", &test_refs_reflog_drop__can_persist_deletion_on_disk }
};
static const struct clar_func _clar_cb_refs_reflog_messages[] = {
    { "setting_head_updates_reflog", &test_refs_reflog_messages__setting_head_updates_reflog },
    { "setting_head_to_same_target_ignores_reflog", &test_refs_reflog_messages__setting_head_to_same_target_ignores_reflog },
    { "detaching_writes_reflog", &test_refs_reflog_messages__detaching_writes_reflog },
    { "orphan_branch_does_not_count", &test_refs_reflog_messages__orphan_branch_does_not_count },
    { "branch_birth", &test_refs_reflog_messages__branch_birth },
    { "commit_on_symbolic_ref_updates_head_reflog", &test_refs_reflog_messages__commit_on_symbolic_ref_updates_head_reflog },
    { "show_merge_for_merge_commits", &test_refs_reflog_messages__show_merge_for_merge_commits },
    { "creating_a_direct_reference", &test_refs_reflog_messages__creating_a_direct_reference },
    { "newline_gets_replaced", &test_refs_reflog_messages__newline_gets_replaced },
    { "renaming_ref", &test_refs_reflog_messages__renaming_ref },
    { "updating_a_direct_reference", &test_refs_reflog_messages__updating_a_direct_reference },
    { "creating_branches_default_messages", &test_refs_reflog_messages__creating_branches_default_messages },
    { "moving_branch_default_message", &test_refs_reflog_messages__moving_branch_default_message },
    { "detaching_head_default_message", &test_refs_reflog_messages__detaching_head_default_message }
};
static const struct clar_func _clar_cb_refs_reflog_reflog[] = {
    { "append_then_read", &test_refs_reflog_reflog__append_then_read },
    { "renaming_the_reference_moves_the_reflog", &test_refs_reflog_reflog__renaming_the_reference_moves_the_reflog },
    { "deleting_the_reference_deletes_the_reflog", &test_refs_reflog_reflog__deleting_the_reference_deletes_the_reflog },
    { "removes_empty_reflog_dir", &test_refs_reflog_reflog__removes_empty_reflog_dir },
    { "fails_gracefully_on_nonempty_reflog_dir", &test_refs_reflog_reflog__fails_gracefully_on_nonempty_reflog_dir },
    { "reference_has_reflog", &test_refs_reflog_reflog__reference_has_reflog },
    { "reading_the_reflog_from_a_reference_with_no_log_returns_an_empty_one", &test_refs_reflog_reflog__reading_the_reflog_from_a_reference_with_no_log_returns_an_empty_one },
    { "reading_a_reflog_with_invalid_format_succeeds", &test_refs_reflog_reflog__reading_a_reflog_with_invalid_format_succeeds },
    { "cannot_write_a_moved_reflog", &test_refs_reflog_reflog__cannot_write_a_moved_reflog },
    { "renaming_with_an_invalid_name_returns_EINVALIDSPEC", &test_refs_reflog_reflog__renaming_with_an_invalid_name_returns_EINVALIDSPEC },
    { "write_only_std_locations", &test_refs_reflog_reflog__write_only_std_locations },
    { "write_when_explicitly_active", &test_refs_reflog_reflog__write_when_explicitly_active },
    { "append_to_HEAD_when_changing_current_branch", &test_refs_reflog_reflog__append_to_HEAD_when_changing_current_branch },
    { "do_not_append_when_no_update", &test_refs_reflog_reflog__do_not_append_when_no_update },
    { "logallrefupdates_bare_set_false", &test_refs_reflog_reflog__logallrefupdates_bare_set_false },
    { "logallrefupdates_bare_set_always", &test_refs_reflog_reflog__logallrefupdates_bare_set_always },
    { "logallrefupdates_bare_unset", &test_refs_reflog_reflog__logallrefupdates_bare_unset },
    { "logallrefupdates_nonbare_set_false", &test_refs_reflog_reflog__logallrefupdates_nonbare_set_false }
};
static const struct clar_func _clar_cb_refs_rename[] = {
    { "loose", &test_refs_rename__loose },
    { "packed", &test_refs_rename__packed },
    { "packed_doesnt_pack_others", &test_refs_rename__packed_doesnt_pack_others },
    { "name_collision", &test_refs_rename__name_collision },
    { "invalid_name", &test_refs_rename__invalid_name },
    { "force_loose_packed", &test_refs_rename__force_loose_packed },
    { "force_loose", &test_refs_rename__force_loose },
    { "overwrite", &test_refs_rename__overwrite },
    { "prefix", &test_refs_rename__prefix },
    { "move_up", &test_refs_rename__move_up },
    { "propagate_eexists", &test_refs_rename__propagate_eexists }
};
static const struct clar_func _clar_cb_refs_revparse[] = {
    { "nonexistant_object", &test_refs_revparse__nonexistant_object },
    { "invalid_reference_name", &test_refs_revparse__invalid_reference_name },
    { "shas", &test_refs_revparse__shas },
    { "head", &test_refs_revparse__head },
    { "full_refs", &test_refs_revparse__full_refs },
    { "partial_refs", &test_refs_revparse__partial_refs },
    { "describe_output", &test_refs_revparse__describe_output },
    { "nth_parent", &test_refs_revparse__nth_parent },
    { "not_tag", &test_refs_revparse__not_tag },
    { "to_type", &test_refs_revparse__to_type },
    { "linear_history", &test_refs_revparse__linear_history },
    { "chaining", &test_refs_revparse__chaining },
    { "upstream", &test_refs_revparse__upstream },
    { "ordinal", &test_refs_revparse__ordinal },
    { "previous_head", &test_refs_revparse__previous_head },
    { "reflog_of_a_ref_under_refs", &test_refs_revparse__reflog_of_a_ref_under_refs },
    { "revwalk", &test_refs_revparse__revwalk },
    { "date", &test_refs_revparse__date },
    { "invalid_date", &test_refs_revparse__invalid_date },
    { "colon", &test_refs_revparse__colon },
    { "disambiguation", &test_refs_revparse__disambiguation },
    { "a_too_short_objectid_returns_EAMBIGUOUS", &test_refs_revparse__a_too_short_objectid_returns_EAMBIGUOUS },
    { "a_not_precise_enough_objectid_returns_EAMBIGUOUS", &test_refs_revparse__a_not_precise_enough_objectid_returns_EAMBIGUOUS },
    { "issue_994", &test_refs_revparse__issue_994 },
    { "try_to_retrieve_branch_before_described_tag", &test_refs_revparse__try_to_retrieve_branch_before_described_tag },
    { "try_to_retrieve_sha_before_branch", &test_refs_revparse__try_to_retrieve_sha_before_branch },
    { "try_to_retrieve_branch_before_abbrev_sha", &test_refs_revparse__try_to_retrieve_branch_before_abbrev_sha },
    { "at_at_end_of_refname", &test_refs_revparse__at_at_end_of_refname },
    { "range", &test_refs_revparse__range },
    { "parses_range_operator", &test_refs_revparse__parses_range_operator },
    { "ext_retrieves_both_the_reference_and_its_target", &test_refs_revparse__ext_retrieves_both_the_reference_and_its_target },
    { "ext_can_expand_short_reference_names", &test_refs_revparse__ext_can_expand_short_reference_names },
    { "ext_returns_NULL_reference_when_expression_points_at_a_revision", &test_refs_revparse__ext_returns_NULL_reference_when_expression_points_at_a_revision },
    { "ext_returns_NULL_reference_when_expression_points_at_a_tree_content", &test_refs_revparse__ext_returns_NULL_reference_when_expression_points_at_a_tree_content },
    { "uneven_sizes", &test_refs_revparse__uneven_sizes },
    { "parses_at_head", &test_refs_revparse__parses_at_head }
};
static const struct clar_func _clar_cb_refs_setter[] = {
    { "update_direct", &test_refs_setter__update_direct },
    { "update_symbolic", &test_refs_setter__update_symbolic },
    { "cant_update_direct_with_symbolic", &test_refs_setter__cant_update_direct_with_symbolic },
    { "cant_update_symbolic_with_direct", &test_refs_setter__cant_update_symbolic_with_direct }
};
static const struct clar_func _clar_cb_refs_shorthand[] = {
    { "0", &test_refs_shorthand__0 }
};
static const struct clar_func _clar_cb_refs_tags_name[] = {
    { "is_name_valid", &test_refs_tags_name__is_name_valid }
};
static const struct clar_func _clar_cb_refs_transactions[] = {
    { "single_ref_oid", &test_refs_transactions__single_ref_oid },
    { "single_ref_symbolic", &test_refs_transactions__single_ref_symbolic },
    { "single_ref_mix_types", &test_refs_transactions__single_ref_mix_types },
    { "single_ref_delete", &test_refs_transactions__single_ref_delete },
    { "single_create", &test_refs_transactions__single_create },
    { "unlocked_set", &test_refs_transactions__unlocked_set },
    { "error_on_locking_locked_ref", &test_refs_transactions__error_on_locking_locked_ref },
    { "commit_unlocks_unmodified_ref", &test_refs_transactions__commit_unlocks_unmodified_ref },
    { "free_unlocks_unmodified_ref", &test_refs_transactions__free_unlocks_unmodified_ref }
};
static const struct clar_func _clar_cb_refs_unicode[] = {
    { "create_and_lookup", &test_refs_unicode__create_and_lookup }
};
static const struct clar_func _clar_cb_refs_update[] = {
    { "updating_the_target_of_a_symref_with_an_invalid_name_returns_EINVALIDSPEC", &test_refs_update__updating_the_target_of_a_symref_with_an_invalid_name_returns_EINVALIDSPEC }
};
static const struct clar_func _clar_cb_remote_create[] = {
    { "manual", &test_remote_create__manual },
    { "named", &test_remote_create__named },
    { "named_fail_on_invalid_name", &test_remote_create__named_fail_on_invalid_name },
    { "named_fail_on_invalid_url", &test_remote_create__named_fail_on_invalid_url },
    { "named_fail_on_conflicting_name", &test_remote_create__named_fail_on_conflicting_name },
    { "with_fetchspec", &test_remote_create__with_fetchspec },
    { "with_empty_fetchspec", &test_remote_create__with_empty_fetchspec },
    { "with_fetchspec_invalid_name", &test_remote_create__with_fetchspec_invalid_name },
    { "with_fetchspec_invalid_url", &test_remote_create__with_fetchspec_invalid_url },
    { "anonymous", &test_remote_create__anonymous },
    { "anonymous_invalid_url", &test_remote_create__anonymous_invalid_url },
    { "detached", &test_remote_create__detached },
    { "detached_invalid_url", &test_remote_create__detached_invalid_url },
    { "with_opts_named", &test_remote_create__with_opts_named },
    { "with_opts_named_and_fetchspec", &test_remote_create__with_opts_named_and_fetchspec },
    { "with_opts_named_no_fetchspec", &test_remote_create__with_opts_named_no_fetchspec },
    { "with_opts_anonymous", &test_remote_create__with_opts_anonymous },
    { "with_opts_detached", &test_remote_create__with_opts_detached },
    { "with_opts_insteadof_disabled", &test_remote_create__with_opts_insteadof_disabled },
    { "with_opts_invalid_name", &test_remote_create__with_opts_invalid_name },
    { "with_opts_conflicting_name", &test_remote_create__with_opts_conflicting_name },
    { "with_opts_invalid_url", &test_remote_create__with_opts_invalid_url }
};
static const struct clar_func _clar_cb_remote_fetch[] = {
    { "dont_update_refs_if_not_descendant_and_not_force", &test_remote_fetch__dont_update_refs_if_not_descendant_and_not_force },
    { "do_update_refs_if_not_descendant_and_force", &test_remote_fetch__do_update_refs_if_not_descendant_and_force }
};
static const struct clar_func _clar_cb_remote_httpproxy[] = {
    { "config_overrides", &test_remote_httpproxy__config_overrides },
    { "config_empty_overrides", &test_remote_httpproxy__config_empty_overrides },
    { "config_overrides_detached_remote", &test_remote_httpproxy__config_overrides_detached_remote },
    { "env", &test_remote_httpproxy__env }
};
static const struct clar_func _clar_cb_remote_insteadof[] = {
    { "not_applicable", &test_remote_insteadof__not_applicable },
    { "url_insteadof_fetch", &test_remote_insteadof__url_insteadof_fetch },
    { "url_insteadof_push", &test_remote_insteadof__url_insteadof_push },
    { "url_insteadof_both", &test_remote_insteadof__url_insteadof_both },
    { "pushurl_insteadof_fetch", &test_remote_insteadof__pushurl_insteadof_fetch },
    { "pushurl_insteadof_push", &test_remote_insteadof__pushurl_insteadof_push },
    { "pushurl_insteadof_both", &test_remote_insteadof__pushurl_insteadof_both },
    { "anonymous_remote_fetch", &test_remote_insteadof__anonymous_remote_fetch },
    { "anonymous_remote_push", &test_remote_insteadof__anonymous_remote_push },
    { "anonymous_remote_both", &test_remote_insteadof__anonymous_remote_both }
};
static const struct clar_func _clar_cb_remote_list[] = {
    { "always_checks_disk_config", &test_remote_list__always_checks_disk_config }
};
static const struct clar_func _clar_cb_repo_config[] = {
    { "can_open_global_when_there_is_no_file", &test_repo_config__can_open_global_when_there_is_no_file },
    { "can_open_missing_global_with_separators", &test_repo_config__can_open_missing_global_with_separators },
    { "read_with_no_configs_at_all", &test_repo_config__read_with_no_configs_at_all }
};
static const struct clar_func _clar_cb_repo_discover[] = {
    { "discovering_repo_with_exact_path_succeeds", &test_repo_discover__discovering_repo_with_exact_path_succeeds },
    { "discovering_nonexistent_dir_fails", &test_repo_discover__discovering_nonexistent_dir_fails },
    { "discovering_repo_with_subdirectory_succeeds", &test_repo_discover__discovering_repo_with_subdirectory_succeeds },
    { "discovering_repository_with_alternative_gitdir_succeeds", &test_repo_discover__discovering_repository_with_alternative_gitdir_succeeds },
    { "discovering_repository_with_malformed_alternative_gitdir_fails", &test_repo_discover__discovering_repository_with_malformed_alternative_gitdir_fails },
    { "discovering_repository_with_ceiling", &test_repo_discover__discovering_repository_with_ceiling },
    { "other_ceiling", &test_repo_discover__other_ceiling },
    { "ceiling_should_not_affect_gitdir_redirection", &test_repo_discover__ceiling_should_not_affect_gitdir_redirection },
    { "discovery_starting_at_file_succeeds", &test_repo_discover__discovery_starting_at_file_succeeds },
    { "discovery_starting_at_system_root_causes_no_hang", &test_repo_discover__discovery_starting_at_system_root_causes_no_hang }
};
static const struct clar_func _clar_cb_repo_env[] = {
    { "open", &test_repo_env__open },
    { "work_tree", &test_repo_env__work_tree },
    { "commondir", &test_repo_env__commondir },
    { "config", &test_repo_env__config }
};
static const struct clar_func _clar_cb_repo_extensions[] = {
    { "builtin", &test_repo_extensions__builtin },
    { "negate_builtin", &test_repo_extensions__negate_builtin },
    { "unsupported", &test_repo_extensions__unsupported },
    { "adds_extension", &test_repo_extensions__adds_extension }
};
static const struct clar_func _clar_cb_repo_getters[] = {
    { "is_empty_correctly_deals_with_pristine_looking_repos", &test_repo_getters__is_empty_correctly_deals_with_pristine_looking_repos },
    { "is_empty_can_detect_used_repositories", &test_repo_getters__is_empty_can_detect_used_repositories },
    { "is_empty_can_detect_repositories_with_defaultbranch_config_empty", &test_repo_getters__is_empty_can_detect_repositories_with_defaultbranch_config_empty },
    { "retrieving_the_odb_honors_the_refcount", &test_repo_getters__retrieving_the_odb_honors_the_refcount },
    { "commit_parents", &test_repo_getters__commit_parents }
};
static const struct clar_func _clar_cb_repo_hashfile[] = {
    { "simple", &test_repo_hashfile__simple },
    { "filtered_in_workdir", &test_repo_hashfile__filtered_in_workdir },
    { "filtered_outside_workdir", &test_repo_hashfile__filtered_outside_workdir }
};
static const struct clar_func _clar_cb_repo_head[] = {
    { "unborn_head", &test_repo_head__unborn_head },
    { "set_head_Attaches_HEAD_to_un_unborn_branch_when_the_branch_doesnt_exist", &test_repo_head__set_head_Attaches_HEAD_to_un_unborn_branch_when_the_branch_doesnt_exist },
    { "set_head_Returns_ENOTFOUND_when_the_reference_doesnt_exist", &test_repo_head__set_head_Returns_ENOTFOUND_when_the_reference_doesnt_exist },
    { "set_head_Fails_when_the_reference_points_to_a_non_commitish", &test_repo_head__set_head_Fails_when_the_reference_points_to_a_non_commitish },
    { "set_head_Attaches_HEAD_when_the_reference_points_to_a_branch", &test_repo_head__set_head_Attaches_HEAD_when_the_reference_points_to_a_branch },
    { "set_head_Detaches_HEAD_when_the_reference_doesnt_point_to_a_branch", &test_repo_head__set_head_Detaches_HEAD_when_the_reference_doesnt_point_to_a_branch },
    { "set_head_detached_Return_ENOTFOUND_when_the_object_doesnt_exist", &test_repo_head__set_head_detached_Return_ENOTFOUND_when_the_object_doesnt_exist },
    { "set_head_detached_Fails_when_the_object_isnt_a_commitish", &test_repo_head__set_head_detached_Fails_when_the_object_isnt_a_commitish },
    { "set_head_detached_Detaches_HEAD_and_make_it_point_to_the_peeled_commit", &test_repo_head__set_head_detached_Detaches_HEAD_and_make_it_point_to_the_peeled_commit },
    { "detach_head_Detaches_HEAD_and_make_it_point_to_the_peeled_commit", &test_repo_head__detach_head_Detaches_HEAD_and_make_it_point_to_the_peeled_commit },
    { "detach_head_Fails_if_HEAD_and_point_to_a_non_commitish", &test_repo_head__detach_head_Fails_if_HEAD_and_point_to_a_non_commitish },
    { "detaching_an_unborn_branch_returns_GIT_EUNBORNBRANCH", &test_repo_head__detaching_an_unborn_branch_returns_GIT_EUNBORNBRANCH },
    { "retrieving_an_unborn_branch_returns_GIT_EUNBORNBRANCH", &test_repo_head__retrieving_an_unborn_branch_returns_GIT_EUNBORNBRANCH },
    { "retrieving_a_missing_head_returns_GIT_ENOTFOUND", &test_repo_head__retrieving_a_missing_head_returns_GIT_ENOTFOUND },
    { "can_tell_if_an_unborn_head_is_detached", &test_repo_head__can_tell_if_an_unborn_head_is_detached }
};
static const struct clar_func _clar_cb_repo_headtree[] = {
    { "can_retrieve_the_root_tree_from_a_detached_head", &test_repo_headtree__can_retrieve_the_root_tree_from_a_detached_head },
    { "can_retrieve_the_root_tree_from_a_non_detached_head", &test_repo_headtree__can_retrieve_the_root_tree_from_a_non_detached_head },
    { "when_head_is_unborn_returns_EUNBORNBRANCH", &test_repo_headtree__when_head_is_unborn_returns_EUNBORNBRANCH },
    { "when_head_is_missing_returns_ENOTFOUND", &test_repo_headtree__when_head_is_missing_returns_ENOTFOUND }
};
static const struct clar_func _clar_cb_repo_init[] = {
    { "standard_repo", &test_repo_init__standard_repo },
    { "standard_repo_noslash", &test_repo_init__standard_repo_noslash },
    { "bare_repo", &test_repo_init__bare_repo },
    { "bare_repo_noslash", &test_repo_init__bare_repo_noslash },
    { "bare_repo_escaping_current_workdir", &test_repo_init__bare_repo_escaping_current_workdir },
    { "reinit_bare_repo", &test_repo_init__reinit_bare_repo },
    { "reinit_nondefault_version", &test_repo_init__reinit_nondefault_version },
    { "reinit_unsupported_version", &test_repo_init__reinit_unsupported_version },
    { "additional_templates", &test_repo_init__additional_templates },
    { "detect_filemode", &test_repo_init__detect_filemode },
    { "detect_ignorecase", &test_repo_init__detect_ignorecase },
    { "symlinks_win32_enabled_by_global_config", &test_repo_init__symlinks_win32_enabled_by_global_config },
    { "symlinks_win32_off_by_default", &test_repo_init__symlinks_win32_off_by_default },
    { "symlinks_posix_detected", &test_repo_init__symlinks_posix_detected },
    { "detect_precompose_unicode_required", &test_repo_init__detect_precompose_unicode_required },
    { "reinit_doesnot_overwrite_ignorecase", &test_repo_init__reinit_doesnot_overwrite_ignorecase },
    { "reinit_overwrites_filemode", &test_repo_init__reinit_overwrites_filemode },
    { "sets_logAllRefUpdates_according_to_type_of_repository", &test_repo_init__sets_logAllRefUpdates_according_to_type_of_repository },
    { "extended_0", &test_repo_init__extended_0 },
    { "extended_1", &test_repo_init__extended_1 },
    { "relative_gitdir", &test_repo_init__relative_gitdir },
    { "relative_gitdir_2", &test_repo_init__relative_gitdir_2 },
    { "can_reinit_an_initialized_repository", &test_repo_init__can_reinit_an_initialized_repository },
    { "init_with_initial_commit", &test_repo_init__init_with_initial_commit },
    { "at_filesystem_root", &test_repo_init__at_filesystem_root },
    { "nonexisting_directory", &test_repo_init__nonexisting_directory },
    { "nonexisting_root", &test_repo_init__nonexisting_root },
    { "unwriteable_directory", &test_repo_init__unwriteable_directory },
    { "defaultbranch_config", &test_repo_init__defaultbranch_config },
    { "defaultbranch_config_empty", &test_repo_init__defaultbranch_config_empty },
    { "longpath", &test_repo_init__longpath },
    { "absolute_path_with_backslashes", &test_repo_init__absolute_path_with_backslashes }
};
static const struct clar_func _clar_cb_repo_message[] = {
    { "none", &test_repo_message__none },
    { "message", &test_repo_message__message }
};
static const struct clar_func _clar_cb_repo_new[] = {
    { "has_nothing", &test_repo_new__has_nothing },
    { "is_bare_until_workdir_set", &test_repo_new__is_bare_until_workdir_set },
    { "sha1", &test_repo_new__sha1 },
    { "sha256", &test_repo_new__sha256 }
};
static const struct clar_func _clar_cb_repo_objectformat[] = {
    { "unspecified", &test_repo_objectformat__unspecified },
    { "sha1", &test_repo_objectformat__sha1 },
    { "sha256", &test_repo_objectformat__sha256 },
    { "invalid", &test_repo_objectformat__invalid }
};
static const struct clar_func _clar_cb_repo_open[] = {
    { "bare_empty_repo", &test_repo_open__bare_empty_repo },
    { "format_version_1", &test_repo_open__format_version_1 },
    { "standard_empty_repo_through_gitdir", &test_repo_open__standard_empty_repo_through_gitdir },
    { "standard_empty_repo_through_workdir", &test_repo_open__standard_empty_repo_through_workdir },
    { "open_with_discover", &test_repo_open__open_with_discover },
    { "check_if_repository", &test_repo_open__check_if_repository },
    { "gitlinked", &test_repo_open__gitlinked },
    { "with_symlinked_config", &test_repo_open__with_symlinked_config },
    { "from_git_new_workdir", &test_repo_open__from_git_new_workdir },
    { "failures", &test_repo_open__failures },
    { "bad_gitlinks", &test_repo_open__bad_gitlinks },
    { "win32_path", &test_repo_open__win32_path },
    { "opening_a_non_existing_repository_returns_ENOTFOUND", &test_repo_open__opening_a_non_existing_repository_returns_ENOTFOUND },
    { "no_config", &test_repo_open__no_config },
    { "force_bare", &test_repo_open__force_bare },
    { "validates_dir_ownership", &test_repo_open__validates_dir_ownership },
    { "validates_bare_repo_ownership", &test_repo_open__validates_bare_repo_ownership },
    { "can_allowlist_dirs_with_problematic_ownership", &test_repo_open__can_allowlist_dirs_with_problematic_ownership },
    { "safe_directory_fails_with_trailing_slash", &test_repo_open__safe_directory_fails_with_trailing_slash },
    { "can_wildcard_allowlist_with_problematic_ownership", &test_repo_open__can_wildcard_allowlist_with_problematic_ownership },
    { "can_allowlist_bare_gitdir", &test_repo_open__can_allowlist_bare_gitdir },
    { "can_wildcard_allowlist_bare_gitdir", &test_repo_open__can_wildcard_allowlist_bare_gitdir },
    { "can_handle_prefixed_safe_paths", &test_repo_open__can_handle_prefixed_safe_paths },
    { "prefixed_safe_paths_must_have_two_slashes", &test_repo_open__prefixed_safe_paths_must_have_two_slashes },
    { "can_handle_win32_prefixed_safe_paths", &test_repo_open__can_handle_win32_prefixed_safe_paths },
    { "can_handle_win32_unc_safe_paths", &test_repo_open__can_handle_win32_unc_safe_paths },
    { "can_reset_safe_directory_list", &test_repo_open__can_reset_safe_directory_list }
};
static const struct clar_func _clar_cb_repo_pathspec[] = {
    { "workdir0", &test_repo_pathspec__workdir0 },
    { "workdir1", &test_repo_pathspec__workdir1 },
    { "workdir2", &test_repo_pathspec__workdir2 },
    { "workdir3", &test_repo_pathspec__workdir3 },
    { "workdir4", &test_repo_pathspec__workdir4 },
    { "index0", &test_repo_pathspec__index0 },
    { "index1", &test_repo_pathspec__index1 },
    { "tree0", &test_repo_pathspec__tree0 },
    { "tree5", &test_repo_pathspec__tree5 },
    { "in_memory", &test_repo_pathspec__in_memory }
};
static const struct clar_func _clar_cb_repo_reservedname[] = {
    { "includes_shortname_on_win32", &test_repo_reservedname__includes_shortname_on_win32 },
    { "includes_shortname_when_requested", &test_repo_reservedname__includes_shortname_when_requested },
    { "custom_shortname_recognized", &test_repo_reservedname__custom_shortname_recognized },
    { "submodule_pointer", &test_repo_reservedname__submodule_pointer },
    { "submodule_pointer_during_create", &test_repo_reservedname__submodule_pointer_during_create }
};
static const struct clar_func _clar_cb_repo_setters[] = {
    { "setting_a_workdir_turns_a_bare_repository_into_a_standard_one", &test_repo_setters__setting_a_workdir_turns_a_bare_repository_into_a_standard_one },
    { "setting_a_workdir_prettifies_its_path", &test_repo_setters__setting_a_workdir_prettifies_its_path },
    { "setting_a_workdir_creates_a_gitlink", &test_repo_setters__setting_a_workdir_creates_a_gitlink },
    { "setting_a_new_index_on_a_repo_which_has_already_loaded_one_properly_honors_the_refcount", &test_repo_setters__setting_a_new_index_on_a_repo_which_has_already_loaded_one_properly_honors_the_refcount },
    { "setting_a_new_odb_on_a_repo_which_already_loaded_one_properly_honors_the_refcount", &test_repo_setters__setting_a_new_odb_on_a_repo_which_already_loaded_one_properly_honors_the_refcount }
};
static const struct clar_func _clar_cb_repo_shallow[] = {
    { "no_shallow_file", &test_repo_shallow__no_shallow_file },
    { "empty_shallow_file", &test_repo_shallow__empty_shallow_file },
    { "shallow_repo", &test_repo_shallow__shallow_repo },
    { "clears_errors", &test_repo_shallow__clears_errors }
};
static const struct clar_func _clar_cb_repo_state[] = {
    { "none_with_HEAD_attached", &test_repo_state__none_with_HEAD_attached },
    { "none_with_HEAD_detached", &test_repo_state__none_with_HEAD_detached },
    { "merge", &test_repo_state__merge },
    { "revert", &test_repo_state__revert },
    { "revert_sequence", &test_repo_state__revert_sequence },
    { "cherry_pick", &test_repo_state__cherry_pick },
    { "cherrypick_sequence", &test_repo_state__cherrypick_sequence },
    { "bisect", &test_repo_state__bisect },
    { "rebase_interactive", &test_repo_state__rebase_interactive },
    { "rebase_merge", &test_repo_state__rebase_merge },
    { "rebase", &test_repo_state__rebase },
    { "apply_mailbox", &test_repo_state__apply_mailbox },
    { "apply_mailbox_or_rebase", &test_repo_state__apply_mailbox_or_rebase }
};
static const struct clar_func _clar_cb_repo_template[] = {
    { "external_templates_specified_in_options", &test_repo_template__external_templates_specified_in_options },
    { "external_templates_specified_in_config", &test_repo_template__external_templates_specified_in_config },
    { "external_templates_with_leading_dot", &test_repo_template__external_templates_with_leading_dot },
    { "extended_with_template_and_shared_mode", &test_repo_template__extended_with_template_and_shared_mode },
    { "templated_head_is_used", &test_repo_template__templated_head_is_used },
    { "initial_head_option_overrides_template_head", &test_repo_template__initial_head_option_overrides_template_head },
    { "empty_template_path", &test_repo_template__empty_template_path },
    { "nonexistent_template_path", &test_repo_template__nonexistent_template_path }
};
static const struct clar_func _clar_cb_reset_default[] = {
    { "resetting_filepaths_against_a_null_target_removes_them_from_the_index", &test_reset_default__resetting_filepaths_against_a_null_target_removes_them_from_the_index },
    { "resetting_filepaths_replaces_their_corresponding_index_entries", &test_reset_default__resetting_filepaths_replaces_their_corresponding_index_entries },
    { "resetting_filepaths_clears_previous_conflicts", &test_reset_default__resetting_filepaths_clears_previous_conflicts },
    { "resetting_unknown_filepaths_does_not_fail", &test_reset_default__resetting_unknown_filepaths_does_not_fail },
    { "staged_rename_reset_delete", &test_reset_default__staged_rename_reset_delete }
};
static const struct clar_func _clar_cb_reset_hard[] = {
    { "resetting_reverts_modified_files", &test_reset_hard__resetting_reverts_modified_files },
    { "cannot_reset_in_a_bare_repository", &test_reset_hard__cannot_reset_in_a_bare_repository },
    { "resetting_reverts_unmerged", &test_reset_hard__resetting_reverts_unmerged },
    { "cleans_up_merge", &test_reset_hard__cleans_up_merge },
    { "reflog_is_correct", &test_reset_hard__reflog_is_correct },
    { "switch_file_to_dir", &test_reset_hard__switch_file_to_dir }
};
static const struct clar_func _clar_cb_reset_mixed[] = {
    { "cannot_reset_in_a_bare_repository", &test_reset_mixed__cannot_reset_in_a_bare_repository },
    { "resetting_refreshes_the_index_to_the_commit_tree", &test_reset_mixed__resetting_refreshes_the_index_to_the_commit_tree },
    { "reflog_is_correct", &test_reset_mixed__reflog_is_correct }
};
static const struct clar_func _clar_cb_reset_soft[] = {
    { "can_reset_the_non_detached_Head_to_the_specified_commit", &test_reset_soft__can_reset_the_non_detached_Head_to_the_specified_commit },
    { "can_reset_the_detached_Head_to_the_specified_commit", &test_reset_soft__can_reset_the_detached_Head_to_the_specified_commit },
    { "resetting_to_the_commit_pointed_at_by_the_Head_does_not_change_the_target_of_the_Head", &test_reset_soft__resetting_to_the_commit_pointed_at_by_the_Head_does_not_change_the_target_of_the_Head },
    { "resetting_to_a_tag_sets_the_Head_to_the_peeled_commit", &test_reset_soft__resetting_to_a_tag_sets_the_Head_to_the_peeled_commit },
    { "cannot_reset_to_a_tag_not_pointing_at_a_commit", &test_reset_soft__cannot_reset_to_a_tag_not_pointing_at_a_commit },
    { "resetting_against_an_unborn_head_repo_makes_the_head_no_longer_unborn", &test_reset_soft__resetting_against_an_unborn_head_repo_makes_the_head_no_longer_unborn },
    { "fails_when_merging", &test_reset_soft__fails_when_merging },
    { "fails_when_index_contains_conflicts_independently_of_MERGE_HEAD_file_existence", &test_reset_soft__fails_when_index_contains_conflicts_independently_of_MERGE_HEAD_file_existence },
    { "reflog_is_correct", &test_reset_soft__reflog_is_correct }
};
static const struct clar_func _clar_cb_revert_bare[] = {
    { "automerge", &test_revert_bare__automerge },
    { "conflicts", &test_revert_bare__conflicts },
    { "orphan", &test_revert_bare__orphan }
};
static const struct clar_func _clar_cb_revert_rename[] = {
    { "automerge", &test_revert_rename__automerge }
};
static const struct clar_func _clar_cb_revert_workdir[] = {
    { "automerge", &test_revert_workdir__automerge },
    { "conflicts", &test_revert_workdir__conflicts },
    { "orphan", &test_revert_workdir__orphan },
    { "again", &test_revert_workdir__again },
    { "again_after_automerge", &test_revert_workdir__again_after_automerge },
    { "again_after_edit", &test_revert_workdir__again_after_edit },
    { "again_after_edit_two", &test_revert_workdir__again_after_edit_two },
    { "conflict_use_ours", &test_revert_workdir__conflict_use_ours },
    { "rename_1_of_2", &test_revert_workdir__rename_1_of_2 },
    { "rename", &test_revert_workdir__rename },
    { "head", &test_revert_workdir__head },
    { "nonmerge_fails_mainline_specified", &test_revert_workdir__nonmerge_fails_mainline_specified },
    { "merge_fails_without_mainline_specified", &test_revert_workdir__merge_fails_without_mainline_specified },
    { "merge_first_parent", &test_revert_workdir__merge_first_parent },
    { "merge_second_parent", &test_revert_workdir__merge_second_parent }
};
static const struct clar_func _clar_cb_revwalk_basic[] = {
    { "sorting_modes", &test_revwalk_basic__sorting_modes },
    { "glob_heads", &test_revwalk_basic__glob_heads },
    { "glob_heads_with_invalid", &test_revwalk_basic__glob_heads_with_invalid },
    { "glob_invalid_symbolic_ref", &test_revwalk_basic__glob_invalid_symbolic_ref },
    { "push_head", &test_revwalk_basic__push_head },
    { "sorted_after_reset", &test_revwalk_basic__sorted_after_reset },
    { "push_head_hide_ref", &test_revwalk_basic__push_head_hide_ref },
    { "push_head_hide_ref_nobase", &test_revwalk_basic__push_head_hide_ref_nobase },
    { "multiple_push_1", &test_revwalk_basic__multiple_push_1 },
    { "multiple_push_2", &test_revwalk_basic__multiple_push_2 },
    { "disallow_non_commit", &test_revwalk_basic__disallow_non_commit },
    { "hide_then_push", &test_revwalk_basic__hide_then_push },
    { "topo_crash", &test_revwalk_basic__topo_crash },
    { "from_new_to_old", &test_revwalk_basic__from_new_to_old },
    { "push_range", &test_revwalk_basic__push_range },
    { "push_range_merge_base", &test_revwalk_basic__push_range_merge_base },
    { "push_range_no_range", &test_revwalk_basic__push_range_no_range },
    { "push_mixed", &test_revwalk_basic__push_mixed },
    { "push_all", &test_revwalk_basic__push_all },
    { "mimic_git_rev_list", &test_revwalk_basic__mimic_git_rev_list },
    { "big_timestamp", &test_revwalk_basic__big_timestamp },
    { "old_hidden_commit_one", &test_revwalk_basic__old_hidden_commit_one },
    { "old_hidden_commit_two", &test_revwalk_basic__old_hidden_commit_two },
    { "newer_hidden_commit_hides_old_commits", &test_revwalk_basic__newer_hidden_commit_hides_old_commits }
};
static const struct clar_func _clar_cb_revwalk_hidecb[] = {
    { "hide_all_cb", &test_revwalk_hidecb__hide_all_cb },
    { "hide_none_cb", &test_revwalk_hidecb__hide_none_cb },
    { "unset_cb_before_walk", &test_revwalk_hidecb__unset_cb_before_walk },
    { "change_cb_before_walk", &test_revwalk_hidecb__change_cb_before_walk },
    { "add_hide_cb_during_walking", &test_revwalk_hidecb__add_hide_cb_during_walking },
    { "hide_some_commits", &test_revwalk_hidecb__hide_some_commits },
    { "test_payload", &test_revwalk_hidecb__test_payload }
};
static const struct clar_func _clar_cb_revwalk_mergebase[] = {
    { "single1", &test_revwalk_mergebase__single1 },
    { "single2", &test_revwalk_mergebase__single2 },
    { "merged_branch", &test_revwalk_mergebase__merged_branch },
    { "two_way_merge", &test_revwalk_mergebase__two_way_merge },
    { "no_common_ancestor_returns_ENOTFOUND", &test_revwalk_mergebase__no_common_ancestor_returns_ENOTFOUND },
    { "prefer_youngest_merge_base", &test_revwalk_mergebase__prefer_youngest_merge_base },
    { "multiple_merge_bases", &test_revwalk_mergebase__multiple_merge_bases },
    { "multiple_merge_bases_many_commits", &test_revwalk_mergebase__multiple_merge_bases_many_commits },
    { "no_off_by_one_missing", &test_revwalk_mergebase__no_off_by_one_missing },
    { "many_no_common_ancestor_returns_ENOTFOUND", &test_revwalk_mergebase__many_no_common_ancestor_returns_ENOTFOUND },
    { "many_merge_branch", &test_revwalk_mergebase__many_merge_branch },
    { "octopus_no_common_ancestor_returns_ENOTFOUND", &test_revwalk_mergebase__octopus_no_common_ancestor_returns_ENOTFOUND },
    { "octopus_merge_branch", &test_revwalk_mergebase__octopus_merge_branch },
    { "remove_redundant", &test_revwalk_mergebase__remove_redundant }
};
static const struct clar_func _clar_cb_revwalk_signatureparsing[] = {
    { "do_not_choke_when_name_contains_angle_brackets", &test_revwalk_signatureparsing__do_not_choke_when_name_contains_angle_brackets }
};
static const struct clar_func _clar_cb_revwalk_simplify[] = {
    { "first_parent", &test_revwalk_simplify__first_parent }
};
static const struct clar_func _clar_cb_stash_apply[] = {
    { "with_default", &test_stash_apply__with_default },
    { "with_existing_file", &test_stash_apply__with_existing_file },
    { "merges_new_file", &test_stash_apply__merges_new_file },
    { "with_reinstate_index", &test_stash_apply__with_reinstate_index },
    { "conflict_index_with_default", &test_stash_apply__conflict_index_with_default },
    { "conflict_index_with_reinstate_index", &test_stash_apply__conflict_index_with_reinstate_index },
    { "conflict_untracked_with_default", &test_stash_apply__conflict_untracked_with_default },
    { "conflict_untracked_with_reinstate_index", &test_stash_apply__conflict_untracked_with_reinstate_index },
    { "conflict_workdir_with_default", &test_stash_apply__conflict_workdir_with_default },
    { "conflict_workdir_with_reinstate_index", &test_stash_apply__conflict_workdir_with_reinstate_index },
    { "conflict_commit_with_default", &test_stash_apply__conflict_commit_with_default },
    { "conflict_commit_with_reinstate_index", &test_stash_apply__conflict_commit_with_reinstate_index },
    { "fails_with_uncommitted_changes_in_index", &test_stash_apply__fails_with_uncommitted_changes_in_index },
    { "pop", &test_stash_apply__pop },
    { "executes_notify_cb", &test_stash_apply__executes_notify_cb },
    { "calls_progress_cb", &test_stash_apply__calls_progress_cb },
    { "progress_cb_can_abort", &test_stash_apply__progress_cb_can_abort },
    { "uses_reflog_like_indices_1", &test_stash_apply__uses_reflog_like_indices_1 },
    { "uses_reflog_like_indices_2", &test_stash_apply__uses_reflog_like_indices_2 }
};
static const struct clar_func _clar_cb_stash_drop[] = {
    { "cannot_drop_from_an_empty_stash", &test_stash_drop__cannot_drop_from_an_empty_stash },
    { "cannot_drop_a_non_existing_stashed_state", &test_stash_drop__cannot_drop_a_non_existing_stashed_state },
    { "can_purge_the_stash_from_the_top", &test_stash_drop__can_purge_the_stash_from_the_top },
    { "can_purge_the_stash_from_the_bottom", &test_stash_drop__can_purge_the_stash_from_the_bottom },
    { "dropping_an_entry_rewrites_reflog_history", &test_stash_drop__dropping_an_entry_rewrites_reflog_history },
    { "dropping_the_last_entry_removes_the_stash", &test_stash_drop__dropping_the_last_entry_removes_the_stash },
    { "dropping_the_top_stash_updates_the_stash_reference", &test_stash_drop__dropping_the_top_stash_updates_the_stash_reference }
};
static const struct clar_func _clar_cb_stash_foreach[] = {
    { "enumerating_a_empty_repository_doesnt_fail", &test_stash_foreach__enumerating_a_empty_repository_doesnt_fail },
    { "can_enumerate_a_repository", &test_stash_foreach__can_enumerate_a_repository }
};
static const struct clar_func _clar_cb_stash_save[] = {
    { "does_not_keep_index_by_default", &test_stash_save__does_not_keep_index_by_default },
    { "can_keep_index", &test_stash_save__can_keep_index },
    { "can_keep_all", &test_stash_save__can_keep_all },
    { "can_include_untracked_files", &test_stash_save__can_include_untracked_files },
    { "untracked_skips_ignored", &test_stash_save__untracked_skips_ignored },
    { "can_include_untracked_and_ignored_files", &test_stash_save__can_include_untracked_and_ignored_files },
    { "untracked_regression", &test_stash_save__untracked_regression },
    { "can_accept_a_message", &test_stash_save__can_accept_a_message },
    { "cannot_stash_against_an_unborn_branch", &test_stash_save__cannot_stash_against_an_unborn_branch },
    { "cannot_stash_against_a_bare_repository", &test_stash_save__cannot_stash_against_a_bare_repository },
    { "can_stash_against_a_detached_head", &test_stash_save__can_stash_against_a_detached_head },
    { "stashing_updates_the_reflog", &test_stash_save__stashing_updates_the_reflog },
    { "multiline_message", &test_stash_save__multiline_message },
    { "cannot_stash_when_there_are_no_local_change", &test_stash_save__cannot_stash_when_there_are_no_local_change },
    { "can_stage_normal_then_stage_untracked", &test_stash_save__can_stage_normal_then_stage_untracked },
    { "including_untracked_without_any_untracked_file_creates_an_empty_tree", &test_stash_save__including_untracked_without_any_untracked_file_creates_an_empty_tree },
    { "ignored_directory", &test_stash_save__ignored_directory },
    { "skip_submodules", &test_stash_save__skip_submodules },
    { "deleted_in_index_modified_in_workdir", &test_stash_save__deleted_in_index_modified_in_workdir },
    { "option_paths", &test_stash_save__option_paths }
};
static const struct clar_func _clar_cb_stash_submodules[] = {
    { "does_not_stash_modified_submodules", &test_stash_submodules__does_not_stash_modified_submodules },
    { "stash_is_empty_with_modified_submodules", &test_stash_submodules__stash_is_empty_with_modified_submodules }
};
static const struct clar_func _clar_cb_status_renames[] = {
    { "head2index_one", &test_status_renames__head2index_one },
    { "head2index_two", &test_status_renames__head2index_two },
    { "head2index_no_rename_from_rewrite", &test_status_renames__head2index_no_rename_from_rewrite },
    { "head2index_rename_from_rewrite", &test_status_renames__head2index_rename_from_rewrite },
    { "index2workdir_one", &test_status_renames__index2workdir_one },
    { "index2workdir_two", &test_status_renames__index2workdir_two },
    { "index2workdir_rename_from_rewrite", &test_status_renames__index2workdir_rename_from_rewrite },
    { "both_one", &test_status_renames__both_one },
    { "both_two", &test_status_renames__both_two },
    { "both_rename_from_rewrite", &test_status_renames__both_rename_from_rewrite },
    { "rewrites_only_for_renames", &test_status_renames__rewrites_only_for_renames },
    { "both_casechange_one", &test_status_renames__both_casechange_one },
    { "both_casechange_two", &test_status_renames__both_casechange_two },
    { "zero_byte_file_does_not_fail", &test_status_renames__zero_byte_file_does_not_fail },
    { "precomposed_unicode_rename", &test_status_renames__precomposed_unicode_rename },
    { "precomposed_unicode_toggle_is_rename", &test_status_renames__precomposed_unicode_toggle_is_rename },
    { "rename_threshold", &test_status_renames__rename_threshold },
    { "case_insensitive_h2i_and_i2wc", &test_status_renames__case_insensitive_h2i_and_i2wc }
};
static const struct clar_func _clar_cb_status_single[] = {
    { "hash_single_file", &test_status_single__hash_single_file },
    { "hash_single_empty_file", &test_status_single__hash_single_empty_file }
};
static const struct clar_func _clar_cb_status_submodules[] = {
    { "api", &test_status_submodules__api },
    { "0", &test_status_submodules__0 },
    { "1", &test_status_submodules__1 },
    { "single_file", &test_status_submodules__single_file },
    { "moved_head", &test_status_submodules__moved_head },
    { "dirty_workdir_only", &test_status_submodules__dirty_workdir_only },
    { "uninitialized", &test_status_submodules__uninitialized },
    { "contained_untracked_repo", &test_status_submodules__contained_untracked_repo },
    { "broken_stuff_that_git_allows", &test_status_submodules__broken_stuff_that_git_allows },
    { "entry_but_dir_tracked", &test_status_submodules__entry_but_dir_tracked },
    { "mixed_case", &test_status_submodules__mixed_case }
};
static const struct clar_func _clar_cb_status_worktree[] = {
    { "whole_repository", &test_status_worktree__whole_repository },
    { "show_index_and_workdir", &test_status_worktree__show_index_and_workdir },
    { "show_index_only", &test_status_worktree__show_index_only },
    { "show_workdir_only", &test_status_worktree__show_workdir_only },
    { "empty_repository", &test_status_worktree__empty_repository },
    { "purged_worktree", &test_status_worktree__purged_worktree },
    { "swap_subdir_and_file", &test_status_worktree__swap_subdir_and_file },
    { "swap_subdir_with_recurse_and_pathspec", &test_status_worktree__swap_subdir_with_recurse_and_pathspec },
    { "within_subdir", &test_status_worktree__within_subdir },
    { "single_file", &test_status_worktree__single_file },
    { "single_nonexistent_file", &test_status_worktree__single_nonexistent_file },
    { "single_nonexistent_file_empty_repo", &test_status_worktree__single_nonexistent_file_empty_repo },
    { "single_file_empty_repo", &test_status_worktree__single_file_empty_repo },
    { "single_folder", &test_status_worktree__single_folder },
    { "ignores", &test_status_worktree__ignores },
    { "issue_592", &test_status_worktree__issue_592 },
    { "issue_592_2", &test_status_worktree__issue_592_2 },
    { "issue_592_3", &test_status_worktree__issue_592_3 },
    { "issue_592_4", &test_status_worktree__issue_592_4 },
    { "issue_592_5", &test_status_worktree__issue_592_5 },
    { "issue_592_ignores_0", &test_status_worktree__issue_592_ignores_0 },
    { "issue_592_ignored_dirs_with_tracked_content", &test_status_worktree__issue_592_ignored_dirs_with_tracked_content },
    { "conflict_with_diff3", &test_status_worktree__conflict_with_diff3 },
    { "filemode_changes", &test_status_worktree__filemode_changes },
    { "filemode_non755", &test_status_worktree__filemode_non755 },
    { "interruptable_foreach", &test_status_worktree__interruptable_foreach },
    { "line_endings_dont_count_as_changes_with_autocrlf", &test_status_worktree__line_endings_dont_count_as_changes_with_autocrlf },
    { "line_endings_dont_count_as_changes_with_autocrlf_issue_1397", &test_status_worktree__line_endings_dont_count_as_changes_with_autocrlf_issue_1397 },
    { "conflicted_item", &test_status_worktree__conflicted_item },
    { "conflict_has_no_oid", &test_status_worktree__conflict_has_no_oid },
    { "file_status_honors_core_ignorecase_true", &test_status_worktree__file_status_honors_core_ignorecase_true },
    { "file_status_honors_core_ignorecase_false", &test_status_worktree__file_status_honors_core_ignorecase_false },
    { "file_status_honors_case_ignorecase_regarding_untracked_files", &test_status_worktree__file_status_honors_case_ignorecase_regarding_untracked_files },
    { "simple_delete", &test_status_worktree__simple_delete },
    { "simple_delete_indexed", &test_status_worktree__simple_delete_indexed },
    { "sorting_by_case", &test_status_worktree__sorting_by_case },
    { "long_filenames", &test_status_worktree__long_filenames },
    { "update_stat_cache_0", &test_status_worktree__update_stat_cache_0 },
    { "unreadable", &test_status_worktree__unreadable },
    { "unreadable_not_included", &test_status_worktree__unreadable_not_included },
    { "unreadable_as_untracked", &test_status_worktree__unreadable_as_untracked },
    { "update_index_with_symlink_doesnt_change_mode", &test_status_worktree__update_index_with_symlink_doesnt_change_mode },
    { "with_directory_in_pathlist", &test_status_worktree__with_directory_in_pathlist },
    { "at_head_parent", &test_status_worktree__at_head_parent },
    { "skip_hash", &test_status_worktree__skip_hash }
};
static const struct clar_func _clar_cb_status_worktree_init[] = {
    { "cannot_retrieve_the_status_of_a_bare_repository", &test_status_worktree_init__cannot_retrieve_the_status_of_a_bare_repository },
    { "first_commit_in_progress", &test_status_worktree_init__first_commit_in_progress },
    { "status_file_without_index_or_workdir", &test_status_worktree_init__status_file_without_index_or_workdir },
    { "status_file_with_clean_index_and_empty_workdir", &test_status_worktree_init__status_file_with_clean_index_and_empty_workdir },
    { "bracket_in_filename", &test_status_worktree_init__bracket_in_filename },
    { "space_in_filename", &test_status_worktree_init__space_in_filename },
    { "disable_pathspec_match", &test_status_worktree_init__disable_pathspec_match },
    { "new_staged_file_must_handle_crlf", &test_status_worktree_init__new_staged_file_must_handle_crlf }
};
static const struct clar_func _clar_cb_stream_deprecated[] = {
    { "register_tls", &test_stream_deprecated__register_tls }
};
static const struct clar_func _clar_cb_stream_registration[] = {
    { "insecure", &test_stream_registration__insecure },
    { "tls", &test_stream_registration__tls },
    { "both", &test_stream_registration__both }
};
static const struct clar_func _clar_cb_stress_diff[] = {
    { "rename_big_files", &test_stress_diff__rename_big_files },
    { "rename_many_files", &test_stress_diff__rename_many_files }
};
static const struct clar_func _clar_cb_submodule_add[] = {
    { "url_absolute", &test_submodule_add__url_absolute },
    { "url_relative", &test_submodule_add__url_relative },
    { "url_relative_to_origin", &test_submodule_add__url_relative_to_origin },
    { "url_relative_to_workdir", &test_submodule_add__url_relative_to_workdir },
    { "path_exists_in_index", &test_submodule_add__path_exists_in_index },
    { "file_exists_in_index", &test_submodule_add__file_exists_in_index },
    { "submodule_clone", &test_submodule_add__submodule_clone },
    { "submodule_clone_into_nonempty_dir_succeeds", &test_submodule_add__submodule_clone_into_nonempty_dir_succeeds },
    { "submodule_clone_twice_fails", &test_submodule_add__submodule_clone_twice_fails }
};
static const struct clar_func _clar_cb_submodule_escape[] = {
    { "from_gitdir", &test_submodule_escape__from_gitdir },
    { "from_gitdir_windows", &test_submodule_escape__from_gitdir_windows }
};
static const struct clar_func _clar_cb_submodule_init[] = {
    { "absolute_url", &test_submodule_init__absolute_url },
    { "relative_url", &test_submodule_init__relative_url },
    { "relative_url_detached_head", &test_submodule_init__relative_url_detached_head }
};
static const struct clar_func _clar_cb_submodule_inject_option[] = {
    { "url", &test_submodule_inject_option__url },
    { "path", &test_submodule_inject_option__path }
};
static const struct clar_func _clar_cb_submodule_lookup[] = {
    { "simple_lookup", &test_submodule_lookup__simple_lookup },
    { "can_be_dupped", &test_submodule_lookup__can_be_dupped },
    { "accessors", &test_submodule_lookup__accessors },
    { "foreach", &test_submodule_lookup__foreach },
    { "duplicated_path", &test_submodule_lookup__duplicated_path },
    { "lookup_even_with_unborn_head", &test_submodule_lookup__lookup_even_with_unborn_head },
    { "lookup_even_with_missing_index", &test_submodule_lookup__lookup_even_with_missing_index },
    { "backslashes", &test_submodule_lookup__backslashes },
    { "just_added", &test_submodule_lookup__just_added },
    { "prefix_name", &test_submodule_lookup__prefix_name },
    { "dotpath_in_name", &test_submodule_lookup__dotpath_in_name },
    { "renamed", &test_submodule_lookup__renamed },
    { "cached", &test_submodule_lookup__cached },
    { "lookup_in_bare_repository_fails", &test_submodule_lookup__lookup_in_bare_repository_fails },
    { "foreach_in_bare_repository_fails", &test_submodule_lookup__foreach_in_bare_repository_fails },
    { "fail_invalid_gitmodules", &test_submodule_lookup__fail_invalid_gitmodules }
};
static const struct clar_func _clar_cb_submodule_modify[] = {
    { "init", &test_submodule_modify__init },
    { "sync", &test_submodule_modify__sync },
    { "set_ignore", &test_submodule_modify__set_ignore },
    { "set_update", &test_submodule_modify__set_update },
    { "set_fetch_recurse_submodules", &test_submodule_modify__set_fetch_recurse_submodules },
    { "set_branch", &test_submodule_modify__set_branch },
    { "set_url", &test_submodule_modify__set_url },
    { "set_relative_url", &test_submodule_modify__set_relative_url }
};
static const struct clar_func _clar_cb_submodule_nosubs[] = {
    { "lookup", &test_submodule_nosubs__lookup },
    { "foreach", &test_submodule_nosubs__foreach },
    { "add", &test_submodule_nosubs__add },
    { "bad_gitmodules", &test_submodule_nosubs__bad_gitmodules },
    { "add_and_delete", &test_submodule_nosubs__add_and_delete }
};
static const struct clar_func _clar_cb_submodule_open[] = {
    { "opening_via_lookup_succeeds", &test_submodule_open__opening_via_lookup_succeeds },
    { "direct_open_succeeds", &test_submodule_open__direct_open_succeeds },
    { "direct_open_succeeds_for_broken_sm_with_gitdir", &test_submodule_open__direct_open_succeeds_for_broken_sm_with_gitdir }
};
static const struct clar_func _clar_cb_submodule_repository_init[] = {
    { "basic", &test_submodule_repository_init__basic }
};
static const struct clar_func _clar_cb_submodule_status[] = {
    { "unchanged", &test_submodule_status__unchanged },
    { "ignore_none", &test_submodule_status__ignore_none },
    { "ignore_untracked", &test_submodule_status__ignore_untracked },
    { "ignore_dirty", &test_submodule_status__ignore_dirty },
    { "ignore_all", &test_submodule_status__ignore_all },
    { "iterator", &test_submodule_status__iterator },
    { "untracked_dirs_containing_ignored_files", &test_submodule_status__untracked_dirs_containing_ignored_files }
};
static const struct clar_func _clar_cb_submodule_update[] = {
    { "uninitialized_submodule_no_init", &test_submodule_update__uninitialized_submodule_no_init },
    { "update_submodule", &test_submodule_update__update_submodule },
    { "update_submodule_with_path", &test_submodule_update__update_submodule_with_path },
    { "update_and_init_submodule", &test_submodule_update__update_and_init_submodule },
    { "update_skip_configured_missing_submodule", &test_submodule_update__update_skip_configured_missing_submodule },
    { "update_already_checked_out_submodule", &test_submodule_update__update_already_checked_out_submodule },
    { "update_blocks_on_dirty_wd", &test_submodule_update__update_blocks_on_dirty_wd },
    { "can_force_update", &test_submodule_update__can_force_update }
};
static const struct clar_func _clar_cb_threads_atomic[] = {
    { "atomic32_set", &test_threads_atomic__atomic32_set },
    { "atomic32_get", &test_threads_atomic__atomic32_get },
    { "atomic32_inc", &test_threads_atomic__atomic32_inc },
    { "atomic32_add", &test_threads_atomic__atomic32_add },
    { "atomic32_dec", &test_threads_atomic__atomic32_dec },
    { "atomic64_set", &test_threads_atomic__atomic64_set },
    { "atomic64_get", &test_threads_atomic__atomic64_get },
    { "atomic64_add", &test_threads_atomic__atomic64_add },
    { "cas_pointer", &test_threads_atomic__cas_pointer },
    { "cas_intptr", &test_threads_atomic__cas_intptr },
    { "swap", &test_threads_atomic__swap },
    { "load_ptr", &test_threads_atomic__load_ptr },
    { "load_intptr", &test_threads_atomic__load_intptr }
};
static const struct clar_func _clar_cb_threads_basic[] = {
    { "cache", &test_threads_basic__cache },
    { "multiple_init", &test_threads_basic__multiple_init },
    { "set_error", &test_threads_basic__set_error },
    { "exit", &test_threads_basic__exit }
};
static const struct clar_func _clar_cb_threads_diff[] = {
    { "concurrent_diffs", &test_threads_diff__concurrent_diffs },
    { "with_concurrent_index_modified", &test_threads_diff__with_concurrent_index_modified }
};
static const struct clar_func _clar_cb_threads_iterator[] = {
    { "workdir", &test_threads_iterator__workdir }
};
static const struct clar_func _clar_cb_threads_refdb[] = {
    { "edit_while_iterate", &test_threads_refdb__edit_while_iterate }
};
static const struct clar_func _clar_cb_threads_tlsdata[] = {
    { "can_set_and_get", &test_threads_tlsdata__can_set_and_get },
    { "threads", &test_threads_tlsdata__threads }
};
static const struct clar_func _clar_cb_trace_trace[] = {
    { "sets", &test_trace_trace__sets },
    { "can_reset", &test_trace_trace__can_reset },
    { "can_unset", &test_trace_trace__can_unset },
    { "skips_higher_level", &test_trace_trace__skips_higher_level },
    { "writes", &test_trace_trace__writes },
    { "writes_lower_level", &test_trace_trace__writes_lower_level }
};
static const struct clar_func _clar_cb_trace_windows_stacktrace[] = {
    { "basic", &test_trace_windows_stacktrace__basic },
    { "leaks", &test_trace_windows_stacktrace__leaks },
    { "aux1", &test_trace_windows_stacktrace__aux1 }
};
static const struct clar_func _clar_cb_transport_register[] = {
    { "custom_transport", &test_transport_register__custom_transport },
    { "custom_transport_error_doubleregister", &test_transport_register__custom_transport_error_doubleregister },
    { "custom_transport_error_remove_non_existing", &test_transport_register__custom_transport_error_remove_non_existing },
    { "custom_transport_ssh", &test_transport_register__custom_transport_ssh },
    { "custom_transport_callbacks", &test_transport_register__custom_transport_callbacks }
};
static const struct clar_func _clar_cb_transport_ssh_exec[] = {
    { "reject_injection_username", &test_transport_ssh_exec__reject_injection_username },
    { "reject_injection_hostname", &test_transport_ssh_exec__reject_injection_hostname },
    { "reject_injection_path", &test_transport_ssh_exec__reject_injection_path }
};
static const struct clar_func _clar_cb_transports_smart_packet[] = {
    { "parsing_garbage_fails", &test_transports_smart_packet__parsing_garbage_fails },
    { "flush_parses", &test_transports_smart_packet__flush_parses },
    { "data_pkt", &test_transports_smart_packet__data_pkt },
    { "sideband_progress_pkt", &test_transports_smart_packet__sideband_progress_pkt },
    { "sideband_err_pkt", &test_transports_smart_packet__sideband_err_pkt },
    { "ack_pkt", &test_transports_smart_packet__ack_pkt },
    { "nak_pkt", &test_transports_smart_packet__nak_pkt },
    { "error_pkt", &test_transports_smart_packet__error_pkt },
    { "comment_pkt", &test_transports_smart_packet__comment_pkt },
    { "ok_pkt", &test_transports_smart_packet__ok_pkt },
    { "ng_pkt", &test_transports_smart_packet__ng_pkt },
    { "unpack_pkt", &test_transports_smart_packet__unpack_pkt },
    { "ref_pkt", &test_transports_smart_packet__ref_pkt }
};
static const struct clar_func _clar_cb_win32_forbidden[] = {
    { "can_open_index", &test_win32_forbidden__can_open_index },
    { "can_add_forbidden_filename_with_entry", &test_win32_forbidden__can_add_forbidden_filename_with_entry },
    { "cannot_add_dot_git_even_with_entry", &test_win32_forbidden__cannot_add_dot_git_even_with_entry },
    { "cannot_add_forbidden_filename_from_filesystem", &test_win32_forbidden__cannot_add_forbidden_filename_from_filesystem },
    { "can_diff_tree_to_index", &test_win32_forbidden__can_diff_tree_to_index },
    { "can_diff_tree_to_tree", &test_win32_forbidden__can_diff_tree_to_tree },
    { "can_diff_index_to_workdir", &test_win32_forbidden__can_diff_index_to_workdir },
    { "checking_out_forbidden_index_fails", &test_win32_forbidden__checking_out_forbidden_index_fails },
    { "can_query_submodules", &test_win32_forbidden__can_query_submodules },
    { "can_blame_file", &test_win32_forbidden__can_blame_file }
};
static const struct clar_func _clar_cb_win32_longpath[] = {
    { "errmsg_on_checkout", &test_win32_longpath__errmsg_on_checkout },
    { "workdir_path_validated", &test_win32_longpath__workdir_path_validated },
    { "status_and_add", &test_win32_longpath__status_and_add },
    { "status_and_add_with_filter", &test_win32_longpath__status_and_add_with_filter }
};
static const struct clar_func _clar_cb_win32_systemdir[] = {
    { "finds_etc_in_path", &test_win32_systemdir__finds_etc_in_path },
    { "finds_mingw64_etc_in_path", &test_win32_systemdir__finds_mingw64_etc_in_path },
    { "prefers_etc_to_mingw64_in_path", &test_win32_systemdir__prefers_etc_to_mingw64_in_path },
    { "finds_etc_in_registry", &test_win32_systemdir__finds_etc_in_registry },
    { "finds_mingw64_etc_in_registry", &test_win32_systemdir__finds_mingw64_etc_in_registry },
    { "prefers_etc_to_mingw64_in_registry", &test_win32_systemdir__prefers_etc_to_mingw64_in_registry },
    { "prefers_path_to_registry", &test_win32_systemdir__prefers_path_to_registry },
    { "no_git_installed", &test_win32_systemdir__no_git_installed }
};
static const struct clar_func _clar_cb_worktree_bare[] = {
    { "list", &test_worktree_bare__list },
    { "add", &test_worktree_bare__add },
    { "repository_path", &test_worktree_bare__repository_path }
};
static const struct clar_func _clar_cb_worktree_config[] = {
    { "open", &test_worktree_config__open },
    { "set_level_local", &test_worktree_config__set_level_local },
    { "requires_extension", &test_worktree_config__requires_extension },
    { "exists", &test_worktree_config__exists },
    { "set_level_worktree", &test_worktree_config__set_level_worktree }
};
static const struct clar_func _clar_cb_worktree_merge[] = {
    { "merge_head", &test_worktree_merge__merge_head },
    { "merge_setup", &test_worktree_merge__merge_setup },
    { "merge_conflict", &test_worktree_merge__merge_conflict }
};
static const struct clar_func _clar_cb_worktree_open[] = {
    { "repository", &test_worktree_open__repository },
    { "repository_through_workdir", &test_worktree_open__repository_through_workdir },
    { "repository_through_gitlink", &test_worktree_open__repository_through_gitlink },
    { "repository_through_gitdir", &test_worktree_open__repository_through_gitdir },
    { "open_discovered_worktree", &test_worktree_open__open_discovered_worktree },
    { "repository_with_nonexistent_parent", &test_worktree_open__repository_with_nonexistent_parent },
    { "open_from_repository", &test_worktree_open__open_from_repository },
    { "open_from_nonworktree_fails", &test_worktree_open__open_from_nonworktree_fails }
};
static const struct clar_func _clar_cb_worktree_reflog[] = {
    { "read_worktree_HEAD", &test_worktree_reflog__read_worktree_HEAD },
    { "read_parent_HEAD", &test_worktree_reflog__read_parent_HEAD },
    { "read", &test_worktree_reflog__read },
    { "append_then_read", &test_worktree_reflog__append_then_read }
};
static const struct clar_func _clar_cb_worktree_refs[] = {
    { "list_no_difference_in_worktree", &test_worktree_refs__list_no_difference_in_worktree },
    { "list_worktree_specific", &test_worktree_refs__list_worktree_specific },
    { "list_worktree_specific_hidden_in_main_repo", &test_worktree_refs__list_worktree_specific_hidden_in_main_repo },
    { "read_head", &test_worktree_refs__read_head },
    { "set_head_fails_when_worktree_wants_linked_repos_HEAD", &test_worktree_refs__set_head_fails_when_worktree_wants_linked_repos_HEAD },
    { "set_head_fails_when_main_repo_wants_worktree_head", &test_worktree_refs__set_head_fails_when_main_repo_wants_worktree_head },
    { "set_head_works_for_current_HEAD", &test_worktree_refs__set_head_works_for_current_HEAD },
    { "set_head_fails_when_already_checked_out", &test_worktree_refs__set_head_fails_when_already_checked_out },
    { "delete_fails_for_checked_out_branch", &test_worktree_refs__delete_fails_for_checked_out_branch },
    { "delete_succeeds_after_pruning_worktree", &test_worktree_refs__delete_succeeds_after_pruning_worktree },
    { "delete_unrelated_branch_on_worktree", &test_worktree_refs__delete_unrelated_branch_on_worktree },
    { "delete_unrelated_branch_on_parent", &test_worktree_refs__delete_unrelated_branch_on_parent },
    { "renaming_reference_updates_worktree_heads", &test_worktree_refs__renaming_reference_updates_worktree_heads },
    { "creating_refs_uses_commondir", &test_worktree_refs__creating_refs_uses_commondir }
};
static const struct clar_func _clar_cb_worktree_repository[] = {
    { "head", &test_worktree_repository__head },
    { "head_fails_for_invalid_worktree", &test_worktree_repository__head_fails_for_invalid_worktree },
    { "head_detached", &test_worktree_repository__head_detached },
    { "head_detached_fails_for_invalid_worktree", &test_worktree_repository__head_detached_fails_for_invalid_worktree }
};
static const struct clar_func _clar_cb_worktree_submodule[] = {
    { "submodule_worktree_parent", &test_worktree_submodule__submodule_worktree_parent },
    { "submodule_worktree_child", &test_worktree_submodule__submodule_worktree_child },
    { "open_discovered_submodule_worktree", &test_worktree_submodule__open_discovered_submodule_worktree },
    { "resolve_relative_url", &test_worktree_submodule__resolve_relative_url }
};
static const struct clar_func _clar_cb_worktree_worktree[] = {
    { "list", &test_worktree_worktree__list },
    { "list_with_invalid_worktree_dirs", &test_worktree_worktree__list_with_invalid_worktree_dirs },
    { "list_in_worktree_repo", &test_worktree_worktree__list_in_worktree_repo },
    { "list_without_worktrees", &test_worktree_worktree__list_without_worktrees },
    { "lookup", &test_worktree_worktree__lookup },
    { "lookup_nonexistent_worktree", &test_worktree_worktree__lookup_nonexistent_worktree },
    { "open", &test_worktree_worktree__open },
    { "open_invalid_commondir", &test_worktree_worktree__open_invalid_commondir },
    { "open_invalid_gitdir", &test_worktree_worktree__open_invalid_gitdir },
    { "open_invalid_parent", &test_worktree_worktree__open_invalid_parent },
    { "init", &test_worktree_worktree__init },
    { "add_remove_add", &test_worktree_worktree__add_remove_add },
    { "add_locked", &test_worktree_worktree__add_locked },
    { "init_existing_branch", &test_worktree_worktree__init_existing_branch },
    { "add_with_explicit_branch", &test_worktree_worktree__add_with_explicit_branch },
    { "add_no_checkout", &test_worktree_worktree__add_no_checkout },
    { "init_existing_worktree", &test_worktree_worktree__init_existing_worktree },
    { "init_existing_path", &test_worktree_worktree__init_existing_path },
    { "init_submodule", &test_worktree_worktree__init_submodule },
    { "validate", &test_worktree_worktree__validate },
    { "name", &test_worktree_worktree__name },
    { "path", &test_worktree_worktree__path },
    { "validate_invalid_commondir", &test_worktree_worktree__validate_invalid_commondir },
    { "validate_invalid_gitdir", &test_worktree_worktree__validate_invalid_gitdir },
    { "validate_invalid_parent", &test_worktree_worktree__validate_invalid_parent },
    { "lock_with_reason", &test_worktree_worktree__lock_with_reason },
    { "lock_without_reason", &test_worktree_worktree__lock_without_reason },
    { "unlock_unlocked_worktree", &test_worktree_worktree__unlock_unlocked_worktree },
    { "unlock_locked_worktree", &test_worktree_worktree__unlock_locked_worktree },
    { "prune_without_opts_fails", &test_worktree_worktree__prune_without_opts_fails },
    { "prune_valid", &test_worktree_worktree__prune_valid },
    { "prune_locked", &test_worktree_worktree__prune_locked },
    { "prune_gitdir_only", &test_worktree_worktree__prune_gitdir_only },
    { "prune_worktree", &test_worktree_worktree__prune_worktree },
    { "foreach_worktree_lists_all_worktrees", &test_worktree_worktree__foreach_worktree_lists_all_worktrees },
    { "validate_invalid_worktreedir", &test_worktree_worktree__validate_invalid_worktreedir },
    { "is_prunable_missing_repo", &test_worktree_worktree__is_prunable_missing_repo }
};
static struct clar_suite _clar_suites[] = {
    {
        "apply::both",
        { "initialize", &test_apply_both__initialize },
        { "cleanup", &test_apply_both__cleanup },
        _clar_cb_apply_both, 27, 1
    },
    {
        "apply::callbacks",
        { "initialize", &test_apply_callbacks__initialize },
        { "cleanup", &test_apply_callbacks__cleanup },
        _clar_cb_apply_callbacks, 3, 1
    },
    {
        "apply::check",
        { "initialize", &test_apply_check__initialize },
        { "cleanup", &test_apply_check__cleanup },
        _clar_cb_apply_check, 4, 1
    },
    {
        "apply::fromdiff",
        { "initialize", &test_apply_fromdiff__initialize },
        { "cleanup", &test_apply_fromdiff__cleanup },
        _clar_cb_apply_fromdiff, 26, 1
    },
    {
        "apply::fromfile",
        { "initialize", &test_apply_fromfile__initialize },
        { "cleanup", &test_apply_fromfile__cleanup },
        _clar_cb_apply_fromfile, 42, 1
    },
    {
        "apply::index",
        { "initialize", &test_apply_index__initialize },
        { "cleanup", &test_apply_index__cleanup },
        _clar_cb_apply_index, 9, 1
    },
    {
        "apply::partial",
        { "initialize", &test_apply_partial__initialize },
        { "cleanup", &test_apply_partial__cleanup },
        _clar_cb_apply_partial, 12, 1
    },
    {
        "apply::tree",
        { "initialize", &test_apply_tree__initialize },
        { "cleanup", &test_apply_tree__cleanup },
        _clar_cb_apply_tree, 2, 1
    },
    {
        "apply::workdir",
        { "initialize", &test_apply_workdir__initialize },
        { "cleanup", &test_apply_workdir__cleanup },
        _clar_cb_apply_workdir, 11, 1
    },
    {
        "attr::file",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_attr_file, 5, 1
    },
    {
        "attr::flags",
        { NULL, NULL },
        { "cleanup", &test_attr_flags__cleanup },
        _clar_cb_attr_flags, 3, 1
    },
    {
        "attr::lookup",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_attr_lookup, 5, 1
    },
    {
        "attr::macro",
        { NULL, NULL },
        { "cleanup", &test_attr_macro__cleanup },
        _clar_cb_attr_macro, 9, 1
    },
    {
        "attr::repo",
        { "initialize", &test_attr_repo__initialize },
        { "cleanup", &test_attr_repo__cleanup },
        _clar_cb_attr_repo, 14, 1
    },
    {
        "blame::buffer",
        { "initialize", &test_blame_buffer__initialize },
        { "cleanup", &test_blame_buffer__cleanup },
        _clar_cb_blame_buffer, 14, 1
    },
    {
        "blame::getters",
        { "initialize", &test_blame_getters__initialize },
        { "cleanup", &test_blame_getters__cleanup },
        _clar_cb_blame_getters, 2, 1
    },
    {
        "blame::harder",
        { "initialize", &test_blame_harder__initialize },
        { "cleanup", &test_blame_harder__cleanup },
        _clar_cb_blame_harder, 4, 1
    },
    {
        "blame::simple",
        { "initialize", &test_blame_simple__initialize },
        { "cleanup", &test_blame_simple__cleanup },
        _clar_cb_blame_simple, 11, 1
    },
    {
        "checkout::binaryunicode",
        { "initialize", &test_checkout_binaryunicode__initialize },
        { "cleanup", &test_checkout_binaryunicode__cleanup },
        _clar_cb_checkout_binaryunicode, 2, 1
    },
    {
        "checkout::conflict",
        { "initialize", &test_checkout_conflict__initialize },
        { "cleanup", &test_checkout_conflict__cleanup },
        _clar_cb_checkout_conflict, 17, 1
    },
    {
        "checkout::crlf",
        { "initialize", &test_checkout_crlf__initialize },
        { "cleanup", &test_checkout_crlf__cleanup },
        _clar_cb_checkout_crlf, 14, 1
    },
    {
        "checkout::head",
        { "initialize", &test_checkout_head__initialize },
        { "cleanup", &test_checkout_head__cleanup },
        _clar_cb_checkout_head, 11, 1
    },
    {
        "checkout::icase",
        { "initialize", &test_checkout_icase__initialize },
        { "cleanup", &test_checkout_icase__cleanup },
        _clar_cb_checkout_icase, 13, 1
    },
    {
        "checkout::index",
        { "initialize", &test_checkout_index__initialize },
        { "cleanup", &test_checkout_index__cleanup },
        _clar_cb_checkout_index, 32, 1
    },
    {
        "checkout::nasty",
        { "initialize", &test_checkout_nasty__initialize },
        { "cleanup", &test_checkout_nasty__cleanup },
        _clar_cb_checkout_nasty, 32, 1
    },
    {
        "checkout::tree",
        { "initialize", &test_checkout_tree__initialize },
        { "cleanup", &test_checkout_tree__cleanup },
        _clar_cb_checkout_tree, 46, 1
    },
    {
        "checkout::typechange",
        { "initialize", &test_checkout_typechange__initialize },
        { "cleanup", &test_checkout_typechange__cleanup },
        _clar_cb_checkout_typechange, 3, 1
    },
    {
        "cherrypick::bare",
        { "initialize", &test_cherrypick_bare__initialize },
        { "cleanup", &test_cherrypick_bare__cleanup },
        _clar_cb_cherrypick_bare, 3, 1
    },
    {
        "cherrypick::workdir",
        { "initialize", &test_cherrypick_workdir__initialize },
        { "cleanup", &test_cherrypick_workdir__cleanup },
        _clar_cb_cherrypick_workdir, 10, 1
    },
    {
        "clone::empty",
        { "initialize", &test_clone_empty__initialize },
        { "cleanup", &test_clone_empty__cleanup },
        _clar_cb_clone_empty, 4, 1
    },
    {
        "clone::local",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_clone_local, 5, 1
    },
    {
        "clone::nonetwork",
        { "initialize", &test_clone_nonetwork__initialize },
        { "cleanup", &test_clone_nonetwork__cleanup },
        _clar_cb_clone_nonetwork, 18, 1
    },
    {
        "clone::transport",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_clone_transport, 1, 1
    },
    {
        "commit::commit",
        { "initialize", &test_commit_commit__initialize },
        { "cleanup", &test_commit_commit__cleanup },
        _clar_cb_commit_commit, 5, 1
    },
    {
        "commit::create",
        { "initialize", &test_commit_create__initialize },
        { "cleanup", &test_commit_create__cleanup },
        _clar_cb_commit_create, 3, 1
    },
    {
        "commit::parent",
        { "initialize", &test_commit_parent__initialize },
        { "cleanup", &test_commit_parent__cleanup },
        _clar_cb_commit_parent, 1, 1
    },
    {
        "commit::parse",
        { "initialize", &test_commit_parse__initialize },
        { "cleanup", &test_commit_parse__cleanup },
        _clar_cb_commit_parse, 8, 1
    },
    {
        "commit::signature",
        { "initialize", &test_commit_signature__initialize },
        { "cleanup", &test_commit_signature__cleanup },
        _clar_cb_commit_signature, 14, 1
    },
    {
        "commit::write",
        { "initialize", &test_commit_write__initialize },
        { "cleanup", &test_commit_write__cleanup },
        _clar_cb_commit_write, 8, 1
    },
    {
        "config::add",
        { "initialize", &test_config_add__initialize },
        { "cleanup", &test_config_add__cleanup },
        _clar_cb_config_add, 2, 1
    },
    {
        "config::backend",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_config_backend, 1, 1
    },
    {
        "config::conditionals",
        { "initialize", &test_config_conditionals__initialize },
        { "cleanup", &test_config_conditionals__cleanup },
        _clar_cb_config_conditionals, 5, 1
    },
    {
        "config::configlevel",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_config_configlevel, 6, 1
    },
    {
        "config::find",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_config_find, 1, 1
    },
    {
        "config::global",
        { "initialize", &test_config_global__initialize },
        { "cleanup", &test_config_global__cleanup },
        _clar_cb_config_global, 5, 1
    },
    {
        "config::include",
        { "initialize", &test_config_include__initialize },
        { "cleanup", &test_config_include__cleanup },
        _clar_cb_config_include, 16, 1
    },
    {
        "config::memory",
        { "initialize", &test_config_memory__initialize },
        { "cleanup", &test_config_memory__cleanup },
        _clar_cb_config_memory, 9, 1
    },
    {
        "config::multivar",
        { "initialize", &test_config_multivar__initialize },
        { "cleanup", &test_config_multivar__cleanup },
        _clar_cb_config_multivar, 10, 1
    },
    {
        "config::new",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_config_new, 1, 1
    },
    {
        "config::read",
        { NULL, NULL },
        { "cleanup", &test_config_read__cleanup },
        _clar_cb_config_read, 50, 1
    },
    {
        "config::readonly",
        { "initialize", &test_config_readonly__initialize },
        { "cleanup", &test_config_readonly__cleanup },
        _clar_cb_config_readonly, 3, 1
    },
    {
        "config::rename",
        { "initialize", &test_config_rename__initialize },
        { "cleanup", &test_config_rename__cleanup },
        _clar_cb_config_rename, 3, 1
    },
    {
        "config::snapshot",
        { NULL, NULL },
        { "cleanup", &test_config_snapshot__cleanup },
        _clar_cb_config_snapshot, 5, 1
    },
    {
        "config::stress",
        { "initialize", &test_config_stress__initialize },
        { "cleanup", &test_config_stress__cleanup },
        _clar_cb_config_stress, 9, 1
    },
    {
        "config::validkeyname",
        { "initialize", &test_config_validkeyname__initialize },
        { "cleanup", &test_config_validkeyname__cleanup },
        _clar_cb_config_validkeyname, 1, 1
    },
    {
        "config::write",
        { "initialize", &test_config_write__initialize },
        { "cleanup", &test_config_write__cleanup },
        _clar_cb_config_write, 28, 1
    },
    {
        "core::buf",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_core_buf, 3, 1
    },
    {
        "core::env",
        { "initialize", &test_core_env__initialize },
        { "cleanup", &test_core_env__cleanup },
        _clar_cb_core_env, 4, 1
    },
    {
        "core::features",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_core_features, 1, 1
    },
    {
        "core::hashsig",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_core_hashsig, 2, 1
    },
    {
        "core::oid",
        { "initialize", &test_core_oid__initialize },
        { NULL, NULL },
        _clar_cb_core_oid, 9, 1
    },
    {
        "core::oidarray",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_core_oidarray, 1, 1
    },
    {
        "core::oidmap",
        { "initialize", &test_core_oidmap__initialize },
        { "cleanup", &test_core_oidmap__cleanup },
        _clar_cb_core_oidmap, 6, 1
    },
    {
        "core::opts",
        { NULL, NULL },
        { "cleanup", &test_core_opts__cleanup },
        _clar_cb_core_opts, 6, 1
    },
    {
        "core::pool",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_core_pool, 1, 1
    },
    {
        "core::structinit",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_core_structinit, 1, 1
    },
    {
        "core::useragent",
        { "initialize", &test_core_useragent__initialize },
        { "cleanup", &test_core_useragent__cleanup },
        _clar_cb_core_useragent, 2, 1
    },
    {
        "date::date",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_date_date, 3, 1
    },
    {
        "date::rfc2822",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_date_rfc2822, 3, 1
    },
    {
        "delta::apply",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_delta_apply, 2, 1
    },
    {
        "describe::describe",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_describe_describe, 2, 1
    },
    {
        "describe::t6120",
        { "initialize", &test_describe_t6120__initialize },
        { "cleanup", &test_describe_t6120__cleanup },
        _clar_cb_describe_t6120, 7, 1
    },
    {
        "diff::binary",
        { "initialize", &test_diff_binary__initialize },
        { "cleanup", &test_diff_binary__cleanup },
        _clar_cb_diff_binary, 12, 1
    },
    {
        "diff::blob",
        { "initialize", &test_diff_blob__initialize },
        { "cleanup", &test_diff_blob__cleanup },
        _clar_cb_diff_blob, 21, 1
    },
    {
        "diff::diffiter",
        { "initialize", &test_diff_diffiter__initialize },
        { "cleanup", &test_diff_diffiter__cleanup },
        _clar_cb_diff_diffiter, 9, 1
    },
    {
        "diff::drivers",
        { "initialize", &test_diff_drivers__initialize },
        { "cleanup", &test_diff_drivers__cleanup },
        _clar_cb_diff_drivers, 4, 1
    },
    {
        "diff::externalmodifications",
        { "initialize", &test_diff_externalmodifications__initialize },
        { "cleanup", &test_diff_externalmodifications__cleanup },
        _clar_cb_diff_externalmodifications, 4, 1
    },
    {
        "diff::format::email",
        { "initialize", &test_diff_format_email__initialize },
        { "cleanup", &test_diff_format_email__cleanup },
        _clar_cb_diff_format_email, 9, 1
    },
    {
        "diff::index",
        { "initialize", &test_diff_index__initialize },
        { "cleanup", &test_diff_index__cleanup },
        _clar_cb_diff_index, 7, 1
    },
    {
        "diff::notify",
        { "initialize", &test_diff_notify__initialize },
        { "cleanup", &test_diff_notify__cleanup },
        _clar_cb_diff_notify, 7, 1
    },
    {
        "diff::parse",
        { NULL, NULL },
        { "cleanup", &test_diff_parse__cleanup },
        _clar_cb_diff_parse, 18, 1
    },
    {
        "diff::patch",
        { "initialize", &test_diff_patch__initialize },
        { "cleanup", &test_diff_patch__cleanup },
        _clar_cb_diff_patch, 7, 1
    },
    {
        "diff::patchid",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_diff_patchid, 11, 1
    },
    {
        "diff::pathspec",
        { "initialize", &test_diff_pathspec__initialize },
        { "cleanup", &test_diff_pathspec__cleanup },
        _clar_cb_diff_pathspec, 1, 1
    },
    {
        "diff::racediffiter",
        { "initialize", &test_diff_racediffiter__initialize },
        { "cleanup", &test_diff_racediffiter__cleanup },
        _clar_cb_diff_racediffiter, 2, 1
    },
    {
        "diff::rename",
        { "initialize", &test_diff_rename__initialize },
        { "cleanup", &test_diff_rename__cleanup },
        _clar_cb_diff_rename, 31, 1
    },
    {
        "diff::stats",
        { "initialize", &test_diff_stats__initialize },
        { "cleanup", &test_diff_stats__cleanup },
        _clar_cb_diff_stats, 17, 1
    },
    {
        "diff::submodules",
        { "initialize", &test_diff_submodules__initialize },
        { "cleanup", &test_diff_submodules__cleanup },
        _clar_cb_diff_submodules, 9, 1
    },
    {
        "diff::tree",
        { "initialize", &test_diff_tree__initialize },
        { "cleanup", &test_diff_tree__cleanup },
        _clar_cb_diff_tree, 12, 1
    },
    {
        "diff::userdiff",
        { NULL, NULL },
        { "cleanup", &test_diff_userdiff__cleanup },
        _clar_cb_diff_userdiff, 1, 1
    },
    {
        "diff::workdir",
        { NULL, NULL },
        { "cleanup", &test_diff_workdir__cleanup },
        _clar_cb_diff_workdir, 34, 1
    },
    {
        "email::create",
        { "initialize", &test_email_create__initialize },
        { "cleanup", &test_email_create__cleanup },
        _clar_cb_email_create, 7, 1
    },
    {
        "fetch::local",
        { "initialize", &test_fetch_local__initialize },
        { "cleanup", &test_fetch_local__cleanup },
        _clar_cb_fetch_local, 2, 1
    },
    {
        "fetchhead::nonetwork",
        { "initialize", &test_fetchhead_nonetwork__initialize },
        { NULL, NULL },
        _clar_cb_fetchhead_nonetwork, 17, 1
    },
    {
        "filter::bare",
        { "initialize", &test_filter_bare__initialize },
        { "cleanup", &test_filter_bare__cleanup },
        _clar_cb_filter_bare, 6, 1
    },
    {
        "filter::blob",
        { "initialize", &test_filter_blob__initialize },
        { "cleanup", &test_filter_blob__cleanup },
        _clar_cb_filter_blob, 4, 1
    },
    {
        "filter::crlf",
        { "initialize", &test_filter_crlf__initialize },
        { "cleanup", &test_filter_crlf__cleanup },
        _clar_cb_filter_crlf, 6, 1
    },
    {
        "filter::custom",
        { "initialize", &test_filter_custom__initialize },
        { "cleanup", &test_filter_custom__cleanup },
        _clar_cb_filter_custom, 6, 1
    },
    {
        "filter::file",
        { "initialize", &test_filter_file__initialize },
        { "cleanup", &test_filter_file__cleanup },
        _clar_cb_filter_file, 2, 1
    },
    {
        "filter::ident",
        { "initialize", &test_filter_ident__initialize },
        { "cleanup", &test_filter_ident__cleanup },
        _clar_cb_filter_ident, 2, 1
    },
    {
        "filter::query",
        { "initialize", &test_filter_query__initialize },
        { "cleanup", &test_filter_query__cleanup },
        _clar_cb_filter_query, 4, 1
    },
    {
        "filter::stream",
        { "initialize", &test_filter_stream__initialize },
        { "cleanup", &test_filter_stream__cleanup },
        _clar_cb_filter_stream, 2, 1
    },
    {
        "filter::systemattrs",
        { "initialize", &test_filter_systemattrs__initialize },
        { "cleanup", &test_filter_systemattrs__cleanup },
        _clar_cb_filter_systemattrs, 2, 1
    },
    {
        "filter::wildcard",
        { "initialize", &test_filter_wildcard__initialize },
        { "cleanup", &test_filter_wildcard__cleanup },
        _clar_cb_filter_wildcard, 3, 1
    },
    {
        "grafts::basic",
        { "initialize", &test_grafts_basic__initialize },
        { "cleanup", &test_grafts_basic__cleanup },
        _clar_cb_grafts_basic, 4, 1
    },
    {
        "grafts::parse",
        { "initialize", &test_grafts_parse__initialize },
        { "cleanup", &test_grafts_parse__cleanup },
        _clar_cb_grafts_parse, 15, 1
    },
    {
        "grafts::shallow",
        { "initialize", &test_grafts_shallow__initialize },
        { "cleanup", &test_grafts_shallow__cleanup },
        _clar_cb_grafts_shallow, 9, 1
    },
    {
        "graph::ahead::behind",
        { "initialize", &test_graph_ahead_behind__initialize },
        { "cleanup", &test_graph_ahead_behind__cleanup },
        _clar_cb_graph_ahead_behind, 1, 1
    },
    {
        "graph::commitgraph",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_graph_commitgraph, 5, 1
    },
    {
        "graph::descendant::of",
        { "initialize", &test_graph_descendant_of__initialize },
        { "cleanup", &test_graph_descendant_of__cleanup },
        _clar_cb_graph_descendant_of, 2, 1
    },
    {
        "graph::reachable::from::any",
        { "initialize", &test_graph_reachable_from_any__initialize },
        { "cleanup", &test_graph_reachable_from_any__cleanup },
        _clar_cb_graph_reachable_from_any, 2, 1
    },
    {
        "ignore::path",
        { "initialize", &test_ignore_path__initialize },
        { "cleanup", &test_ignore_path__cleanup },
        _clar_cb_ignore_path, 36, 1
    },
    {
        "ignore::status",
        { "initialize", &test_ignore_status__initialize },
        { "cleanup", &test_ignore_status__cleanup },
        _clar_cb_ignore_status, 38, 1
    },
    {
        "index::add",
        { "initialize", &test_index_add__initialize },
        { "cleanup", &test_index_add__cleanup },
        _clar_cb_index_add, 2, 1
    },
    {
        "index::addall",
        { "initialize", &test_index_addall__initialize },
        { "cleanup", &test_index_addall__cleanup },
        _clar_cb_index_addall, 8, 1
    },
    {
        "index::bypath",
        { "initialize", &test_index_bypath__initialize },
        { "cleanup", &test_index_bypath__cleanup },
        _clar_cb_index_bypath, 13, 1
    },
    {
        "index::cache",
        { "initialize", &test_index_cache__initialize },
        { "cleanup", &test_index_cache__cleanup },
        _clar_cb_index_cache, 5, 1
    },
    {
        "index::collision",
        { "initialize", &test_index_collision__initialize },
        { "cleanup", &test_index_collision__cleanup },
        _clar_cb_index_collision, 4, 1
    },
    {
        "index::conflicts",
        { "initialize", &test_index_conflicts__initialize },
        { "cleanup", &test_index_conflicts__cleanup },
        _clar_cb_index_conflicts, 12, 1
    },
    {
        "index::crlf",
        { "initialize", &test_index_crlf__initialize },
        { "cleanup", &test_index_crlf__cleanup },
        _clar_cb_index_crlf, 10, 1
    },
    {
        "index::filemodes",
        { "initialize", &test_index_filemodes__initialize },
        { "cleanup", &test_index_filemodes__cleanup },
        _clar_cb_index_filemodes, 6, 1
    },
    {
        "index::inmemory",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_index_inmemory, 2, 1
    },
    {
        "index::names",
        { "initialize", &test_index_names__initialize },
        { "cleanup", &test_index_names__cleanup },
        _clar_cb_index_names, 7, 1
    },
    {
        "index::nsec",
        { "initialize", &test_index_nsec__initialize },
        { "cleanup", &test_index_nsec__cleanup },
        _clar_cb_index_nsec, 3, 1
    },
    {
        "index::racy",
        { "initialize", &test_index_racy__initialize },
        { "cleanup", &test_index_racy__cleanup },
        _clar_cb_index_racy, 9, 1
    },
    {
        "index::read::index",
        { "initialize", &test_index_read_index__initialize },
        { "cleanup", &test_index_read_index__cleanup },
        _clar_cb_index_read_index, 4, 1
    },
    {
        "index::read::tree",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_index_read_tree, 1, 1
    },
    {
        "index::rename",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_index_rename, 2, 1
    },
    {
        "index::reuc",
        { "initialize", &test_index_reuc__initialize },
        { "cleanup", &test_index_reuc__cleanup },
        _clar_cb_index_reuc, 14, 1
    },
    {
        "index::splitindex",
        { "initialize", &test_index_splitindex__initialize },
        { "cleanup", &test_index_splitindex__cleanup },
        _clar_cb_index_splitindex, 1, 1
    },
    {
        "index::stage",
        { "initialize", &test_index_stage__initialize },
        { "cleanup", &test_index_stage__cleanup },
        _clar_cb_index_stage, 2, 1
    },
    {
        "index::tests",
        { "initialize", &test_index_tests__initialize },
        { "cleanup", &test_index_tests__cleanup },
        _clar_cb_index_tests, 34, 1
    },
    {
        "index::tests256",
        { "initialize", &test_index_tests256__initialize },
        { "cleanup", &test_index_tests256__cleanup },
        _clar_cb_index_tests256, 30, 1
    },
    {
        "index::version",
        { NULL, NULL },
        { "cleanup", &test_index_version__cleanup },
        _clar_cb_index_version, 3, 1
    },
    {
        "iterator::index",
        { "initialize", &test_iterator_index__initialize },
        { "cleanup", &test_iterator_index__cleanup },
        _clar_cb_iterator_index, 23, 1
    },
    {
        "iterator::tree",
        { "initialize", &test_iterator_tree__initialize },
        { "cleanup", &test_iterator_tree__cleanup },
        _clar_cb_iterator_tree, 24, 1
    },
    {
        "iterator::workdir",
        { "initialize", &test_iterator_workdir__initialize },
        { "cleanup", &test_iterator_workdir__cleanup },
        _clar_cb_iterator_workdir, 30, 1
    },
    {
        "mailmap::basic",
        { "initialize", &test_mailmap_basic__initialize },
        { "cleanup", &test_mailmap_basic__cleanup },
        _clar_cb_mailmap_basic, 5, 1
    },
    {
        "mailmap::blame",
        { "initialize", &test_mailmap_blame__initialize },
        { "cleanup", &test_mailmap_blame__cleanup },
        _clar_cb_mailmap_blame, 2, 1
    },
    {
        "mailmap::parsing",
        { "initialize", &test_mailmap_parsing__initialize },
        { "cleanup", &test_mailmap_parsing__cleanup },
        _clar_cb_mailmap_parsing, 7, 1
    },
    {
        "merge::analysis (with bare repository)",
        { "initialize_with_bare_repository", &test_merge_analysis__initialize_with_bare_repository },
        { "cleanup", &test_merge_analysis__cleanup },
        _clar_cb_merge_analysis, 9, 1
    },
    {
        "merge::analysis (with nonbare repository)",
        { "initialize_with_nonbare_repository", &test_merge_analysis__initialize_with_nonbare_repository },
        { "cleanup", &test_merge_analysis__cleanup },
        _clar_cb_merge_analysis, 9, 1
    },
    {
        "merge::annotated::commit",
        { "initialize", &test_merge_annotated_commit__initialize },
        { "cleanup", &test_merge_annotated_commit__cleanup },
        _clar_cb_merge_annotated_commit, 1, 1
    },
    {
        "merge::driver",
        { "initialize", &test_merge_driver__initialize },
        { "cleanup", &test_merge_driver__cleanup },
        _clar_cb_merge_driver, 12, 1
    },
    {
        "merge::files",
        { "initialize", &test_merge_files__initialize },
        { "cleanup", &test_merge_files__cleanup },
        _clar_cb_merge_files, 12, 1
    },
    {
        "merge::trees::automerge",
        { "initialize", &test_merge_trees_automerge__initialize },
        { "cleanup", &test_merge_trees_automerge__cleanup },
        _clar_cb_merge_trees_automerge, 4, 1
    },
    {
        "merge::trees::commits",
        { "initialize", &test_merge_trees_commits__initialize },
        { "cleanup", &test_merge_trees_commits__cleanup },
        _clar_cb_merge_trees_commits, 4, 1
    },
    {
        "merge::trees::modeconflict",
        { "initialize", &test_merge_trees_modeconflict__initialize },
        { "cleanup", &test_merge_trees_modeconflict__cleanup },
        _clar_cb_merge_trees_modeconflict, 1, 1
    },
    {
        "merge::trees::recursive",
        { "initialize", &test_merge_trees_recursive__initialize },
        { "cleanup", &test_merge_trees_recursive__cleanup },
        _clar_cb_merge_trees_recursive, 18, 1
    },
    {
        "merge::trees::renames",
        { "initialize", &test_merge_trees_renames__initialize },
        { "cleanup", &test_merge_trees_renames__cleanup },
        _clar_cb_merge_trees_renames, 5, 1
    },
    {
        "merge::trees::treediff",
        { "initialize", &test_merge_trees_treediff__initialize },
        { "cleanup", &test_merge_trees_treediff__cleanup },
        _clar_cb_merge_trees_treediff, 5, 1
    },
    {
        "merge::trees::trivial",
        { "initialize", &test_merge_trees_trivial__initialize },
        { "cleanup", &test_merge_trees_trivial__cleanup },
        _clar_cb_merge_trees_trivial, 13, 1
    },
    {
        "merge::trees::whitespace",
        { "initialize", &test_merge_trees_whitespace__initialize },
        { "cleanup", &test_merge_trees_whitespace__cleanup },
        _clar_cb_merge_trees_whitespace, 3, 1
    },
    {
        "merge::workdir::dirty",
        { "initialize", &test_merge_workdir_dirty__initialize },
        { "cleanup", &test_merge_workdir_dirty__cleanup },
        _clar_cb_merge_workdir_dirty, 6, 1
    },
    {
        "merge::workdir::recursive",
        { "initialize", &test_merge_workdir_recursive__initialize },
        { "cleanup", &test_merge_workdir_recursive__cleanup },
        _clar_cb_merge_workdir_recursive, 2, 1
    },
    {
        "merge::workdir::renames",
        { "initialize", &test_merge_workdir_renames__initialize },
        { "cleanup", &test_merge_workdir_renames__cleanup },
        _clar_cb_merge_workdir_renames, 3, 1
    },
    {
        "merge::workdir::setup",
        { "initialize", &test_merge_workdir_setup__initialize },
        { "cleanup", &test_merge_workdir_setup__cleanup },
        _clar_cb_merge_workdir_setup, 32, 1
    },
    {
        "merge::workdir::simple",
        { "initialize", &test_merge_workdir_simple__initialize },
        { "cleanup", &test_merge_workdir_simple__cleanup },
        _clar_cb_merge_workdir_simple, 18, 1
    },
    {
        "merge::workdir::submodules",
        { "initialize", &test_merge_workdir_submodules__initialize },
        { "cleanup", &test_merge_workdir_submodules__cleanup },
        _clar_cb_merge_workdir_submodules, 3, 1
    },
    {
        "merge::workdir::trivial",
        { "initialize", &test_merge_workdir_trivial__initialize },
        { "cleanup", &test_merge_workdir_trivial__cleanup },
        _clar_cb_merge_workdir_trivial, 13, 1
    },
    {
        "message::trailer",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_message_trailer, 10, 1
    },
    {
        "network::cred",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_network_cred, 3, 1
    },
    {
        "network::fetchlocal",
        { NULL, NULL },
        { "cleanup", &test_network_fetchlocal__cleanup },
        _clar_cb_network_fetchlocal, 13, 1
    },
    {
        "network::refspecs",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_network_refspecs, 9, 1
    },
    {
        "network::remote::defaultbranch",
        { "initialize", &test_network_remote_defaultbranch__initialize },
        { "cleanup", &test_network_remote_defaultbranch__cleanup },
        _clar_cb_network_remote_defaultbranch, 6, 1
    },
    {
        "network::remote::delete",
        { "initialize", &test_network_remote_delete__initialize },
        { "cleanup", &test_network_remote_delete__cleanup },
        _clar_cb_network_remote_delete, 3, 1
    },
    {
        "network::remote::isvalidname",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_network_remote_isvalidname, 2, 1
    },
    {
        "network::remote::local",
        { "initialize", &test_network_remote_local__initialize },
        { "cleanup", &test_network_remote_local__cleanup },
        _clar_cb_network_remote_local, 19, 1
    },
    {
        "network::remote::push",
        { "initialize", &test_network_remote_push__initialize },
        { "cleanup", &test_network_remote_push__cleanup },
        _clar_cb_network_remote_push, 2, 1
    },
    {
        "network::remote::remotes",
        { "initialize", &test_network_remote_remotes__initialize },
        { "cleanup", &test_network_remote_remotes__cleanup },
        _clar_cb_network_remote_remotes, 26, 1
    },
    {
        "network::remote::rename",
        { "initialize", &test_network_remote_rename__initialize },
        { "cleanup", &test_network_remote_rename__cleanup },
        _clar_cb_network_remote_rename, 13, 1
    },
    {
        "notes::notes",
        { "initialize", &test_notes_notes__initialize },
        { "cleanup", &test_notes_notes__cleanup },
        _clar_cb_notes_notes, 23, 1
    },
    {
        "notes::notesref",
        { "initialize", &test_notes_notesref__initialize },
        { "cleanup", &test_notes_notesref__cleanup },
        _clar_cb_notes_notesref, 1, 1
    },
    {
        "object::blob::filter",
        { "initialize", &test_object_blob_filter__initialize },
        { "cleanup", &test_object_blob_filter__cleanup },
        _clar_cb_object_blob_filter, 3, 1
    },
    {
        "object::blob::fromstream",
        { "initialize", &test_object_blob_fromstream__initialize },
        { "cleanup", &test_object_blob_fromstream__cleanup },
        _clar_cb_object_blob_fromstream, 2, 1
    },
    {
        "object::blob::write",
        { NULL, NULL },
        { "cleanup", &test_object_blob_write__cleanup },
        _clar_cb_object_blob_write, 3, 1
    },
    {
        "object::cache (cache no blobs)",
        { "initialize_cache_no_blobs", &test_object_cache__initialize_cache_no_blobs },
        { "cleanup", &test_object_cache__cleanup },
        _clar_cb_object_cache, 3, 1
    },
    {
        "object::cache (cache tiny blobs)",
        { "initialize_cache_tiny_blobs", &test_object_cache__initialize_cache_tiny_blobs },
        { "cleanup", &test_object_cache__cleanup },
        _clar_cb_object_cache, 3, 1
    },
    {
        "object::cache (cache all blobs)",
        { "initialize_cache_all_blobs", &test_object_cache__initialize_cache_all_blobs },
        { "cleanup", &test_object_cache__cleanup },
        _clar_cb_object_cache, 3, 1
    },
    {
        "object::cache (cache no trees)",
        { "initialize_cache_no_trees", &test_object_cache__initialize_cache_no_trees },
        { "cleanup", &test_object_cache__cleanup },
        _clar_cb_object_cache, 3, 1
    },
    {
        "object::commit::commitstagedfile",
        { "initialize", &test_object_commit_commitstagedfile__initialize },
        { "cleanup", &test_object_commit_commitstagedfile__cleanup },
        _clar_cb_object_commit_commitstagedfile, 2, 1
    },
    {
        "object::commit::parse",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_object_commit_parse, 24, 1
    },
    {
        "object::lookup",
        { "initialize", &test_object_lookup__initialize },
        { "cleanup", &test_object_lookup__cleanup },
        _clar_cb_object_lookup, 6, 1
    },
    {
        "object::lookup256",
        { "initialize", &test_object_lookup256__initialize },
        { "cleanup", &test_object_lookup256__cleanup },
        _clar_cb_object_lookup256, 6, 1
    },
    {
        "object::lookupbypath",
        { "initialize", &test_object_lookupbypath__initialize },
        { "cleanup", &test_object_lookupbypath__cleanup },
        _clar_cb_object_lookupbypath, 4, 1
    },
    {
        "object::message",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_object_message, 16, 1
    },
    {
        "object::peel",
        { "initialize", &test_object_peel__initialize },
        { "cleanup", &test_object_peel__cleanup },
        _clar_cb_object_peel, 6, 1
    },
    {
        "object::raw::chars",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_object_raw_chars, 2, 1
    },
    {
        "object::raw::compare",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_object_raw_compare, 7, 1
    },
    {
        "object::raw::convert",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_object_raw_convert, 3, 1
    },
    {
        "object::raw::fromstr",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_object_raw_fromstr, 2, 1
    },
    {
        "object::raw::hash",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_object_raw_hash, 11, 1
    },
    {
        "object::raw::short",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_object_raw_short, 3, 1
    },
    {
        "object::raw::size",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_object_raw_size, 1, 1
    },
    {
        "object::raw::type2string",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_object_raw_type2string, 3, 1
    },
    {
        "object::raw::write",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_object_raw_write, 7, 1
    },
    {
        "object::shortid",
        { "initialize", &test_object_shortid__initialize },
        { "cleanup", &test_object_shortid__cleanup },
        _clar_cb_object_shortid, 1, 1
    },
    {
        "object::tag::list",
        { "initialize", &test_object_tag_list__initialize },
        { "cleanup", &test_object_tag_list__cleanup },
        _clar_cb_object_tag_list, 2, 1
    },
    {
        "object::tag::parse",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_object_tag_parse, 12, 1
    },
    {
        "object::tag::peel",
        { "initialize", &test_object_tag_peel__initialize },
        { "cleanup", &test_object_tag_peel__cleanup },
        _clar_cb_object_tag_peel, 3, 1
    },
    {
        "object::tag::read",
        { "initialize", &test_object_tag_read__initialize },
        { "cleanup", &test_object_tag_read__cleanup },
        _clar_cb_object_tag_read, 5, 1
    },
    {
        "object::tag::write",
        { "initialize", &test_object_tag_write__initialize },
        { "cleanup", &test_object_tag_write__cleanup },
        _clar_cb_object_tag_write, 11, 1
    },
    {
        "object::tree::attributes",
        { "initialize", &test_object_tree_attributes__initialize },
        { "cleanup", &test_object_tree_attributes__cleanup },
        _clar_cb_object_tree_attributes, 5, 1
    },
    {
        "object::tree::duplicateentries",
        { "initialize", &test_object_tree_duplicateentries__initialize },
        { "cleanup", &test_object_tree_duplicateentries__cleanup },
        _clar_cb_object_tree_duplicateentries, 2, 1
    },
    {
        "object::tree::frompath",
        { "initialize", &test_object_tree_frompath__initialize },
        { "cleanup", &test_object_tree_frompath__cleanup },
        _clar_cb_object_tree_frompath, 2, 1
    },
    {
        "object::tree::parse",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_object_tree_parse, 14, 1
    },
    {
        "object::tree::read",
        { "initialize", &test_object_tree_read__initialize },
        { "cleanup", &test_object_tree_read__cleanup },
        _clar_cb_object_tree_read, 3, 1
    },
    {
        "object::tree::update",
        { "initialize", &test_object_tree_update__initialize },
        { "cleanup", &test_object_tree_update__cleanup },
        _clar_cb_object_tree_update, 9, 1
    },
    {
        "object::tree::walk",
        { "initialize", &test_object_tree_walk__initialize },
        { "cleanup", &test_object_tree_walk__cleanup },
        _clar_cb_object_tree_walk, 3, 1
    },
    {
        "object::tree::write",
        { "initialize", &test_object_tree_write__initialize },
        { "cleanup", &test_object_tree_write__cleanup },
        _clar_cb_object_tree_write, 9, 1
    },
    {
        "object::validate",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_object_validate, 6, 1
    },
    {
        "odb::alternates",
        { NULL, NULL },
        { "cleanup", &test_odb_alternates__cleanup },
        _clar_cb_odb_alternates, 2, 1
    },
    {
        "odb::backend::loose",
        { "initialize", &test_odb_backend_loose__initialize },
        { "cleanup", &test_odb_backend_loose__cleanup },
        _clar_cb_odb_backend_loose, 2, 1
    },
    {
        "odb::backend::mempack",
        { "initialize", &test_odb_backend_mempack__initialize },
        { "cleanup", &test_odb_backend_mempack__cleanup },
        _clar_cb_odb_backend_mempack, 5, 1
    },
    {
        "odb::backend::multiple",
        { "initialize", &test_odb_backend_multiple__initialize },
        { "cleanup", &test_odb_backend_multiple__cleanup },
        _clar_cb_odb_backend_multiple, 5, 1
    },
    {
        "odb::backend::nobackend",
        { "initialize", &test_odb_backend_nobackend__initialize },
        { "cleanup", &test_odb_backend_nobackend__cleanup },
        _clar_cb_odb_backend_nobackend, 1, 1
    },
    {
        "odb::backend::nonrefreshing",
        { "initialize", &test_odb_backend_nonrefreshing__initialize },
        { "cleanup", &test_odb_backend_nonrefreshing__cleanup },
        _clar_cb_odb_backend_nonrefreshing, 9, 1
    },
    {
        "odb::backend::refreshing",
        { "initialize", &test_odb_backend_refreshing__initialize },
        { "cleanup", &test_odb_backend_refreshing__cleanup },
        _clar_cb_odb_backend_refreshing, 11, 1
    },
    {
        "odb::backend::simple",
        { "initialize", &test_odb_backend_simple__initialize },
        { "cleanup", &test_odb_backend_simple__cleanup },
        _clar_cb_odb_backend_simple, 14, 1
    },
    {
        "odb::emptyobjects",
        { "initialize", &test_odb_emptyobjects__initialize },
        { "cleanup", &test_odb_emptyobjects__cleanup },
        _clar_cb_odb_emptyobjects, 3, 1
    },
    {
        "odb::foreach",
        { NULL, NULL },
        { "cleanup", &test_odb_foreach__cleanup },
        _clar_cb_odb_foreach, 4, 1
    },
    {
        "odb::freshen",
        { "initialize", &test_odb_freshen__initialize },
        { "cleanup", &test_odb_freshen__cleanup },
        _clar_cb_odb_freshen, 5, 1
    },
    {
        "odb::largefiles",
        { "initialize", &test_odb_largefiles__initialize },
        { "cleanup", &test_odb_largefiles__cleanup },
        _clar_cb_odb_largefiles, 6, 1
    },
    {
        "odb::loose",
        { "initialize", &test_odb_loose__initialize },
        { "cleanup", &test_odb_loose__cleanup },
        _clar_cb_odb_loose, 15, 1
    },
    {
        "odb::mixed",
        { "initialize", &test_odb_mixed__initialize },
        { "cleanup", &test_odb_mixed__cleanup },
        _clar_cb_odb_mixed, 4, 1
    },
    {
        "odb::open",
        { "initialize", &test_odb_open__initialize },
        { "cleanup", &test_odb_open__cleanup },
        _clar_cb_odb_open, 1, 1
    },
    {
        "odb::packed",
        { "initialize", &test_odb_packed__initialize },
        { "cleanup", &test_odb_packed__cleanup },
        _clar_cb_odb_packed, 3, 1
    },
    {
        "odb::packed256",
        { "initialize", &test_odb_packed256__initialize },
        { "cleanup", &test_odb_packed256__cleanup },
        _clar_cb_odb_packed256, 3, 1
    },
    {
        "odb::packedone",
        { "initialize", &test_odb_packedone__initialize },
        { "cleanup", &test_odb_packedone__cleanup },
        _clar_cb_odb_packedone, 2, 1
    },
    {
        "odb::packedone256",
        { "initialize", &test_odb_packedone256__initialize },
        { "cleanup", &test_odb_packedone256__cleanup },
        _clar_cb_odb_packedone256, 2, 1
    },
    {
        "odb::sorting",
        { "initialize", &test_odb_sorting__initialize },
        { "cleanup", &test_odb_sorting__cleanup },
        _clar_cb_odb_sorting, 3, 1
    },
    {
        "odb::streamwrite",
        { "initialize", &test_odb_streamwrite__initialize },
        { "cleanup", &test_odb_streamwrite__cleanup },
        _clar_cb_odb_streamwrite, 3, 1
    },
    {
        "online::badssl",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_online_badssl, 4, 0
    },
    {
        "online::clone",
        { "initialize", &test_online_clone__initialize },
        { "cleanup", &test_online_clone__cleanup },
        _clar_cb_online_clone, 53, 0
    },
    {
        "online::customcert",
        { "initialize", &test_online_customcert__initialize },
        { "cleanup", &test_online_customcert__cleanup },
        _clar_cb_online_customcert, 2, 0
    },
    {
        "online::fetch",
        { "initialize", &test_online_fetch__initialize },
        { "cleanup", &test_online_fetch__cleanup },
        _clar_cb_online_fetch, 16, 0
    },
    {
        "online::fetchhead",
        { "initialize", &test_online_fetchhead__initialize },
        { "cleanup", &test_online_fetchhead__cleanup },
        _clar_cb_online_fetchhead, 7, 0
    },
    {
        "online::push",
        { "initialize", &test_online_push__initialize },
        { "cleanup", &test_online_push__cleanup },
        _clar_cb_online_push, 22, 0
    },
    {
        "online::remotes",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_online_remotes, 6, 0
    },
    {
        "online::shallow",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_online_shallow, 7, 0
    },
    {
        "pack::filelimit (tiny)",
        { "initialize_tiny", &test_pack_filelimit__initialize_tiny },
        { "cleanup", &test_pack_filelimit__cleanup },
        _clar_cb_pack_filelimit, 1, 1
    },
    {
        "pack::filelimit (medium)",
        { "initialize_medium", &test_pack_filelimit__initialize_medium },
        { "cleanup", &test_pack_filelimit__cleanup },
        _clar_cb_pack_filelimit, 1, 1
    },
    {
        "pack::filelimit (unlimited)",
        { "initialize_unlimited", &test_pack_filelimit__initialize_unlimited },
        { "cleanup", &test_pack_filelimit__cleanup },
        _clar_cb_pack_filelimit, 1, 1
    },
    {
        "pack::indexer",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_pack_indexer, 8, 1
    },
    {
        "pack::midx",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_pack_midx, 4, 1
    },
    {
        "pack::packbuilder",
        { "initialize", &test_pack_packbuilder__initialize },
        { "cleanup", &test_pack_packbuilder__cleanup },
        _clar_cb_pack_packbuilder, 12, 1
    },
    {
        "pack::sharing",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_pack_sharing, 1, 1
    },
    {
        "pack::threadsafety",
        { "initialize", &test_pack_threadsafety__initialize },
        { "cleanup", &test_pack_threadsafety__cleanup },
        _clar_cb_pack_threadsafety, 1, 1
    },
    {
        "patch::parse",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_patch_parse, 17, 1
    },
    {
        "patch::print",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_patch_print, 27, 1
    },
    {
        "path::validate",
        { NULL, NULL },
        { "cleanup", &test_path_validate__cleanup },
        _clar_cb_path_validate, 2, 1
    },
    {
        "perf::merge",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_perf_merge, 1, 0
    },
    {
        "rebase::abort",
        { "initialize", &test_rebase_abort__initialize },
        { "cleanup", &test_rebase_abort__cleanup },
        _clar_cb_rebase_abort, 7, 1
    },
    {
        "rebase::inmemory",
        { "initialize", &test_rebase_inmemory__initialize },
        { "cleanup", &test_rebase_inmemory__cleanup },
        _clar_cb_rebase_inmemory, 4, 1
    },
    {
        "rebase::iterator",
        { "initialize", &test_rebase_iterator__initialize },
        { "cleanup", &test_rebase_iterator__cleanup },
        _clar_cb_rebase_iterator, 2, 1
    },
    {
        "rebase::merge",
        { "initialize", &test_rebase_merge__initialize },
        { "cleanup", &test_rebase_merge__cleanup },
        _clar_cb_rebase_merge, 19, 1
    },
    {
        "rebase::setup",
        { "initialize", &test_rebase_setup__initialize },
        { "cleanup", &test_rebase_setup__cleanup },
        _clar_cb_rebase_setup, 14, 1
    },
    {
        "rebase::sign",
        { "initialize", &test_rebase_sign__initialize },
        { "cleanup", &test_rebase_sign__cleanup },
        _clar_cb_rebase_sign, 6, 1
    },
    {
        "rebase::submodule",
        { "initialize", &test_rebase_submodule__initialize },
        { "cleanup", &test_rebase_submodule__cleanup },
        _clar_cb_rebase_submodule, 1, 1
    },
    {
        "refs::basic",
        { "initialize", &test_refs_basic__initialize },
        { "cleanup", &test_refs_basic__cleanup },
        _clar_cb_refs_basic, 2, 1
    },
    {
        "refs::branches::checkedout",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_refs_branches_checkedout, 4, 1
    },
    {
        "refs::branches::create",
        { "initialize", &test_refs_branches_create__initialize },
        { "cleanup", &test_refs_branches_create__cleanup },
        _clar_cb_refs_branches_create, 10, 1
    },
    {
        "refs::branches::delete",
        { "initialize", &test_refs_branches_delete__initialize },
        { "cleanup", &test_refs_branches_delete__cleanup },
        _clar_cb_refs_branches_delete, 10, 1
    },
    {
        "refs::branches::ishead",
        { "initialize", &test_refs_branches_ishead__initialize },
        { "cleanup", &test_refs_branches_ishead__cleanup },
        _clar_cb_refs_branches_ishead, 6, 1
    },
    {
        "refs::branches::iterator",
        { "initialize", &test_refs_branches_iterator__initialize },
        { "cleanup", &test_refs_branches_iterator__cleanup },
        _clar_cb_refs_branches_iterator, 5, 1
    },
    {
        "refs::branches::lookup",
        { "initialize", &test_refs_branches_lookup__initialize },
        { "cleanup", &test_refs_branches_lookup__cleanup },
        _clar_cb_refs_branches_lookup, 8, 1
    },
    {
        "refs::branches::move",
        { "initialize", &test_refs_branches_move__initialize },
        { "cleanup", &test_refs_branches_move__cleanup },
        _clar_cb_refs_branches_move, 12, 1
    },
    {
        "refs::branches::name",
        { "initialize", &test_refs_branches_name__initialize },
        { "cleanup", &test_refs_branches_name__cleanup },
        _clar_cb_refs_branches_name, 4, 1
    },
    {
        "refs::branches::remote",
        { "initialize", &test_refs_branches_remote__initialize },
        { "cleanup", &test_refs_branches_remote__cleanup },
        _clar_cb_refs_branches_remote, 4, 1
    },
    {
        "refs::branches::upstream",
        { "initialize", &test_refs_branches_upstream__initialize },
        { "cleanup", &test_refs_branches_upstream__cleanup },
        _clar_cb_refs_branches_upstream, 11, 1
    },
    {
        "refs::branches::upstreamname",
        { "initialize", &test_refs_branches_upstreamname__initialize },
        { "cleanup", &test_refs_branches_upstreamname__cleanup },
        _clar_cb_refs_branches_upstreamname, 2, 1
    },
    {
        "refs::crashes",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_refs_crashes, 2, 1
    },
    {
        "refs::create",
        { "initialize", &test_refs_create__initialize },
        { "cleanup", &test_refs_create__cleanup },
        _clar_cb_refs_create, 13, 1
    },
    {
        "refs::delete",
        { "initialize", &test_refs_delete__initialize },
        { "cleanup", &test_refs_delete__cleanup },
        _clar_cb_refs_delete, 4, 1
    },
    {
        "refs::dup",
        { "initialize", &test_refs_dup__initialize },
        { "cleanup", &test_refs_dup__cleanup },
        _clar_cb_refs_dup, 2, 1
    },
    {
        "refs::foreachglob",
        { "initialize", &test_refs_foreachglob__initialize },
        { "cleanup", &test_refs_foreachglob__cleanup },
        _clar_cb_refs_foreachglob, 6, 1
    },
    {
        "refs::isvalidname",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_refs_isvalidname, 2, 1
    },
    {
        "refs::iterator",
        { "initialize", &test_refs_iterator__initialize },
        { "cleanup", &test_refs_iterator__cleanup },
        _clar_cb_refs_iterator, 8, 1
    },
    {
        "refs::list",
        { "initialize", &test_refs_list__initialize },
        { "cleanup", &test_refs_list__cleanup },
        _clar_cb_refs_list, 2, 1
    },
    {
        "refs::listall",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_refs_listall, 3, 1
    },
    {
        "refs::lookup",
        { "initialize", &test_refs_lookup__initialize },
        { "cleanup", &test_refs_lookup__cleanup },
        _clar_cb_refs_lookup, 5, 1
    },
    {
        "refs::namespaces",
        { "initialize", &test_refs_namespaces__initialize },
        { "cleanup", &test_refs_namespaces__cleanup },
        _clar_cb_refs_namespaces, 2, 1
    },
    {
        "refs::normalize",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_refs_normalize, 6, 1
    },
    {
        "refs::overwrite",
        { "initialize", &test_refs_overwrite__initialize },
        { "cleanup", &test_refs_overwrite__cleanup },
        _clar_cb_refs_overwrite, 4, 1
    },
    {
        "refs::pack",
        { "initialize", &test_refs_pack__initialize },
        { "cleanup", &test_refs_pack__cleanup },
        _clar_cb_refs_pack, 3, 1
    },
    {
        "refs::peel",
        { "initialize", &test_refs_peel__initialize },
        { "cleanup", &test_refs_peel__cleanup },
        _clar_cb_refs_peel, 7, 1
    },
    {
        "refs::races",
        { "initialize", &test_refs_races__initialize },
        { "cleanup", &test_refs_races__cleanup },
        _clar_cb_refs_races, 6, 1
    },
    {
        "refs::read",
        { "initialize", &test_refs_read__initialize },
        { "cleanup", &test_refs_read__cleanup },
        _clar_cb_refs_read, 15, 1
    },
    {
        "refs::reflog::drop",
        { "initialize", &test_refs_reflog_drop__initialize },
        { "cleanup", &test_refs_reflog_drop__cleanup },
        _clar_cb_refs_reflog_drop, 7, 1
    },
    {
        "refs::reflog::messages",
        { "initialize", &test_refs_reflog_messages__initialize },
        { "cleanup", &test_refs_reflog_messages__cleanup },
        _clar_cb_refs_reflog_messages, 14, 1
    },
    {
        "refs::reflog::reflog",
        { "initialize", &test_refs_reflog_reflog__initialize },
        { "cleanup", &test_refs_reflog_reflog__cleanup },
        _clar_cb_refs_reflog_reflog, 18, 1
    },
    {
        "refs::rename",
        { "initialize", &test_refs_rename__initialize },
        { "cleanup", &test_refs_rename__cleanup },
        _clar_cb_refs_rename, 11, 1
    },
    {
        "refs::revparse",
        { "initialize", &test_refs_revparse__initialize },
        { "cleanup", &test_refs_revparse__cleanup },
        _clar_cb_refs_revparse, 36, 1
    },
    {
        "refs::setter",
        { "initialize", &test_refs_setter__initialize },
        { "cleanup", &test_refs_setter__cleanup },
        _clar_cb_refs_setter, 4, 1
    },
    {
        "refs::shorthand",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_refs_shorthand, 1, 1
    },
    {
        "refs::tags::name",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_refs_tags_name, 1, 1
    },
    {
        "refs::transactions",
        { "initialize", &test_refs_transactions__initialize },
        { "cleanup", &test_refs_transactions__cleanup },
        _clar_cb_refs_transactions, 9, 1
    },
    {
        "refs::unicode",
        { "initialize", &test_refs_unicode__initialize },
        { "cleanup", &test_refs_unicode__cleanup },
        _clar_cb_refs_unicode, 1, 1
    },
    {
        "refs::update",
        { "initialize", &test_refs_update__initialize },
        { "cleanup", &test_refs_update__cleanup },
        _clar_cb_refs_update, 1, 1
    },
    {
        "remote::create",
        { "initialize", &test_remote_create__initialize },
        { "cleanup", &test_remote_create__cleanup },
        _clar_cb_remote_create, 22, 1
    },
    {
        "remote::fetch",
        { "initialize", &test_remote_fetch__initialize },
        { "cleanup", &test_remote_fetch__cleanup },
        _clar_cb_remote_fetch, 2, 1
    },
    {
        "remote::httpproxy",
        { "initialize", &test_remote_httpproxy__initialize },
        { "cleanup", &test_remote_httpproxy__cleanup },
        _clar_cb_remote_httpproxy, 4, 1
    },
    {
        "remote::insteadof",
        { "initialize", &test_remote_insteadof__initialize },
        { "cleanup", &test_remote_insteadof__cleanup },
        _clar_cb_remote_insteadof, 10, 1
    },
    {
        "remote::list",
        { "initialize", &test_remote_list__initialize },
        { "cleanup", &test_remote_list__cleanup },
        _clar_cb_remote_list, 1, 1
    },
    {
        "repo::config",
        { "initialize", &test_repo_config__initialize },
        { "cleanup", &test_repo_config__cleanup },
        _clar_cb_repo_config, 3, 1
    },
    {
        "repo::discover",
        { "initialize", &test_repo_discover__initialize },
        { "cleanup", &test_repo_discover__cleanup },
        _clar_cb_repo_discover, 10, 1
    },
    {
        "repo::env",
        { "initialize", &test_repo_env__initialize },
        { "cleanup", &test_repo_env__cleanup },
        _clar_cb_repo_env, 4, 1
    },
    {
        "repo::extensions",
        { "initialize", &test_repo_extensions__initialize },
        { "cleanup", &test_repo_extensions__cleanup },
        _clar_cb_repo_extensions, 4, 1
    },
    {
        "repo::getters",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_repo_getters, 5, 1
    },
    {
        "repo::hashfile",
        { "initialize", &test_repo_hashfile__initialize },
        { "cleanup", &test_repo_hashfile__cleanup },
        _clar_cb_repo_hashfile, 3, 1
    },
    {
        "repo::head",
        { "initialize", &test_repo_head__initialize },
        { "cleanup", &test_repo_head__cleanup },
        _clar_cb_repo_head, 15, 1
    },
    {
        "repo::headtree",
        { "initialize", &test_repo_headtree__initialize },
        { "cleanup", &test_repo_headtree__cleanup },
        _clar_cb_repo_headtree, 4, 1
    },
    {
        "repo::init",
        { "initialize", &test_repo_init__initialize },
        { "cleanup", &test_repo_init__cleanup },
        _clar_cb_repo_init, 32, 1
    },
    {
        "repo::message",
        { "initialize", &test_repo_message__initialize },
        { "cleanup", &test_repo_message__cleanup },
        _clar_cb_repo_message, 2, 1
    },
    {
        "repo::new",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_repo_new, 4, 1
    },
    {
        "repo::objectformat",
        { "initialize", &test_repo_objectformat__initialize },
        { "cleanup", &test_repo_objectformat__cleanup },
        _clar_cb_repo_objectformat, 4, 1
    },
    {
        "repo::open",
        { "initialize", &test_repo_open__initialize },
        { "cleanup", &test_repo_open__cleanup },
        _clar_cb_repo_open, 27, 1
    },
    {
        "repo::pathspec",
        { "initialize", &test_repo_pathspec__initialize },
        { "cleanup", &test_repo_pathspec__cleanup },
        _clar_cb_repo_pathspec, 10, 1
    },
    {
        "repo::reservedname",
        { NULL, NULL },
        { "cleanup", &test_repo_reservedname__cleanup },
        _clar_cb_repo_reservedname, 5, 1
    },
    {
        "repo::setters",
        { "initialize", &test_repo_setters__initialize },
        { "cleanup", &test_repo_setters__cleanup },
        _clar_cb_repo_setters, 5, 1
    },
    {
        "repo::shallow",
        { "initialize", &test_repo_shallow__initialize },
        { "cleanup", &test_repo_shallow__cleanup },
        _clar_cb_repo_shallow, 4, 1
    },
    {
        "repo::state",
        { "initialize", &test_repo_state__initialize },
        { "cleanup", &test_repo_state__cleanup },
        _clar_cb_repo_state, 13, 1
    },
    {
        "repo::template",
        { "initialize", &test_repo_template__initialize },
        { "cleanup", &test_repo_template__cleanup },
        _clar_cb_repo_template, 8, 1
    },
    {
        "reset::default",
        { "initialize", &test_reset_default__initialize },
        { "cleanup", &test_reset_default__cleanup },
        _clar_cb_reset_default, 5, 1
    },
    {
        "reset::hard",
        { "initialize", &test_reset_hard__initialize },
        { "cleanup", &test_reset_hard__cleanup },
        _clar_cb_reset_hard, 6, 1
    },
    {
        "reset::mixed",
        { "initialize", &test_reset_mixed__initialize },
        { "cleanup", &test_reset_mixed__cleanup },
        _clar_cb_reset_mixed, 3, 1
    },
    {
        "reset::soft",
        { "initialize", &test_reset_soft__initialize },
        { "cleanup", &test_reset_soft__cleanup },
        _clar_cb_reset_soft, 9, 1
    },
    {
        "revert::bare",
        { "initialize", &test_revert_bare__initialize },
        { "cleanup", &test_revert_bare__cleanup },
        _clar_cb_revert_bare, 3, 1
    },
    {
        "revert::rename",
        { "initialize", &test_revert_rename__initialize },
        { "cleanup", &test_revert_rename__cleanup },
        _clar_cb_revert_rename, 1, 1
    },
    {
        "revert::workdir",
        { "initialize", &test_revert_workdir__initialize },
        { "cleanup", &test_revert_workdir__cleanup },
        _clar_cb_revert_workdir, 15, 1
    },
    {
        "revwalk::basic",
        { "initialize", &test_revwalk_basic__initialize },
        { "cleanup", &test_revwalk_basic__cleanup },
        _clar_cb_revwalk_basic, 24, 1
    },
    {
        "revwalk::hidecb",
        { "initialize", &test_revwalk_hidecb__initialize },
        { "cleanup", &test_revwalk_hidecb__cleanup },
        _clar_cb_revwalk_hidecb, 7, 1
    },
    {
        "revwalk::mergebase",
        { "initialize", &test_revwalk_mergebase__initialize },
        { "cleanup", &test_revwalk_mergebase__cleanup },
        _clar_cb_revwalk_mergebase, 14, 1
    },
    {
        "revwalk::signatureparsing",
        { "initialize", &test_revwalk_signatureparsing__initialize },
        { "cleanup", &test_revwalk_signatureparsing__cleanup },
        _clar_cb_revwalk_signatureparsing, 1, 1
    },
    {
        "revwalk::simplify",
        { NULL, NULL },
        { "cleanup", &test_revwalk_simplify__cleanup },
        _clar_cb_revwalk_simplify, 1, 1
    },
    {
        "stash::apply",
        { "initialize", &test_stash_apply__initialize },
        { "cleanup", &test_stash_apply__cleanup },
        _clar_cb_stash_apply, 19, 1
    },
    {
        "stash::drop",
        { "initialize", &test_stash_drop__initialize },
        { "cleanup", &test_stash_drop__cleanup },
        _clar_cb_stash_drop, 7, 1
    },
    {
        "stash::foreach",
        { "initialize", &test_stash_foreach__initialize },
        { "cleanup", &test_stash_foreach__cleanup },
        _clar_cb_stash_foreach, 2, 1
    },
    {
        "stash::save",
        { "initialize", &test_stash_save__initialize },
        { "cleanup", &test_stash_save__cleanup },
        _clar_cb_stash_save, 20, 1
    },
    {
        "stash::submodules",
        { "initialize", &test_stash_submodules__initialize },
        { "cleanup", &test_stash_submodules__cleanup },
        _clar_cb_stash_submodules, 2, 1
    },
    {
        "status::renames",
        { "initialize", &test_status_renames__initialize },
        { "cleanup", &test_status_renames__cleanup },
        _clar_cb_status_renames, 18, 1
    },
    {
        "status::single",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_status_single, 2, 1
    },
    {
        "status::submodules",
        { "initialize", &test_status_submodules__initialize },
        { "cleanup", &test_status_submodules__cleanup },
        _clar_cb_status_submodules, 11, 1
    },
    {
        "status::worktree",
        { NULL, NULL },
        { "cleanup", &test_status_worktree__cleanup },
        _clar_cb_status_worktree, 45, 1
    },
    {
        "status::worktree::init",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_status_worktree_init, 8, 1
    },
    {
        "stream::deprecated",
        { NULL, NULL },
        { "cleanup", &test_stream_deprecated__cleanup },
        _clar_cb_stream_deprecated, 1, 1
    },
    {
        "stream::registration",
        { NULL, NULL },
        { "cleanup", &test_stream_registration__cleanup },
        _clar_cb_stream_registration, 3, 1
    },
    {
        "stress::diff",
        { "initialize", &test_stress_diff__initialize },
        { "cleanup", &test_stress_diff__cleanup },
        _clar_cb_stress_diff, 2, 0
    },
    {
        "submodule::add",
        { NULL, NULL },
        { "cleanup", &test_submodule_add__cleanup },
        _clar_cb_submodule_add, 9, 1
    },
    {
        "submodule::escape",
        { NULL, NULL },
        { "cleanup", &test_submodule_escape__cleanup },
        _clar_cb_submodule_escape, 2, 1
    },
    {
        "submodule::init",
        { NULL, NULL },
        { "cleanup", &test_submodule_init__cleanup },
        _clar_cb_submodule_init, 3, 1
    },
    {
        "submodule::inject::option",
        { "initialize", &test_submodule_inject_option__initialize },
        { "cleanup", &test_submodule_inject_option__cleanup },
        _clar_cb_submodule_inject_option, 2, 1
    },
    {
        "submodule::lookup",
        { "initialize", &test_submodule_lookup__initialize },
        { "cleanup", &test_submodule_lookup__cleanup },
        _clar_cb_submodule_lookup, 16, 1
    },
    {
        "submodule::modify",
        { "initialize", &test_submodule_modify__initialize },
        { NULL, NULL },
        _clar_cb_submodule_modify, 8, 1
    },
    {
        "submodule::nosubs",
        { NULL, NULL },
        { "cleanup", &test_submodule_nosubs__cleanup },
        _clar_cb_submodule_nosubs, 5, 1
    },
    {
        "submodule::open",
        { "initialize", &test_submodule_open__initialize },
        { "cleanup", &test_submodule_open__cleanup },
        _clar_cb_submodule_open, 3, 1
    },
    {
        "submodule::repository::init",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_submodule_repository_init, 1, 1
    },
    {
        "submodule::status",
        { "initialize", &test_submodule_status__initialize },
        { "cleanup", &test_submodule_status__cleanup },
        _clar_cb_submodule_status, 7, 1
    },
    {
        "submodule::update",
        { NULL, NULL },
        { "cleanup", &test_submodule_update__cleanup },
        _clar_cb_submodule_update, 8, 1
    },
    {
        "threads::atomic",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_threads_atomic, 13, 1
    },
    {
        "threads::basic",
        { "initialize", &test_threads_basic__initialize },
        { "cleanup", &test_threads_basic__cleanup },
        _clar_cb_threads_basic, 4, 1
    },
    {
        "threads::diff",
        { "initialize", &test_threads_diff__initialize },
        { "cleanup", &test_threads_diff__cleanup },
        _clar_cb_threads_diff, 2, 1
    },
    {
        "threads::iterator",
        { NULL, NULL },
        { "cleanup", &test_threads_iterator__cleanup },
        _clar_cb_threads_iterator, 1, 1
    },
    {
        "threads::refdb",
        { "initialize", &test_threads_refdb__initialize },
        { "cleanup", &test_threads_refdb__cleanup },
        _clar_cb_threads_refdb, 1, 1
    },
    {
        "threads::tlsdata",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_threads_tlsdata, 2, 1
    },
    {
        "trace::trace",
        { "initialize", &test_trace_trace__initialize },
        { "cleanup", &test_trace_trace__cleanup },
        _clar_cb_trace_trace, 6, 1
    },
    {
        "trace::windows::stacktrace",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_trace_windows_stacktrace, 3, 1
    },
    {
        "transport::register",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_transport_register, 5, 1
    },
    {
        "transport::ssh::exec",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_transport_ssh_exec, 3, 1
    },
    {
        "transports::smart::packet",
        { NULL, NULL },
        { NULL, NULL },
        _clar_cb_transports_smart_packet, 13, 1
    },
    {
        "win32::forbidden",
        { "initialize", &test_win32_forbidden__initialize },
        { "cleanup", &test_win32_forbidden__cleanup },
        _clar_cb_win32_forbidden, 10, 1
    },
    {
        "win32::longpath",
        { "initialize", &test_win32_longpath__initialize },
        { "cleanup", &test_win32_longpath__cleanup },
        _clar_cb_win32_longpath, 4, 1
    },
    {
        "win32::systemdir",
        { "initialize", &test_win32_systemdir__initialize },
        { "cleanup", &test_win32_systemdir__cleanup },
        _clar_cb_win32_systemdir, 8, 1
    },
    {
        "worktree::bare",
        { "initialize", &test_worktree_bare__initialize },
        { "cleanup", &test_worktree_bare__cleanup },
        _clar_cb_worktree_bare, 3, 1
    },
    {
        "worktree::config",
        { "initialize", &test_worktree_config__initialize },
        { "cleanup", &test_worktree_config__cleanup },
        _clar_cb_worktree_config, 5, 1
    },
    {
        "worktree::merge",
        { "initialize", &test_worktree_merge__initialize },
        { "cleanup", &test_worktree_merge__cleanup },
        _clar_cb_worktree_merge, 3, 1
    },
    {
        "worktree::open",
        { "initialize", &test_worktree_open__initialize },
        { "cleanup", &test_worktree_open__cleanup },
        _clar_cb_worktree_open, 8, 1
    },
    {
        "worktree::reflog",
        { "initialize", &test_worktree_reflog__initialize },
        { "cleanup", &test_worktree_reflog__cleanup },
        _clar_cb_worktree_reflog, 4, 1
    },
    {
        "worktree::refs",
        { "initialize", &test_worktree_refs__initialize },
        { "cleanup", &test_worktree_refs__cleanup },
        _clar_cb_worktree_refs, 14, 1
    },
    {
        "worktree::repository",
        { "initialize", &test_worktree_repository__initialize },
        { "cleanup", &test_worktree_repository__cleanup },
        _clar_cb_worktree_repository, 4, 1
    },
    {
        "worktree::submodule",
        { "initialize", &test_worktree_submodule__initialize },
        { "cleanup", &test_worktree_submodule__cleanup },
        _clar_cb_worktree_submodule, 4, 1
    },
    {
        "worktree::worktree",
        { "initialize", &test_worktree_worktree__initialize },
        { "cleanup", &test_worktree_worktree__cleanup },
        _clar_cb_worktree_worktree, 37, 1
    }
};
static const size_t _clar_suite_count = 382;
static const size_t _clar_callback_count = 3079;
